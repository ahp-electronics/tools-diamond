#$Header:

package provide IP_Templates 1.0.0

#********************************************************************************
# REVEAL Version 0.1 Template files
#********************************************************************************


#*******************************************
# IP Generation Scripts
#*******************************************
#
# Script for generating:
#
#    trig.v
#    reveal.v
#    reveal_bb.v
#    reveal_inst.v
#    reveal_sim.v
#
#*******************************************


#************************************************
# Generate trig.v
#************************************************
proc WriteTrigVerilog {} {
	global Para

	set outFile [file join "$Para(BuildDir)" "$Para(ModuleName)_trig_gen.v"]
	if [catch {open $outFile w} fileId] {
	        set Para(msg) "ERROR: Cannot open file: $outFile!\n"
		return -1
	}
	set Para(Date) [clock format [clock seconds] -format "%m/%d/%Y"]
	set Para(Time) [clock format [clock seconds] -format "%H:%M:%S"]

	puts $fileId "//============================================================================="
	puts $fileId "// Verilog module generated by IPExpress    $Para(Date)    $Para(Time)         "
	puts $fileId "// Filename: $Para(ModuleName)_trig_gen.v                                          "
	puts $fileId "// Copyright(c) 2006 Lattice Semiconductor Corporation. All rights reserved.   "
	puts $fileId "//============================================================================="
	puts $fileId ""
	puts $fileId "/* WARNING - Changes to this file should be performed by re-running IPexpress"
	puts $fileId "or modifying the .LPC file and regenerating the core.  Other changes may lead"
	puts $fileId "to inconsistent simulation and/or implemenation results */"
	puts $fileId ""

	puts $fileId "module $Para(ModuleName)_trig ("
        puts $fileId "    clk,"
        puts $fileId "    reset_n,"

        for {set x 0} {$x<$Para(NUM_TU)} {incr x} {
        puts $fileId "    tu_in_$x,"
        }

        puts $fileId "    wr_din,"
        puts $fileId "    rd_dout_trig,"
        puts $fileId "    addr,"
        puts $fileId "    ren,"
        puts $fileId "    wen,"
        puts $fileId "    wen_jtck,"
        puts $fileId "    capture_clk,"
        puts $fileId "    clear,"
        puts $fileId "    parity_err,"
        puts $fileId "    te_prog_din,"
        puts $fileId "    ip_enable_bit,"
        puts $fileId "    jtck,"
        puts $fileId "    jrstn,"
        puts $fileId "    jshift,"
        puts $fileId "    jshift_d1,"
        puts $fileId "    jce2,"
        puts $fileId "    capture_dr,"
        puts $fileId "    tt_prog_en_0,"
        puts $fileId "    even_parity,"
        if {$Para(PORDebug)} {
        puts $fileId "    trigger_en,"
        }
        puts $fileId "    trigger"
        puts $fileId ");"
        puts $fileId ""
        puts $fileId "// PARAMETERS DEFINED BY ipEXPRESS"
        puts $fileId "localparam NUM_TU = $Para(NUM_TU);"
	puts $fileId "localparam NUM_TE = $Para(NUM_TE);"
	puts $fileId "localparam NUM_TCNT_BITS = $Para(NUM_TCNT_BITS);"

        for {set y 0} {$y<$Para(NUM_TE)} {incr y} {
	puts $fileId "localparam NUM_TE_ROW_$y  = $Para(NUM_TE_ROW_$y);"
	puts $fileId "localparam NUM_TE_COL_$y  = $Para(NUM_TE_COL_$y);"
	puts $fileId "localparam TE_EBR_$y      = $Para(TE_EBR_$y);"
	puts $fileId "localparam NUM_TE_EVENT_CNT_BITS_$y = $Para(NUM_TE_EVENT_CNT_BITS_$y);"
        }

        for {set z 0} {$z<$Para(NUM_TU)} {incr z} {
	puts $fileId "localparam NUM_TU_BITS_$z = $Para(NUM_TU_BITS_$z);"
        }

	puts $fileId "localparam GSR_ENABLE  = $Para(GSR_ENABLE);"
	puts $fileId "localparam LSCC_FAMILY = \"$Para(tech_pmi)\";"
        if {$Para(PORDebug)} {
        puts $fileId "localparam TE_INIT           = $Para(TE_INIT);"
        puts $fileId "localparam TE_NUM_THEN       = $Para(TE_NUM_THEN);"
        puts $fileId "localparam TE_NEXT_THEN      = $Para(TE_NEXT_THEN);"
        puts $fileId "localparam TE_CNT_CNTG       = $Para(TE_CNT_CNTG);"
        puts $fileId "localparam TE_EVENT_CNTR     = $Para(TE_EVENT_CNTR);"
        puts $fileId "localparam TE_ENABLE         = $Para(TE_ENABLE);"
        # POR will not support Final Counter
        #puts $fileId "localparam TE_TRIG_CNTR      = $Para(TE_TRIG_CNTR);"
        for {set x 0} {$x<$Para(NUM_TU)} {incr x} {
        puts $fileId "localparam TU_COMPARE_VAL_$x = $Para(TU_COMPARE_VAL_$x);"
        puts $fileId "localparam TU_OP_CODE_$x     = $Para(TU_OP_CODE_$x);"
        puts $fileId "localparam TU_MASK_VAL_$x    = $Para(TU_MASK_VAL_$x);"
        }
        }
        puts $fileId ""

        puts $fileId "input  clk;"
        puts $fileId "input  reset_n;"

        for {set x 0} {$x<$Para(NUM_TU)} {incr x} {
           if {$Para(TU_TYPE_$x) == 0} {
              puts $fileId "input  \[NUM_TU_BITS_$x -1:0\] tu_in_$x;"
           }
           if {$Para(TU_TYPE_$x) == 1} {
              puts $fileId "input  \[0:0\] tu_in_$x;"
           }
        }

        puts $fileId "input  \[15:0\] wr_din;"
        puts $fileId "output \[15:0\] rd_dout_trig;"
        puts $fileId "input  \[15:0\] addr;"
        puts $fileId "input  ren;"
        puts $fileId "input  wen;"
        puts $fileId "input  wen_jtck;"
        puts $fileId "input  capture_clk;"
        puts $fileId "input  clear;"
        puts $fileId "input  parity_err;"
        puts $fileId "input  \[15:0\] te_prog_din;"
        puts $fileId "input  ip_enable_bit;"
        puts $fileId "input  jtck;"
        puts $fileId "input  jrstn;"
        puts $fileId "input  jshift;"
        puts $fileId "input  jshift_d1;"
        puts $fileId "input  jce2;"
        puts $fileId "input  capture_dr;"
        puts $fileId "output tt_prog_en_0;"
        puts $fileId "output even_parity;"
        puts $fileId "output trigger;"
        if {$Para(PORDebug)} {
        puts $fileId "input  trigger_en;"
        }
        puts $fileId ""
        puts $fileId "wire \[NUM_TE -1 :0\] tt_prog_en;"
        puts $fileId "wire \[NUM_TE -1 :0\] tt_end;"
        puts $fileId "wire \[NUM_TE -1 :0\] te_out;"
        puts $fileId "wire clk;"
        puts $fileId "wire reset_n;"
        puts $fileId "wire \[NUM_TU -1: 0\] wen_tu;"
        puts $fileId "wire \[NUM_TE -1: 0\] wen_te;"
        puts $fileId "wire rd_tu;"
        puts $fileId "wire rd_te;"
        puts $fileId "wire wen_tcnt;"
        puts $fileId "wire \[NUM_TU -1: 0\] tu_out;"
        puts $fileId "wire \[15:0\] rd_dout_te \[NUM_TE -1:0\];"
        puts $fileId "wire \[15:0\] rd_dout_tu \[NUM_TU -1:0\];"
        puts $fileId "wire \[15:0\] rd_dout_tcnt;"
        puts $fileId "wire \[15:0\] rd_dout_trig;"
        puts $fileId ""
        puts $fileId "assign rd_dout_trig = (rd_tu) ? rd_dout_tu\[addr\[11:8\]\] : (rd_te) ? rd_dout_te\[addr\[11:8\]\] : rd_dout_tcnt; "
        puts $fileId "assign tt_prog_en_0 = tt_prog_en\[0\]; "
        puts $fileId ""
        puts $fileId "rvl_decode #("
        puts $fileId "    .NUM_TU         (NUM_TU),"
        puts $fileId "    .NUM_TE         (NUM_TE)"
        puts $fileId ")"
        puts $fileId "decode_u ("
        puts $fileId "    .addr           (addr),"
        puts $fileId "    .ren            (ren),"
        puts $fileId "    .wen            (wen),"
        puts $fileId "    .wen_tu         (wen_tu),"
        puts $fileId "    .wen_te         (wen_te),"
        puts $fileId "    .wen_tcnt       (wen_tcnt),"
        puts $fileId "    .rd_tu          (rd_tu),"
        puts $fileId "    .rd_te          (rd_te)"
        puts $fileId ");"
        puts $fileId ""

        for {set x 0} {$x<$Para(NUM_TU)} {incr x} {
           if {$Para(TU_TYPE_$x) == 0} {
              puts $fileId "rvl_tu #("
           }
           if {$Para(TU_TYPE_$x) == 1} {
              puts $fileId "rvl_serial_tu #("
           }
        if {$Para(PORDebug)} {
		if {$Para(TU_TYPE_$x)==0} {
        puts $fileId "    .TU_OP_CODE     (TU_OP_CODE_$x),"}
        puts $fileId "    .TU_COMPARE_VAL (TU_COMPARE_VAL_$x),"
        puts $fileId "    .TU_MASK_VAL    (TU_MASK_VAL_$x),"
        }
        puts $fileId "    .NUM_TU_BITS    (NUM_TU_BITS_$x)"
        puts $fileId ")"
        puts $fileId "tu_$x ("
        puts $fileId "    .clk            (clk),"
        puts $fileId "    .reset_n        (reset_n),"
        puts $fileId "    .input_a        (tu_in_$x),"
        puts $fileId "    .addr           (addr\[5:0\]),"
        puts $fileId "    .wr_din         (wr_din\[15:0\]),"
        puts $fileId "    .wen_tu         (wen_tu\[$x\]),"
        puts $fileId "    .rd_dout_tu     (rd_dout_tu\[$x\]),"
        puts $fileId "    .tu_out         (tu_out\[$x\])"
        puts $fileId ");"
        puts $fileId ""
        }

for {set y 0} {$y<$Para(NUM_TE)} {incr y} {
        puts $fileId "rvl_te #("
        if {$Para(PORDebug)} {
        puts $fileId "    .TE_INIT        (TE_INIT),"
        puts $fileId "    .TE_NUM_THEN    (TE_NUM_THEN),"
        puts $fileId "    .TE_NEXT_THEN   (TE_NEXT_THEN),"
        puts $fileId "    .TE_CNT_CNTG    (TE_CNT_CNTG),"
        puts $fileId "    .TE_EVENT_CNTR  (TE_EVENT_CNTR),"
        }
        puts $fileId "    .NUM_TU         (NUM_TU),"
        puts $fileId "    .NUM_TE_ROW     (NUM_TE_ROW_$y),"
        puts $fileId "    .NUM_TE_COL     (NUM_TE_COL_$y),"
        puts $fileId "    .TE_EBR         (TE_EBR_$y),"
        puts $fileId "    .NUM_TE_EVENT_CNT_BITS (NUM_TE_EVENT_CNT_BITS_$y),"
        puts $fileId "    .GSR_ENABLE     (GSR_ENABLE),"
        puts $fileId "    .LSCC_FAMILY    (LSCC_FAMILY)"
        puts $fileId ")"
        puts $fileId "te_$y ("
        puts $fileId "    .clk            (clk),"
        puts $fileId "    .reset_n        (reset_n),"
        puts $fileId "    .clear          (clear),"
        puts $fileId "    .te_prog_din    (te_prog_din),"
        puts $fileId "    .te_in          ({"

        if {$Para(NUM_TU) > 1} {
            for {set z 1} {$z < $Para(NUM_TU)} {incr z} {
            set v [ expr {$Para(NUM_TU) - $z}]
	    puts $fileId "                      tu_out\[$v\],"
            }
        }

        puts $fileId "                      tu_out\[0\]}),"
        puts $fileId "    .wr_din         (wr_din\[15:0\]),"
        puts $fileId "    .rd_dout_te     (rd_dout_te\[$y\]),"
        puts $fileId "    .addr           (addr\[13:0\]),"
        puts $fileId "    .wen_te         (wen_te\[$y\]),"
        puts $fileId "    .ip_enable_bit  (ip_enable_bit),"
        puts $fileId "    .jtck           (jtck),"
        puts $fileId "    .jrstn          (jrstn),"
        puts $fileId "    .wen_jtck       (wen_jtck),"
        puts $fileId "    .jshift         (jshift),"
        puts $fileId "    .jshift_d1      (jshift_d1),"
        puts $fileId "    .jce2           (jce2),"
        puts $fileId "    .first_te       ("

	if {$y == 0} {puts $fileId "                      1'b1)," 
	} else       {puts $fileId "                      1'b0),"}

        puts $fileId "    .tt_start       ("

	if {$y == 0} {puts $fileId "                      capture_dr),"
	} else       {puts $fileId "                      tt_end\[$y-1\]),"}

        puts $fileId "    .tt_prog_en     (tt_prog_en\[$y\]),"
        puts $fileId "    .tt_end         (tt_end\[$y\]),"
        puts $fileId "    .te_out         (te_out\[$y\])"
        puts $fileId ");"
        puts $fileId ""
}

        puts $fileId ""
        puts $fileId "rvl_tcnt #("
        if {$Para(PORDebug)} {
        puts $fileId "    .TE_ENABLE      (TE_ENABLE),"
        #puts $fileId "    .TE_TRIG_CNTR   (TE_TRIG_CNTR),"
        }
        puts $fileId "    .NUM_TE         (NUM_TE),"
        puts $fileId "    .NUM_TCNT_BITS  (NUM_TCNT_BITS)"
        puts $fileId ")"
        puts $fileId "tcnt_0 ("
        puts $fileId "    .clk            (clk),"
        puts $fileId "    .reset_n        (reset_n),"

        puts $fileId "    .te_out         ({"

        if {$Para(NUM_TE) > 1} {
            for {set z 1} {$z < $Para(NUM_TE)} {incr z} {
            set v [ expr {$Para(NUM_TE) - $z}]
	    puts $fileId "                      te_out\[$v\],"
            }
        }
	puts $fileId "                      te_out\[0\]}),"

        puts $fileId "    .wr_din         (wr_din\[15:0\]),"
        puts $fileId "    .rd_dout_tcnt   (rd_dout_tcnt),"
        puts $fileId "    .addr           (addr\[15:0\]),"
        puts $fileId "    .wen_tcnt       (wen_tcnt),"
        puts $fileId "    .ren            (ren),"
        puts $fileId "    .wen            (wen),"
        puts $fileId "    .capture_clk    (capture_clk),"
        puts $fileId "    .even_parity    (even_parity),"
        puts $fileId "    .parity_err     (parity_err),"
        if {$Para(PORDebug)} {
        puts $fileId "    .trigger_en     (trigger_en),"
        } else {
        puts $fileId "    .trigger_en     (1'b1),"
        }
        puts $fileId "    .trigger        (trigger),"
        puts $fileId "    .trig_lat       (trig_lat),"
        puts $fileId "    .clear          (clear)"
        puts $fileId ");"
        puts $fileId ""
        puts $fileId "endmodule"

	close $fileId
	return 0
}

# CLOSE GENERATION OF trig.v
#
#************************************************
# Generate reveal.v
#************************************************

proc WriteRevealVerilog {} {
	global Para

	set outFile [file join "$Para(BuildDir)" "$Para(ModuleName)_gen.v"]
	if [catch {open $outFile w} fileId] {
	        set Para(msg) "ERROR: Cannot open file: $outFile!\n"
		return -1
	}
	set Para(Date) [clock format [clock seconds] -format "%m/%d/%Y"]
	set Para(Time) [clock format [clock seconds] -format "%H:%M:%S"]

	puts $fileId "//============================================================================="
	puts $fileId "// Verilog module generated by IPExpress    $Para(Date)    $Para(Time)"
	puts $fileId "// Filename: $Para(ModuleName).v"
	puts $fileId "// Reveal IP core version: $Para(ipgen_ver)"
	puts $fileId "// Copyright(c) 2006 Lattice Semiconductor Corporation. All rights reserved."
	puts $fileId "//============================================================================="
	puts $fileId ""
	puts $fileId "/* WARNING - Changes to this file should be performed by re-running IPexpress"
	puts $fileId "or modifying the .LPC file and regenerating the core.  Other changes may lead"
	puts $fileId "to inconsistent simulation and/or implemenation results */"
	puts $fileId ""
	puts $fileId "module $Para(ModuleName) ("
        puts $fileId "    clk,"
        puts $fileId "    reset_n,"
        puts $fileId "    jtck,"
        puts $fileId "    jrstn,"
        puts $fileId "    jce2,"
        puts $fileId "    jtdi,"
        puts $fileId "    er2_tdo,"
        puts $fileId "    jshift,"
        puts $fileId "    jupdate,"

        for {set x 0} {$x<$Para(NUM_TU)} {incr x} {
            puts $fileId "    trigger_din_$x,"
        }

        puts $fileId "    trace_din,"

        if {$Para(SAMPLE_ENABLE) == 1} {
	    puts $fileId "    sample_en,"
        }

        if {$Para(TRIGGER_OUT) == 1} {
	    puts $fileId "    trigger_out,"
        }
		
		#if {[info exists Para(TRIGGER_ENABLE)]} {
		#if {$Para(TRIGGER_ENABLE) == 1} {
	    puts $fileId "    trigger_en,"
        #}
		#}

        puts $fileId "    ip_enable"
        puts $fileId ") \/\* synthesis GSR=DISABLED \*\/ ;"
	puts $fileId ""
        puts $fileId "// PARAMETERS DEFINED BY USER"
        puts $fileId "localparam NUM_TRACE_SIGNALS   = $Para(NUM_TRACE_SIGNALS);"
        puts $fileId "localparam NUM_TRACE_SAMPLES   = $Para(NUM_TRACE_SAMPLES);"
        puts $fileId "localparam NUM_TRIGGER_SIGNALS = $Para(NUM_TRIGGER_SIGNALS);"
        puts $fileId "localparam MULTIPLE_CAPTURE    = $Para(MULTIPLE_CAPTURE);"
        puts $fileId "localparam NUM_TRIG_MAX        = $Para(NUM_TRIG_MAX);"
        puts $fileId "localparam SAMPLE_ENABLE       = $Para(SAMPLE_ENABLE);"
        puts $fileId "localparam INVERT_SAMPLE_EN    = $Para(INVERT_SAMPLE_EN);"
        puts $fileId "localparam GSR_ENABLE          = $Para(GSR_ENABLE);"
        puts $fileId "localparam INVERT_RESET        = $Para(INVERT_RESET);"
        puts $fileId "localparam INCLUDE_TRIG_DATA   = $Para(INCLUDE_TRIG_DATA);"
        puts $fileId "localparam TM_EBR              = $Para(TM_EBR);"
        puts $fileId "localparam DISABLE_DIST_RAM    = $Para(DISABLE_DIST_RAM);"
        puts $fileId "localparam NUM_TIME_STAMP_BITS = $Para(NUM_TIME_STAMP_BITS);"
        puts $fileId "localparam NUM_TRIG_COUNT_BITS = $Para(NUM_TRIG_COUNT_BITS);"
        puts $fileId "localparam MIN_TRIG_OUT_PULSE  = $Para(MIN_TRIG_OUT_PULSE);"
        puts $fileId "localparam INVERT_TRIG_OUT     = $Para(INVERT_TRIG_OUT);"

        for {set x 0} {$x<$Para(NUM_TU)} {incr x} {
            puts $fileId "localparam NUM_TU_BITS_$x       = $Para(NUM_TU_BITS_$x);"
        }

        puts $fileId "localparam REVEAL_SIG          = $Para(REVEAL_SIG);"
        puts $fileId "localparam REVEAL_VER          = $Para(ipgen_ver);"
        puts $fileId "localparam LSCC_FAMILY         = \"$Para(tech_pmi)\";"
        if {$Para(PORDebug)} {
        puts $fileId "localparam TRIGGER_ENABLE      = $Para(TRIGGER_ENABLE);"
        puts $fileId "localparam INVERT_TRIGGER_EN   = $Para(INVERT_TRIGGER_EN);"
        puts $fileId "localparam TM_START_INIT       = $Para(TM_START_INIT);"
        puts $fileId "localparam TM_PRE_TRIG         = $Para(TM_PRE_TRIG);"
        puts $fileId "localparam TM_POST_TRIG        = $Para(TM_POST_TRIG);"
        puts $fileId "localparam TM_MULT_TRIG        = $Para(TM_MULT_TRIG);"
        }
        puts $fileId ""
        puts $fileId "input  clk;"
        puts $fileId "input  reset_n;"
        puts $fileId "input  jtck;"
        puts $fileId "input  jrstn;"
        puts $fileId "input  jce2;"
        puts $fileId "input  jtdi;"
        puts $fileId "output er2_tdo;"
        puts $fileId "input  jshift;"
        puts $fileId "input  jupdate;"

        for {set x 0} {$x<$Para(NUM_TU)} {incr x} {
           if {$Para(TU_TYPE_$x) == 0} {
              puts $fileId "input  \[NUM_TU_BITS_$x -1:0\] trigger_din_$x;"
           }
           if {$Para(TU_TYPE_$x) == 1} {
              puts $fileId "input  \[0:0\] trigger_din_$x;"
           }
        }

        puts $fileId "input  \[NUM_TRACE_SIGNALS + (NUM_TRIGGER_SIGNALS * INCLUDE_TRIG_DATA) -1:0\] trace_din;"
        puts $fileId "input  ip_enable;"

        if {$Para(SAMPLE_ENABLE) == 1} {
	    puts $fileId "input  sample_en;"
        }

        if {$Para(TRIGGER_OUT) == 1} {
	    puts $fileId "output trigger_out;"
        }

		#if {[info exists Para(TRIGGER_ENABLE)]} {
		#if {$Para(TRIGGER_ENABLE) == 1} {
	    puts $fileId "input  trigger_en;"
        #}
		#}
		
        puts $fileId ""
        puts $fileId "wire clear;"
        puts $fileId "wire trigger;"
        puts $fileId "wire wen;"
        puts $fileId "wire ren;"
        puts $fileId "wire wen_jtck;"
        puts $fileId "wire ren_jtck;"
        puts $fileId "wire \[15:0\] addr;"
        puts $fileId "wire \[15:0\] wr_din;"
        puts $fileId "wire \[15:0\] rd_dout_trig;"
        puts $fileId "wire \[15:0\] rd_dout_tm;"
        puts $fileId "wire \[NUM_TIME_STAMP_BITS + NUM_TRACE_SIGNALS + (NUM_TRIGGER_SIGNALS * INCLUDE_TRIG_DATA) -1:0\] trace_dout;"
        puts $fileId "wire trace_dout_1st_bit;"
        puts $fileId "wire parity_err;"
        puts $fileId "wire even_parity;"
        puts $fileId "wire capture_clk;"
        puts $fileId "wire reset_rvl_n;"
        puts $fileId "wire trigger_out;"
        puts $fileId "wire tr_bit_0;"
        puts $fileId "wire addr_15;"
        puts $fileId "wire capture_dr;"
        puts $fileId "wire \[15:0\] te_prog_din;"
        puts $fileId "wire start_por;"
        puts $fileId ""
        #sreepa fix 2011.01.19
        #puts $fileId "assign reset_rvl_n = jrstn | ~ip_enable;"
	# ckng 6/7/12 restore 1.14 version until multiple TE bug is fixed
        #puts $fileId "assign reset_rvl_n = jrstn | ip_enable;"
        ##puts $fileId "assign reset_rvl_n = jrstn | ip_enable | start_por;"
		if {$Para(PORDebug)} {
        puts $fileId "wire prog_done_n;"
        puts $fileId "BBPU bbpu_inst(.I(1'b0),.T(1'b0),.O(prog_done_n)) /* synthesis IO_TYPE=LVCMOS33 */;"
        puts $fileId "assign reset_rvl_n = jrstn | ip_enable | (~prog_done_n & start_por);"
		} else {
		puts $fileId "assign reset_rvl_n = jrstn | ip_enable;"
		}
        puts $fileId ""
        puts $fileId "rvl_jtag_int #("
        puts $fileId "    .NUM_TRACE_SIGNALS   (NUM_TRACE_SIGNALS),"
        puts $fileId "    .NUM_TRIGGER_SIGNALS (NUM_TRIGGER_SIGNALS),"
        puts $fileId "    .INCLUDE_TRIG_DATA   (INCLUDE_TRIG_DATA),"
        puts $fileId "    .NUM_TIME_STAMP_BITS (NUM_TIME_STAMP_BITS)"
        puts $fileId ")"
        puts $fileId "jtag_int_u("
        puts $fileId "    .clk            (clk),"
        puts $fileId "    .reset_n        (reset_rvl_n),"
        puts $fileId "    .jce2           (jce2),"
        puts $fileId "    .jtdi           (jtdi),"
        puts $fileId "    .jtdo           (er2_tdo),"
        puts $fileId "    .jtck           (jtck),"
        puts $fileId "    .jshift         (jshift),"
        puts $fileId "    .jupdate        (jupdate),"
        puts $fileId "    .jrstn          (jrstn),"
        puts $fileId "    .ip_enable_bit  (ip_enable),"
        puts $fileId "    .rd_dout_trig   (rd_dout_trig),"
        puts $fileId "    .rd_dout_tm     (rd_dout_tm),"
        puts $fileId "    .trace_dout     (trace_dout),"
        puts $fileId "    .trace_dout_1st_bit     (trace_dout_1st_bit),"
        puts $fileId "    .tr_bit_0       (tr_bit_0),"
        puts $fileId "    .addr_15        (addr_15),"
        puts $fileId "    .jshift_d1      (jshift_d1),"
        puts $fileId "    .tt_prog_en_0   (tt_prog_en_0),"
        puts $fileId "    .even_parity    (even_parity),"
        puts $fileId "    .wen            (wen),"
        puts $fileId "    .ren            (ren),"
        puts $fileId "    .wen_jtck       (wen_jtck),"
        puts $fileId "    .ren_jtck       (ren_jtck),"
        puts $fileId "    .capture_clk    (capture_clk),"
        puts $fileId "    .parity_err     (parity_err),"
        puts $fileId "    .addr           (addr),"
        puts $fileId "    .te_prog_din    (te_prog_din),"
        puts $fileId "    .capture_dr     (capture_dr),"
        puts $fileId "    .wr_din         (wr_din)"
        puts $fileId ");"

        puts $fileId ""
        puts $fileId "$Para(ModuleName)_trig trig_u("
        puts $fileId "    .clk            (clk),"
        puts $fileId "    .reset_n        (reset_rvl_n),"

        for {set x 0} {$x<$Para(NUM_TU)} {incr x} {

                puts $fileId "    .tu_in_$x        (trigger_din_$x),"
        }

        puts $fileId "    .wr_din         (wr_din),"
        puts $fileId "    .rd_dout_trig   (rd_dout_trig),"
        puts $fileId "    .addr           (addr),"
        puts $fileId "    .ren            (ren),"
        puts $fileId "    .wen            (wen),"
        puts $fileId "    .wen_jtck       (wen_jtck),"
        puts $fileId "    .capture_clk    (capture_clk),"
        puts $fileId "    .clear          (clear),"
        puts $fileId "    .parity_err     (parity_err),"
        puts $fileId "    .te_prog_din    (te_prog_din),"
        puts $fileId "    .ip_enable_bit  (ip_enable),"
        puts $fileId "    .jtck           (jtck),"
        puts $fileId "    .jrstn          (jrstn),"
        puts $fileId "    .jshift         (jshift),"
        puts $fileId "    .jshift_d1      (jshift_d1),"
        puts $fileId "    .jce2           (jce2),"
        puts $fileId "    .capture_dr     (capture_dr),"
        puts $fileId "    .tt_prog_en_0   (tt_prog_en_0),"
        puts $fileId "    .even_parity    (even_parity),"
        if {$Para(PORDebug)} {
        if {$Para(INVERT_TRIGGER_EN) == 1} {
        puts $fileId "    .trigger_en     (~trigger_en),"
        } else {
        puts $fileId "    .trigger_en     (trigger_en),"
        }
        }
        puts $fileId "    .trigger        (trigger)"
        puts $fileId ");"

        puts $fileId ""
        puts $fileId "rvl_tm #("
        puts $fileId "    .NUM_TRACE_SIGNALS   (NUM_TRACE_SIGNALS),"
        puts $fileId "    .NUM_TRACE_SAMPLES   (NUM_TRACE_SAMPLES),"
        puts $fileId "    .NUM_TRIGGER_SIGNALS (NUM_TRIGGER_SIGNALS),"
        puts $fileId "    .MULTIPLE_CAPTURE    (MULTIPLE_CAPTURE),"
        puts $fileId "    .NUM_TRIG_MAX        (NUM_TRIG_MAX),"
        puts $fileId "    .REVEAL_SIG          (REVEAL_SIG),"
        puts $fileId "    .GSR_ENABLE          (GSR_ENABLE),"
        puts $fileId "    .SAMPLE_ENABLE       (SAMPLE_ENABLE),"
        puts $fileId "    .INVERT_SAMPLE_EN    (INVERT_SAMPLE_EN),"
        puts $fileId "    .INCLUDE_TRIG_DATA   (INCLUDE_TRIG_DATA),"
        puts $fileId "    .NUM_TIME_STAMP_BITS (NUM_TIME_STAMP_BITS),"
        puts $fileId "    .NUM_TRIG_COUNT_BITS (NUM_TRIG_COUNT_BITS),"
        puts $fileId "    .MIN_TRIG_OUT_PULSE  (MIN_TRIG_OUT_PULSE),"
        puts $fileId "    .INVERT_TRIG_OUT     (INVERT_TRIG_OUT),"
        puts $fileId "    .TM_EBR              (TM_EBR),"
        puts $fileId "    .DISABLE_DIST_RAM    (DISABLE_DIST_RAM),"
        if {$Para(PORDebug)} {
        puts $fileId "    .TM_START_INIT       (TM_START_INIT),"
        puts $fileId "    .TM_PRE_TRIG         (TM_PRE_TRIG),"
        puts $fileId "    .TM_POST_TRIG        (TM_POST_TRIG),"
        puts $fileId "    .TM_MULT_TRIG        (TM_MULT_TRIG),"
        }
        puts $fileId "    .LSCC_FAMILY         (LSCC_FAMILY)"
        puts $fileId ")"
        puts $fileId "tm_u("
        puts $fileId "    .clk            (clk),"
        puts $fileId "    .reset_n        (reset_rvl_n),"
        puts $fileId "    .wen            (wen),"
        puts $fileId "    .ren            (ren),"
        puts $fileId "    .wen_jtck       (wen_jtck),"
        puts $fileId "    .ren_jtck       (ren_jtck),"
        puts $fileId "    .jtck           (jtck),"
        puts $fileId "    .jrstn          (jrstn),"
        puts $fileId "    .rd_dout_tm     (rd_dout_tm),"
        puts $fileId "    .addr           (addr),"
        puts $fileId "    .trigger        (trigger),"
        puts $fileId "    .wr_din         (wr_din),"

        if {$Para(SAMPLE_ENABLE) == 1} {
            puts $fileId "    .sample_en      (sample_en),"
        }
	if {$Para(SAMPLE_ENABLE) == 0} {
            puts $fileId "    .sample_en      (1'b1),"
        }

        puts $fileId "    .start_por      (start_por),"
        puts $fileId "    .trace_din      (trace_din),"
        puts $fileId "    .tr_bit_0       (tr_bit_0),"
        puts $fileId "    .addr_15        (addr_15),"
        puts $fileId "    .capture_dr     (capture_dr),"
        puts $fileId "    .jshift         (jshift),"
        puts $fileId "    .clear          (clear),"
        puts $fileId "    .trace_dout     (trace_dout),"
        puts $fileId "    .trace_dout_1st_bit     (trace_dout_1st_bit),"
        puts $fileId "    .trigger_out    (trigger_out)"
        puts $fileId ");"

        puts $fileId ""
        puts $fileId "endmodule"

	close $fileId

	return 0
}

# close of generation of reveal.v
#

#************************************************
# Generate reveal_sim.v
#************************************************

proc WriteSimVerilog {} {
	global Para

	set outFile [file join "$Para(BuildDir)" "$Para(ModuleName)_sim.v"]
	if [catch {open $outFile w} fileId] {
	        set Para(msg) "ERROR: Cannot open file: $outFile!\n"
		return -1
	}
	set Para(Date) [clock format [clock seconds] -format "%m/%d/%Y"]
	set Para(Time) [clock format [clock seconds] -format "%H:%M:%S"]

	puts $fileId "//============================================================================="
	puts $fileId "// Verilog module generated by IPExpress    $Para(Date)    $Para(Time)         "
	puts $fileId "// Filename: $Para(ModuleName)_sim.v                                          "
	puts $fileId "// Copyright(c) 2006 Lattice Semiconductor Corporation. All rights reserved.   "
	puts $fileId "//============================================================================="
	puts $fileId ""
	puts $fileId "/* WARNING - Changes to this file should be performed by re-running IPexpress"
	puts $fileId "or modifying the .LPC file and regenerating the core.  Other changes may lead"
	puts $fileId "to inconsistent simulation and/or implemenation results */"
	puts $fileId ""
	puts $fileId "module $Para(ModuleName) ("
        puts $fileId "    clk,"
        puts $fileId "    reset_n,"
        puts $fileId "    jtck,"
        puts $fileId "    jrstn,"
        puts $fileId "    jce2,"
        puts $fileId "    jtdi,"
        puts $fileId "    er2_tdo,"
        puts $fileId "    jshift,"
        puts $fileId "    jupdate,"

        for {set x 0} {$x<$Para(NUM_TU)} {incr x} {
            puts $fileId "    trigger_din_$x,"
        }

        puts $fileId "    trace_din,"

        if {$Para(SAMPLE_ENABLE) == 1} {
	    puts $fileId "    sample_en,"
        }

        if {$Para(TRIGGER_OUT) == 1} {
	    puts $fileId "    trigger_out,"
        }

        puts $fileId "    ip_enable"
        puts $fileId ");"
        puts $fileId ""
        puts $fileId "// PARAMETERS DEFINED BY USER"
        puts $fileId "localparam NUM_TRACE_SIGNALS   = $Para(NUM_TRACE_SIGNALS);"
        puts $fileId "localparam NUM_TRIGGER_SIGNALS = $Para(NUM_TRIGGER_SIGNALS);"
        puts $fileId "localparam INCLUDE_TRIG_DATA   = $Para(INCLUDE_TRIG_DATA);"

        for {set x 0} {$x<$Para(NUM_TU)} {incr x} {
            puts $fileId "localparam NUM_TU_BITS_$x       = $Para(NUM_TU_BITS_$x);"
        }

        puts $fileId ""
        puts $fileId "input  clk;"
        puts $fileId "input  reset_n;"
        puts $fileId "input  jtck;"
        puts $fileId "input  jrstn;"
        puts $fileId "input  jce2;"
        puts $fileId "input  jtdi;"
        puts $fileId "output er2_tdo;"
        puts $fileId "input  jshift;"
        puts $fileId "input  jupdate;"

        for {set x 0} {$x<$Para(NUM_TU)} {incr x} {
           if {$Para(TU_TYPE_$x) == 0} {
              puts $fileId "input  \[NUM_TU_BITS_$x -1:0\] trigger_din_$x;"
           }
           if {$Para(TU_TYPE_$x) == 1} {
              puts $fileId "input  \[0:0\] trigger_din_$x;"
           }
        }

        puts $fileId "input  \[NUM_TRACE_SIGNALS + (NUM_TRIGGER_SIGNALS * INCLUDE_TRIG_DATA) -1:0\] trace_din;"
        puts $fileId "input  ip_enable;"

        if {$Para(SAMPLE_ENABLE) == 1} {
	    puts $fileId "input sample_en;"
        }

        if {$Para(TRIGGER_OUT) == 1} {
	    puts $fileId "output trigger_out;"
        }

        puts $fileId ""
	puts $fileId "assign er2_tdo = 1'b0;"
        if {$Para(TRIGGER_OUT) == 1} {
	    puts $fileId "assign trigger_out = 1'b0;"
        }
        puts $fileId ""
        puts $fileId "endmodule"

	close $fileId

	return 0
}
# close of generation of reveal_sim.v
#

#************************************************
# Generate reveal_bb.v
#************************************************

proc WriteVerilogBB {} {
	global Para

	set outFile [file join "$Para(BuildDir)" "$Para(ModuleName)_bb.v"]
	if [catch {open $outFile w} fileId] {
	        set Para(msg) "ERROR: Cannot open file: $outFile!\n"
		return -1
	}
	set Para(Date) [clock format [clock seconds] -format "%m/%d/%Y"]
	set Para(Time) [clock format [clock seconds] -format "%H:%M:%S"]

	puts $fileId "//============================================================================="
	puts $fileId "// Verilog module generated by IPExpress    $Para(Date)    $Para(Time)         "
	puts $fileId "// Filename: $Para(ModuleName)_bb.v                                          "
	puts $fileId "// Copyright(c) 2006 Lattice Semiconductor Corporation. All rights reserved.   "
	puts $fileId "//============================================================================="
	puts $fileId ""
	puts $fileId "/* WARNING - Changes to this file should be performed by re-running IPexpress"
	puts $fileId "or modifying the .LPC file and regenerating the core.  Other changes may lead"
	puts $fileId "to inconsistent simulation and/or implemenation results */"
	puts $fileId ""
	puts $fileId "module $Para(ModuleName) ("
        puts $fileId "    clk,"
        puts $fileId "    reset_n,"
        puts $fileId "    jtck,"
        puts $fileId "    jrstn,"
        puts $fileId "    jce2,"
        puts $fileId "    jtdi,"
        puts $fileId "    er2_tdo,"
        puts $fileId "    jshift,"
        puts $fileId "    jupdate,"

        for {set x 0} {$x<$Para(NUM_TU)} {incr x} {
            puts $fileId "    trigger_din_$x,"
        }

        puts $fileId "    trace_din,"

        if {$Para(SAMPLE_ENABLE) == 1} {
	    puts $fileId "    sample_en,"
        }

        if {$Para(TRIGGER_OUT) == 1} {
	    puts $fileId "    trigger_out,"
        }

		#if {[info exists Para(TRIGGER_ENABLE)]} {
		#if {$Para(TRIGGER_ENABLE) == 1} {
	    puts $fileId "    trigger_en,"
        #}
		#}
		
        puts $fileId "    ip_enable"
        puts $fileId ");"
        puts $fileId ""
        puts $fileId "// PARAMETERS DEFINED BY USER"
        puts $fileId "localparam NUM_TRACE_SIGNALS   = $Para(NUM_TRACE_SIGNALS);"
        puts $fileId "localparam NUM_TRIGGER_SIGNALS = $Para(NUM_TRIGGER_SIGNALS);"
        puts $fileId "localparam INCLUDE_TRIG_DATA   = $Para(INCLUDE_TRIG_DATA);"

        for {set x 0} {$x<$Para(NUM_TU)} {incr x} {
            puts $fileId "localparam NUM_TU_BITS_$x       = $Para(NUM_TU_BITS_$x);"
        }

        puts $fileId ""
        puts $fileId "input  clk;"
        puts $fileId "input  reset_n;"
        puts $fileId "input  jtck;"
        puts $fileId "input  jrstn;"
        puts $fileId "input  jce2;"
        puts $fileId "input  jtdi;"
        puts $fileId "output er2_tdo;"
        puts $fileId "input  jshift;"
        puts $fileId "input  jupdate;"

        for {set x 0} {$x<$Para(NUM_TU)} {incr x} {
           if {$Para(TU_TYPE_$x) == 0} {
              puts $fileId "input  \[NUM_TU_BITS_$x -1:0\] trigger_din_$x;"
           }
           if {$Para(TU_TYPE_$x) == 1} {
              puts $fileId "input  \[0:0\] trigger_din_$x;"
           }
        }

        puts $fileId "input  \[NUM_TRACE_SIGNALS + (NUM_TRIGGER_SIGNALS * INCLUDE_TRIG_DATA) -1:0\] trace_din;"
        puts $fileId "input  ip_enable;"

        if {$Para(SAMPLE_ENABLE) == 1} {
	    puts $fileId "input sample_en;"
        }

        if {$Para(TRIGGER_OUT) == 1} {
	    puts $fileId "output trigger_out;"
        }

		#if {[info exists Para(TRIGGER_ENABLE)]} {
		#if {$Para(TRIGGER_ENABLE) == 1} {
	    puts $fileId "input  trigger_en;"
        #}
		#}
		
        puts $fileId ""
        puts $fileId "endmodule"

	close $fileId

	return 0
}
# close of generation of reveal_bb.v
#

#************************************************
# Generate reveal_inst.v
#************************************************

proc WriteVerilogInst {} {
	global Para

	set outFile [file join "$Para(BuildDir)" "$Para(ModuleName)_inst.v"]
	if [catch {open $outFile w} fileId] {
	        set Para(msg) "ERROR: Cannot open file: $outFile!\n"
		return -1
	}
	set Para(Date) [clock format [clock seconds] -format "%m/%d/%Y"]
	set Para(Time) [clock format [clock seconds] -format "%H:%M:%S"]

	puts $fileId "//============================================================================="
	puts $fileId "// Verilog module generated by IPExpress    $Para(Date)    $Para(Time)         "
	puts $fileId "// Filename: $Para(ModuleName)_inst.v                                          "
	puts $fileId "// Copyright(c) 2006 Lattice Semiconductor Corporation. All rights reserved.   "
	puts $fileId "//============================================================================="
	puts $fileId ""
	puts $fileId "/* WARNING - Changes to this file should be performed by re-running IPexpress"
	puts $fileId "or modifying the .LPC file and regenerating the core.  Other changes may lead"
	puts $fileId "to inconsistent simulation and/or implemenation results */"
	puts $fileId ""
	puts $fileId "$Para(ModuleName) ("
        puts $fileId "    .clk		(clk),"
        puts $fileId "    .reset_n		(reset_n),"
        puts $fileId "    .jtck		(jtck),"
        puts $fileId "    .jrstn		(jrstn),"
        puts $fileId "    .jce2		(jce2),"
        puts $fileId "    .jtdi		(jtdi),"
        puts $fileId "    .er2_tdo		(er2_tdo),"
        puts $fileId "    .jshift		(jshift),"
        puts $fileId "    .jupdate		(jupdate),"

        for {set x 0} {$x<$Para(NUM_TU)} {incr x} {
            puts $fileId "    .trigger_din_$x	(trigger_din_$x),"
        }

        puts $fileId "    .trace_din		(trace_din),"

        if {$Para(SAMPLE_ENABLE) == 1} {
	    puts $fileId "    .sample_en	(sample_en),"
        }

        if {$Para(TRIGGER_OUT) == 1} {
	    puts $fileId "    .trigger_out	(trigger_out),"
        }

        puts $fileId "    .ip_enable    	(ip_enable)"
#        puts $fileId ");"
        puts $fileId ")"
        puts $fileId ""
        puts $fileId "object \/\* synthesis GSR=DISABLED \*\/"
        puts $fileId "object \/\* synthesis UGROUP=\”$Para(ModuleName)_core\” \*\/"
        puts $fileId "pragma \/\/ attribute UGROUP \”$Para(ModuleName)_core\” "
        puts $fileId ";"
        puts $fileId ""

	close $fileId

	return 0
}
# close of generation of reveal_inst.v
#

#************************************************
# Generate reveal_comp.vhd
#************************************************

proc WriteVHDLComp {} {
	global Para

	set outFile [file join "$Para(BuildDir)" "$Para(ModuleName)_comp.vhd"]
	if [catch {open $outFile w} fileId] {
	        set Para(msg) "ERROR: Cannot open file: $outFile!\n"
		return -1
	}
	set Para(Date) [clock format [clock seconds] -format "%m/%d/%Y"]
	set Para(Time) [clock format [clock seconds] -format "%H:%M:%S"]

	puts $fileId "-- ============================================================================="
	puts $fileId "--  VHDL instance generated by IPExpress    $Para(Date)    $Para(Time)         "
	puts $fileId "--  Filename: $Para(ModuleName)_inst.vhd                                          "
	puts $fileId "--  Copyright(c) 2006 Lattice Semiconductor Corporation. All rights reserved.   "
	puts $fileId "-- ============================================================================="
	puts $fileId ""
	puts $fileId "-- WARNING - Changes to this file should be performed by re-running IPexpress"
	puts $fileId "-- or modifying the .LPC file and regenerating the core.  Other changes may lead"
	puts $fileId "-- to inconsistent simulation and/or implemenation results */"
	puts $fileId ""
	puts $fileId "library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all;"
	puts $fileId "PACKAGE $Para(ModuleName)_pkg IS"
	puts $fileId "    COMPONENT $Para(ModuleName)"
	puts $fileId "    PORT ("
        puts $fileId "        clk:		IN std_logic;"
        puts $fileId "        reset_n:	IN std_logic;"
        puts $fileId "        jtck:		IN std_logic;"
        puts $fileId "        jrstn:		IN std_logic;"
        puts $fileId "        jce2:		IN std_logic;"
        puts $fileId "        jtdi:		IN std_logic;"
        puts $fileId "        er2_tdo:	BUFFER std_logic;"
        puts $fileId "        jshift:		IN std_logic;"
        puts $fileId "        jupdate:	IN std_logic;"

        for {set x 0} {$x<$Para(NUM_TU)} {incr x} {
           if {$Para(TU_TYPE_$x) == 0} {
              puts $fileId "        trigger_din_$x:	IN std_logic_vector ([expr {$Para(NUM_TU_BITS_$x) - 1}] downto 0);"
           }
           if {$Para(TU_TYPE_$x) == 1} {
              puts $fileId "        trigger_din_$x:	IN std_logic_vector (0 downto 0);"
           }
        }

        puts $fileId "        trace_din:	IN std_logic_vector ([expr {$Para(NUM_TRACE_SIGNALS) + ($Para(NUM_TRIGGER_SIGNALS) * $Para(INCLUDE_TRIG_DATA)) - 1}] downto 0);"

        if {$Para(SAMPLE_ENABLE) == 1} {
	    puts $fileId "        sample_en:	IN std_logic;"
        }

        if {$Para(TRIGGER_OUT) == 1} {
	    puts $fileId "        trigger_out:	BUFFER std_logic;"
        }

        puts $fileId "        ip_enable:	IN std_logic"
        puts $fileId "    );"
        puts $fileId ""
        puts $fileId "    END COMPONENT;"
        puts $fileId ""
        puts $fileId "END PACKAGE $Para(ModuleName)_pkg;"

	close $fileId

	return 0
}
# close of generation of reveal_comp.vhd
#

#************************************************
# Generate reveal_inst.vhd
#************************************************

proc WriteVHDLInst {} {
	global Para

	set outFile [file join "$Para(BuildDir)" "$Para(ModuleName)_inst.vhd"]
	if [catch {open $outFile w} fileId] {
	        set Para(msg) "ERROR: Cannot open file: $outFile!\n"
		return -1
	}
	set Para(Date) [clock format [clock seconds] -format "%m/%d/%Y"]
	set Para(Time) [clock format [clock seconds] -format "%H:%M:%S"]

	puts $fileId "-- ============================================================================="
	puts $fileId "--  VHDL instance generated by IPExpress    $Para(Date)    $Para(Time)         "
	puts $fileId "--  Filename: $Para(ModuleName)_inst.vhd                                          "
	puts $fileId "--  Copyright(c) 2006 Lattice Semiconductor Corporation. All rights reserved.   "
	puts $fileId "-- ============================================================================="
	puts $fileId ""
	puts $fileId "-- WARNING - Changes to this file should be performed by re-running IPexpress"
	puts $fileId "-- or modifying the .LPC file and regenerating the core.  Other changes may lead"
	puts $fileId "-- to inconsistent simulation and/or implemenation results */"
	puts $fileId ""
	puts $fileId "$Para(ModuleName)_inst: $Para(ModuleName)"
	puts $fileId "   port map ("
        puts $fileId "       clk		=> clk,"
        puts $fileId "       reset_n		=> reset_n,"
        puts $fileId "       jtck		=> jtck,"
        puts $fileId "       jrstn		=> jrstn,"
        puts $fileId "       jce2		=> jce2,"
        puts $fileId "       jtdi		=> jtdi,"
        puts $fileId "       er2_tdo		=> er2_tdo,"
        puts $fileId "       jshift		=> jshift,"
        puts $fileId "       jupdate		=> jupdate,"

        for {set x 0} {$x<$Para(NUM_TU)} {incr x} {
           if {$Para(TU_TYPE_$x) == 0} {
              puts $fileId "       trigger_din_$x	=> trigger_din_$x\([expr {$Para(NUM_TU_BITS_$x) - 1}] downto 0),"
           }
           if {$Para(TU_TYPE_$x) == 1} {
              puts $fileId "       trigger_din_$x	=> trigger_din_$x\(0 downto 0),"
           }
        }

        puts $fileId "       trace_din	=> trace_din([expr {$Para(NUM_TRACE_SIGNALS) + ($Para(NUM_TRIGGER_SIGNALS) * $Para(INCLUDE_TRIG_DATA)) - 1}] downto 0),"

        if {$Para(SAMPLE_ENABLE) == 1} {
	    puts $fileId "       sample_en	=> sample_en,"
        }

        if {$Para(TRIGGER_OUT) == 1} {
	    puts $fileId "       trigger_out	=> trigger_out,"
        }

        puts $fileId "       ip_enable        => ip_enable"
        puts $fileId ")"
        puts $fileId ""
        puts $fileId "object \/\* synthesis GSR=DISABLED \*\/"
        puts $fileId "object \/\* synthesis UGROUP=\”$Para(ModuleName)_core\” \*\/"
        puts $fileId "pragma \/\/ attribute UGROUP \”$Para(ModuleName)_core\” "
        puts $fileId ";"
        puts $fileId ""

	close $fileId

	return 0
}
# close of generation of reveal_inst.vhd
#

#************************************************
# Generate reveal_sim.vhd
#************************************************

proc WriteSimVHDL {} {
	global Para

	set outFile [file join "$Para(BuildDir)" "$Para(ModuleName)_sim.vhd"]
	if [catch {open $outFile w} fileId] {
	        set Para(msg) "ERROR: Cannot open file: $outFile!\n"
		return -1
	}
	set Para(Date) [clock format [clock seconds] -format "%m/%d/%Y"]
	set Para(Time) [clock format [clock seconds] -format "%H:%M:%S"]

	puts $fileId "-- ============================================================================="
	puts $fileId "--  VHDL simulation model generated by IPExpress    $Para(Date)    $Para(Time)         "
	puts $fileId "--  Filename: $Para(ModuleName)_sim.vhd                                          "
	puts $fileId "--  Copyright(c) 2006 Lattice Semiconductor Corporation. All rights reserved.   "
	puts $fileId "-- ============================================================================="
	puts $fileId ""
	puts $fileId "-- WARNING - Changes to this file should be performed by re-running IPexpress"
	puts $fileId "-- or modifying the .LPC file and regenerating the core.  Other changes may lead"
	puts $fileId "-- to inconsistent simulation and/or implemenation results */"
	puts $fileId ""
	puts $fileId "library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all;"
	puts $fileId ""
	puts $fileId "entity $Para(ModuleName) is"
	puts $fileId "    PORT ("
        puts $fileId "        clk:		IN std_logic;"
        puts $fileId "        reset_n:	IN std_logic;"
        puts $fileId "        jtck:		IN std_logic;"
        puts $fileId "        jrstn:		IN std_logic;"
        puts $fileId "        jce2:		IN std_logic;"
        puts $fileId "        jtdi:		IN std_logic;"
        puts $fileId "        er2_tdo:	BUFFER std_logic;"
        puts $fileId "        jshift:		IN std_logic;"
        puts $fileId "        jupdate:	IN std_logic;"

        for {set x 0} {$x<$Para(NUM_TU)} {incr x} {
           if {$Para(TU_TYPE_$x) == 0} {
              puts $fileId "        trigger_din_$x:	IN std_logic_vector ([expr {$Para(NUM_TU_BITS_$x) - 1}] downto 0);"
           }
           if {$Para(TU_TYPE_$x) == 1} {
              puts $fileId "        trigger_din_$x:	IN std_logic_vector (0 downto 0);"
           }
        }

        puts $fileId "        trace_din:	IN std_logic_vector ([expr {$Para(NUM_TRACE_SIGNALS) + ($Para(NUM_TRIGGER_SIGNALS) * $Para(INCLUDE_TRIG_DATA)) - 1}] downto 0);"


        if {$Para(SAMPLE_ENABLE) == 1} {
	    puts $fileId "        sample_en:	IN std_logic;"
        }

		#if {[info exists Para(TRIGGER_ENABLE)]} {
		#if {$Para(TRIGGER_ENABLE) == 1} {
	    puts $fileId "        trigger_en:	IN std_logic;"
        #}
		#}

        if {$Para(TRIGGER_OUT) == 1} {
	    puts $fileId "        trigger_out:	BUFFER std_logic;"
        }

        puts $fileId "        ip_enable:	IN std_logic"
        puts $fileId "    );"
        puts $fileId ""
        puts $fileId "end $Para(ModuleName);"
        puts $fileId ""
        puts $fileId "architecture $Para(ModuleName)_u of $Para(ModuleName) is"
        puts $fileId "begin"
        puts $fileId ""
        puts $fileId "    er2_tdo <= '0';"

        if {$Para(TRIGGER_OUT) == 1} {
            puts $fileId "    trigger_out <= '0';"
        }

        puts $fileId ""
        puts $fileId "end $Para(ModuleName)_u;"

	close $fileId

	return 0
}
# close of generation of reveal_sim.vhd
#


#*******************************************
# Generate instance and component files
#*******************************************
proc WriteFiles {} {
	global Para

    set Para(PORDebug) [expr [info exists Para(TRIGGER_ENABLE)] && $Para(TRIGGER_ENABLE) == 1]

	set ret [WriteTrigVerilog]
	set ret [WriteRevealVerilog]
	set ret [WriteSimVerilog]
	set ret [WriteVerilogBB]
	set ret [WriteVerilogInst]
	set ret [WriteVHDLComp]
	set ret [WriteVHDLInst]
	set ret [WriteSimVHDL]

	return $ret

}

