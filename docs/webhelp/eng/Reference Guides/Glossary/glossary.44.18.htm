<!DOCTYPE html ><html xml:lang="en" lang="en" data-highlight-require-whitespace="false" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><title>S</title><link rel="Prev" href="glossary.44.17.htm" title="Previous" /><link rel="Next" href="glossary.44.19.htm" title="Next" /><link rel="StyleSheet" href="../../css/font-awesome/css/font-awesome.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/glossary.css" type="text/css" media="all" /><link rel="StyleSheet" href="../css/webworks.css" type="text/css" media="all" /><link rel="StyleSheet" href="../css/skin.css" type="text/css" media="all" /><link rel="StyleSheet" href="../css/social.css" type="text/css" media="all" /><link rel="StyleSheet" href="../css/print.css" type="text/css" media="print" /><script type="text/javascript" src="../scripts/common.js"></script><script type="text/javascript" src="../scripts/page.js"></script><script type="text/javascript" src="../scripts/search-client.js"></script><script type="text/javascript" src="../scripts/unidata.js"></script><script type="text/javascript" src="../scripts/unibreak.js"></script><noscript><div id="noscript_padding"></div></noscript></head><body id="plkZ8iVyFyw7wj1LAzJj5zw" class="ww_skin_page_body" onload="Page.OnLoad('../../index.htm#page/Reference%20Guides/Glossary/glossary.44.18.htm');"><div id="ww_content_container"><header id="wwconnect_header"><div class="ww_skin_page_toolbar"><a class="ww_behavior_print ww_skin ww_skin_print" title="Print" href="#"><i class="fa"></i></a></div><!-- was this helpful button --><!--                         --><!-- Moved breadcrumbs to bottom of the header so that the print --><!-- button would float to the right of the breadcrumbs. --><!-- PH 4June2019 --><div class="ww_skin_breadcrumbs"><a class="WebWorks_Breadcrumb_Link" href="../Strategies/strategy_settings.htm">Reference Guides</a> &gt; <a class="WebWorks_Breadcrumb_Link" href="glossary.44.01.htm#1189419">Glossary</a> &gt; S</div></header><div id="page_content_container" style="background-color: White; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px"><div id="page_content"><h2 id="ww1189419" class="Heading1"><span></span>S</h2><h5 id="ww1189421" class="GlossTerm"><span></span>sample</h5><p id="ww1189422" class="GlossDef"><span></span>A sample is a trace data value captured from the trace bus and written into the trace memory in Reveal.</p><h5 id="ww1189423" class="GlossTerm"><span></span>saturation logic</h5><p id="ww1189424" class="GlossDef"><span></span>Saturation logic is logic in which the transistors are operating at or beyond their fully conducting state.</p><h5 id="ww1189425" class="GlossTerm"><span></span>_sc</h5><p id="ww1189426" class="GlossDef"><span></span>A -sc file is a Schematic Editor log file.</p><h5 id="ww1189427" class="GlossTerm"><span></span>scan chain</h5><p id="ww1189428" class="GlossDef"><span></span>A scan chain, or scan shift register, is a set of scannable flip-flops, or scan cells, linked in a chain for testing purposes.</p><h5 id="ww1189429" class="GlossTerm"><span></span>scan net</h5><p id="ww1189430" class="GlossDef"><span></span>A scan net is a net whose pins are all scan pins.</p><h5 id="ww1189431" class="GlossTerm"><span></span>.sch</h5><p id="ww1189432" class="GlossDef"><span></span>An .sch file is a Schematic Editor file.</p><h5 id="ww1189433" class="GlossTerm"><span></span>schematic</h5><p id="ww1189434" class="GlossDef"><span></span>A schematic is a drawing representing a design in terms of user and library components.</p><h5 id="ww1189435" class="GlossTerm"><span></span>Schematic Editor</h5><p id="ww1189436" class="GlossDef"><span></span>Schematic Editor is an application that enables you to create and edit schematic files that can represent a complete design or any component of a hierarchical design. </p><h5 id="ww1189437" class="GlossTerm"><span></span>Schmitt trigger</h5><p id="ww1189438" class="GlossDef"><span></span>A Schmitt trigger is a type of comparator circuit that forces certain input signals to conform to the shape of true digital signals, or waveforms, before passing them to other parts of the logic circuit: signals with slow rise times, slow fall times, or both; noisy signals; or analog signals. The trigger for this circuit to change states is the input voltage level. The Schmitt trigger uses two voltage thresholds, a high threshold during low-to-high transitions, and a low threshold during high-to-low transitions. It changes its output state only when the input voltage level rises above the higher threshold, then uses hysteresis to prevent the output from automatically switching back until the input voltage level goes below the lower voltage threshold. A Schmitt trigger stabilizes a circuit by preventing noise from triggering rapid switching back and forth between the two output states when the inputs are close to the threshold.</p><h5 id="ww1189439" class="GlossTerm"><span></span>.scr</h5><p id="ww1189440" class="GlossDef"><span></span>An .scr file is an ASCII-based EPIC command script file.</p><h5 id="ww1189441" class="GlossTerm"><span></span>script</h5><p id="ww1189442" class="GlossDef"><span></span>A script is a series of commands that automatically execute a complex operation, such as the steps in a design flow. See also <a href="../../Reference%20Guides/Glossary/glossary.44.10.htm#ww1193118" title="J">JScript</a> and <a href="../../Reference%20Guides/Glossary/glossary.44.21.htm#ww1193164" title="V">VBScript</a>.</p><h5 id="ww1189446" class="GlossTerm"><span></span>.sdf</h5><p id="ww1194801" class="GlossDef"><span></span>An .sdf file is an industry-standard file format for specifying timing information. It is usually used for simulation. It is required by ModelSim / Questa for timing simulation.</p><h5 id="ww1194802" class="GlossTerm"><span></span>SDC </h5><p id="ww1194805" class="GlossDef"><span></span>SDC is Synopsys’ widely used design constraints format that describes the design intent and surrounding constraints for synthesis, clocking, timing, power, test, and environmental and operating conditions. The Lattice Synthesis Engine can read and process SDC. See also <a href="../../Reference%20Guides/Glossary/glossary.44.06.htm#ww1215339" title="F">.fdc</a> and <a href="../../Reference%20Guides/Glossary/glossary.44.11.htm#ww1200067" title="L">.ldc</a>.</p><h5 id="ww1189448" class="GlossTerm"><span></span>SDF</h5><p id="ww1189451" class="GlossDef"><span></span>SDF is an abbreviation for standard delay format. See <a href="../../Reference%20Guides/Glossary/glossary.44.18.htm#ww1189446" title="S">.sdf</a>.</p><h5 id="ww1189453" class="GlossTerm"><span></span>SDR</h5><p id="ww1189454" class="GlossDef"><span></span>SDR is an abbreviation for single data rate, a memory interface in an SDRAM that captures data on one edge of the clock.</p><h5 id="ww1189455" class="GlossTerm"><span></span>SDRAM</h5><p id="ww1189456" class="GlossDef"><span></span>SDRAM is an abbreviation for synchronous dynamic random-access memory, which is a type of dynamic random-access memory (DRAM) that can run at much higher clock speeds than conventional memory.</p><h5 id="ww1189457" class="GlossTerm"><span></span>sequence depth</h5><p id="ww1189458" class="GlossDef"><span></span>The sequence depth is the number of sequences used in a trigger expression in Reveal Inserter and Reveal Analyzer. Sequences are sequential states connected by THEN operators. </p><h5 id="ww1189460" class="GlossTerm"><span></span>sequential function</h5><p id="ww1189461" class="GlossDef"><span></span>A sequential function is a logic circuit whose output values depend on both its current input values and on a sequence of previous input values. See also <a href="../../Reference%20Guides/Glossary/glossary.44.03.htm#ww1188144" title="C">combinational function</a>.</p><h5 id="ww1189465" class="GlossTerm"><span></span>sequential logic</h5><p id="ww1189466" class="GlossDef"><span></span>Sequential logic is a logic network that is built around flip-flops. Examples of sequential circuits are counters and state machines. Sequential logic circuits are not necessarily synchronous just because they contain clocked elements.</p><h5 id="ww1189468" class="GlossTerm"><span></span>SERDES</h5><p id="ww1189469" class="GlossDef"><span></span>SERDES is an abbreviation of serializer/deserializer, which is an integrated circuit transceiver that converts serial data to parallel data, and parallel data to serial data. SERDES devices are used in telecommunications systems to facilitate the transmission of parallel data between two points over serial streams, reducing the number of data paths and therefore the number of connecting pins or wires required.</p><h5 id="ww1189470" class="GlossTerm"><span></span>serial boot PROM</h5><p id="ww1189471" class="GlossDef"><span></span>A serial boot PROM is a method of configuring a Lattice Semiconductor FPGA at startup.</p><h5 id="ww1189472" class="GlossTerm"><span></span>serial PROM</h5><p id="ww1189473" class="GlossDef"><span></span>A serial PROM is a PROM that is read one bit at a time. See also <a href="../../Reference%20Guides/Glossary/glossary.44.15.htm#ww1189272" title="P">programmable read-only memory</a>.</p><h5 id="ww1189477" class="GlossTerm"><span></span>set/reset</h5><p id="ww1189478" class="GlossDef"><span></span>Set/reset is an operation made possible by the asynchronous set/reset property. This function is also implemented by the global reset STARTUP primitive.</p><h5 id="ww1189479" class="GlossTerm"><span></span>setup time</h5><p id="ww1189480" class="GlossDef"><span></span>Setup time is the period before the clocking edge during which the data input to a latch or flip-flop must be held constant in order to guarantee that the latched data is correct.</p><h5 id="ww1189481" class="GlossTerm"><span></span>sheet</h5><p id="ww1189482" class="GlossDef"><span></span>A sheet is a page of a schematic.</p><h5 id="ww1189483" class="GlossTerm"><span></span>shift register</h5><p id="ww1189484" class="GlossDef"><span></span>A shift register is a register in which data is loaded in parallel and shifted out of the register again. It refers to a chain of flip-flops connected in cascade.</p><h5 id="ww1189485" class="GlossTerm"><span></span>sidewall capacitance</h5><p id="ww1189486" class="GlossDef"><span></span>Sidewall capacitance is the same as lateral capacitance. See <a href="../../Reference%20Guides/Glossary/glossary.44.11.htm#ww1188698" title="L">lateral capacitance</a>.</p><h5 id="ww1189490" class="GlossTerm"><span></span>signal</h5><p id="ww1189494" class="GlossDef"><span></span>A signal is a wire or a net. See also <a href="../../Reference%20Guides/Glossary/glossary.44.13.htm#ww1200911" title="N">net</a>.</p><h5 id="ww1189495" class="GlossTerm"><span></span>signal integrity</h5><p id="ww1189496" class="GlossDef"><span></span>Signal integrity is a signal’s freedom from noise and unpredictable delay caused by increasing coupling capacitance between neighboring signals.</p><h5 id="ww1230040" class="GlossTerm"><span></span>signature</h5><p id="ww1230063" class="GlossDef"><span></span>a digital signature guarantees the authenticity of an electronic document of message in digital communication and uses encryption techniques to provide proof of original and unmodified documentation.</p><h5 id="ww1189497" class="GlossTerm"><span></span>simulation</h5><p id="ww1189498" class="GlossDef"><span></span>Simulation is the process of verifying the logic and timing of a design.</p><h5 id="ww1189913" class="GlossTerm"><span></span>simultaneously switching outputs (SSOs)</h5><p id="ww1189917" class="GlossDef"><span></span>Simultaneously switching outputs (SSOs) are multiple output drivers that change state at the same time, which can result in power supply disturbances or noise. </p><h5 id="ww1189499" class="GlossTerm"><span></span>site</h5><p id="ww1189500" class="GlossDef"><span></span>A site is an unused or vacant resource on a device where a component can possibly be placed.</p><h5 id="ww1189501" class="GlossTerm"><span></span>skew</h5><p id="ww1189505" class="GlossDef"><span></span>See <a href="../../Reference%20Guides/Glossary/glossary.44.03.htm#ww1188135" title="C">clock skew</a>.</p><h5 id="ww1189506" class="GlossTerm"><span></span>skin effect</h5><p id="ww1189507" class="GlossDef"><span></span>The skin effect is the tendency of alternating current to flow near the surface of a conductor.</p><h5 id="ww1189508" class="GlossTerm"><span></span>slack</h5><p id="ww1189509" class="GlossDef"><span></span>Slack is the difference between the expected delay and the required delay. A positive slack time in a static timing analysis report indicates that the delay is acceptable, but a negative slack time indicates that the timing of the design does not meet the timing requirements.</p><h5 id="ww1189510" class="GlossTerm"><span></span>slave port</h5><p id="ww1189511" class="GlossDef"><span></span>A slave port is a port that cannot initiate transactions but can respond to transactions initiated by a master port if it determines that it is the targeted component for the initiated transaction.</p><h5 id="ww1189513" class="GlossTerm"><span></span>slew rate</h5><p id="ww1189514" class="GlossDef"><span></span>The slew rate is the speed with which the output voltage level transitions from low to high or high to low. The slew rate determines how fast the transistors on the outputs change states.</p><h5 id="ww1189517" class="GlossTerm"><span></span>slice</h5><p id="ww1189518" class="GlossDef"><span></span>A slice is an architectural element within an FPGA consisting of two LUT4 lookup tables that feed two registers (programmed to be in FF or latch mode) and some associated logic that allows the LUTs to be combined to perform functions such as LUT5, LUT6, LUT7, and LUT8. It also includes control logic to perform set/reset functions (programmable as synchronous/ asynchronous), clock select, chip select, and wider RAM/ROM functions. The registers in the slice can be configured for positive or negative and edge or level clocks. There are four interconnected slices per PFU block. Each slice in a PFU is capable of four modes of operation: logic, ripple, RAM, and ROM. Each slice in the PFF is capable of all modes except RAM.</p><h5 id="ww1189519" class="GlossTerm"><span></span>slope</h5><p id="ww1189523" class="GlossDef"><span></span>Slope is the same as the slew rate. See <a href="../../Reference%20Guides/Glossary/glossary.44.18.htm#ww1189513" title="S">slew rate</a>.</p><h5 id="ww1189524" class="GlossTerm"><span></span>SoC</h5><p id="ww1189525" class="GlossDef"><span></span>SoC is an abbreviation for system-on-a-chip, which is an integrated circuit that includes all the components of a computer: microprocessors, memories, logic, and I/O interfaces.</p><h5 id="ww1189527" class="GlossTerm"><span></span>soft macro</h5><p id="ww1189528" class="GlossDef"><span></span>A soft macro is the logical design that determines how logical elements are interconnected functionally, but not the physical or actual wiring pattern on a chip. A soft macro can be altered with a simple text editor. Such macros are provided in synthesizable Verilog or VHDL. But it is virtually impossible for the IP provider to predict the timing of the macro, even if the customer does not modify it. The process of placement and routing is simply too unstable. See also <a href="../../Reference%20Guides/Glossary/glossary.44.08.htm#ww1188526" title="H">hard macro</a>.</p><h5 id="ww1189532" class="GlossTerm"><span></span>software application code</h5><p id="ww1189533" class="GlossDef"><span></span>The software application code is the code that runs on the LatticeMico32 microprocessor or LatticeMico8 microcontroller to control the components, the bus, and the memories. The application is written in a high-level language such as C++.</p><h5 id="ww1189534" class="GlossTerm"><span></span>SOP</h5><p id="ww1189535" class="GlossDef"><span></span>SOP is an abbreviation for sum-of-products, a method of logic representation in which the outputs are the sum of multiple product terms. More simply, it is AND-OR logic.</p><h5 id="ww1194375" class="GlossTerm"><span></span>Source Editor</h5><p id="ww1194376" class="GlossDef"><span></span>Source Editor is a Lattice Diamond application that enables you to create and edit text-based files, such as HDL files, test stimulus files, and project documentation files.</p><h5 id="ww1197467" class="GlossTerm"><span></span>SPE</h5><p id="ww1197468" class="GlossDef"><span></span>SPE is an abbreviation for Software Project Environment, one of the integrated environments of LatticeMico System. The Lattice Software Project Environment enables you to develop the C or C++ application code that runs on platforms created with Mico System Builder (MSB), use the debugger to validate the code, and deploy the application code to on-chip or flash memory. SPE uses a GNU C/C++ tool chain (compiler, assembler, linker, debugger, and other utilities such as objdump) optimized for the LatticeMico process. It uses the same graphical user interface as Mico System Builder (MSB).See also <a href="../../Reference%20Guides/Glossary/glossary.44.11.htm#ww1197446" title="L">LatticeMico System</a> and <a href="../../Reference%20Guides/Glossary/glossary.44.12.htm#ww1188928" title="M">MSB</a>.</p><h5 id="ww1189536" class="GlossTerm"><span></span>speed grade</h5><p id="ww1189537" class="GlossDef"><span></span>The speed grade specifies the frequency of the internal clock of a design. The higher the number is, the faster the clock speed. For example, -5 is faster than -3, and 5 is faster than 3.</p><h5 id="ww1195450" class="GlossTerm"><span></span>.spf</h5><p id="ww1195459" class="GlossDef"><span></span>An .spf file is a simulation project file, a script file produced by the Diamond Simulation Wizard. The .spf script file enables you to run the simulator for your project from Diamond. </p><h5 id="ww1189538" class="GlossTerm"><span></span>SPI</h5><p id="ww1189539" class="GlossDef"><span></span>SPI is an acronym for serial peripheral interface, a core that allows high-speed synchronous serial data transfers between microprocessors, microcontrollers, and peripheral devices. It can operate either as a master or as a slave.</p><h5 id="ww1189540" class="GlossTerm"><span></span>SPI serial flash</h5><p id="ww1189541" class="GlossDef"><span></span>SPI (serial peripheral interface) serial flash is a method of configuring a Lattice Semiconductor FPGA at startup.</p><h5 id="ww1189542" class="GlossTerm"><span></span>SPICE</h5><p id="ww1189543" class="GlossDef"><span></span>SPICE is an acronym for Simulation Program with Integrated Circuit Emphasis, which is a simulation program originally developed at UC Berkeley as a transistor-level circuit simulator. It is now often used to refer to any transistor-level circuit simulator.</p><h5 id="ww1189544" class="GlossTerm"><span></span>SPLD</h5><p id="ww1189545" class="GlossDef"><span></span>SPLD is an abbreviation for simple programmable logic device, which is a PLD with fewer than 1000 gates. It is also known as a low-density PLD.</p><h5 id="ww1201484" class="GlossTerm"><span></span>Spreadsheet View</h5><p id="ww1203323" class="GlossDef"><span></span>Spreadsheet View is the main application in Lattice Diamond for creating and editing design constraints known as preferences. Spreadsheet View includes separate sheets for Port Assignments, Pin Assignments, Clock Resource, Route Priority, Cell Mapping, Global Preferences, Timing Preferences, Group, and Misc Preferences. Preferences are written to the logical preference file (.lpf), and can also be edited in a text editor. See also <a href="../../Reference%20Guides/Glossary/glossary.44.11.htm#ww1188807" title="L">.lpf</a>.</p><h5 id="ww1201830" class="GlossTerm"><span></span>Spreadsheet View – TPF</h5><p id="ww1201831" class="GlossDef"><span></span>Spreadsheet View – TPF is a Lattice Diamond application that enables you to modify timing preferences for the purpose of experimentation and timing analysis. It is a part of Diamond’s Timing Analysis View and contains sheets for Global Preferences, Timing Preferences, and Group. When you make timing preference changes, the modifications are written to a timing preference file (.tpf). You can create multiple .tpf files and access them from the Analysis Files folder of Diamond’s File List view. See also <a href="../../Reference%20Guides/Glossary/glossary.44.19.htm#ww1201981" title="T">Timing Analysis View</a></p><h5 id="ww1201832" class="GlossTerm"><span></span>SRAM</h5><p id="ww1189547" class="GlossDef"><span></span>SRAM is an abbreviation for static random-access memory. See <a href="../../Reference%20Guides/Glossary/glossary.44.18.htm#ww1189570" title="S">static random-access memory</a>.</p><h5 id="ww1189551" class="GlossTerm"><span></span>SRL</h5><p id="ww1189552" class="GlossDef"><span></span>SRL is an abbreviation for shift register latch, a serial shift register used to access the programming circuitry in Lattice Semiconductor devices.</p><h5 id="ww1189935" class="GlossTerm"><span></span>SSO</h5><p id="ww1189936" class="GlossDef"><span></span>See <a href="../../Reference%20Guides/Glossary/glossary.44.18.htm#ww1189913" title="S">simultaneously switching outputs (SSOs)</a>.</p><h5 id="ww1201758" class="GlossTerm"><span></span>STA</h5><p id="ww1201762" class="GlossDef"><span></span>See <a href="../../Reference%20Guides/Glossary/glossary.44.18.htm#ww1189573" title="S">static timing analysis</a></p><h5 id="ww1189554" class="GlossTerm"><span></span>standard cell</h5><p id="ww1189555" class="GlossDef"><span></span>A standard cell is a completed design for a logic function on an integrated circuit. The function can be as simple as a clock circuit or as complex as a microcoprocessor. Since standard cells are made using blank wafers rather than partially fabricated wafers, they are more efficient than gate arrays but more costly.</p><h5 id="ww1189556" class="GlossTerm"><span></span>standard delay format</h5><p id="ww1189560" class="GlossDef"><span></span>See <a href="../../Reference%20Guides/Glossary/glossary.44.18.htm#ww1189446" title="S">.sdf</a>.</p><h5 id="ww1189561" class="GlossTerm"><span></span>standard encoding</h5><p id="ww1189562" class="GlossDef"><span></span>Standard encoding is a type of state machine encoding that forms clusters of states and uses binary encoding for each cluster. One-hot encoding is a special case of standard encoding in which each cluster contains exactly one state. Binary encoding is a special case in which all states belong to a single cluster.</p><h5 id="ww1202042" class="GlossTerm"><span></span>STAPL</h5><p id="ww1202054" class="GlossDef"><span></span>STAPL is an abbreviation for Standard Test and Program Language. A STAPL file is an output data file generated from a JEDEC input file by the Lattice Deployment tool. See also <a href="../../Reference%20Guides/Glossary/glossary.44.04.htm#ww1195711" title="D">Deployment Tool</a>.</p><h5 id="ww1189563" class="GlossTerm"><span></span>state</h5><p id="ww1189564" class="GlossDef"><span></span>A state is the set of values stored in the memory elements of a device that represent the state of that device at a particular point. To each state there corresponds a specific set of logical values.</p><h5 id="ww1189565" class="GlossTerm"><span></span>state diagram</h5><p id="ww1189566" class="GlossDef"><span></span>A state diagram is a pictorial representation of the outputs and required inputs for each state transition, as well as the sequencing between states. Each circle in a state diagram contains the name of a state. Arrows to and from the circles show the transitions between states and the input conditions that cause state transitions. These conditions are written next to each arrow.</p><h5 id="ww1189567" class="GlossTerm"><span></span>state machine</h5><p id="ww1189568" class="GlossDef"><span></span>A state machine is a set of combinatorial and sequential logic elements arranged to operate in a predefined sequence in response to specified inputs. The hardware implementation of a state machine design is a set of storage registers (flip-flops) and combinatorial logic, or gates. The storage registers store the current state, and the logic network performs the operations to determine the next state.</p><h5 id="ww1189570" class="GlossTerm"><span></span>static random-access memory</h5><p id="ww1189571" class="GlossDef"><span></span>Static random-access memory is a device that holds a value as long as power is continually supplied. It loses its contents when the power is turned off. It is sometimes called volatile memory.</p><h5 id="ww1189573" class="GlossTerm"><span></span>static timing analysis</h5><p id="ww1189574" class="GlossDef"><span></span>Static timing analysis (STA) is the process of verifying circuit timing by totaling the propagation delays along paths between clocked or combinational elements in a circuit. The analysis can determine and report timing data such as the critical path, setup- and hold-time requirements, and the maximum frequency. The primary advantage of timing analysis is that it can be run at any time and requires no input test vectors, which can be very time-consuming and tedious to create. Although timing analysis does not give you a complete timing picture, it is an excellent way to quickly verify the speed of critical paths and identify performance bottlenecks. See also <a href="../../Reference%20Guides/Glossary/glossary.44.19.htm#ww1189688" title="T">timing simulation</a>.</p><h5 id="ww1189578" class="GlossTerm"><span></span>static timing analyzer</h5><p id="ww1189579" class="GlossDef"><span></span>A static timing analyzer is a tool that analyzes the timing of the design on the basis of its paths. See also <a href="../../Reference%20Guides/Glossary/glossary.44.19.htm#ww1189716" title="T">TRACE</a> and <a href="../../Reference%20Guides/Glossary/glossary.44.19.htm#ww1201981" title="T">Timing Analysis View</a>.</p><h5 id="ww1189583" class="GlossTerm"><span></span>Steiner tree</h5><p id="ww1189584" class="GlossDef"><span></span>A Steiner tree is the shortest route for connecting a set of pins.</p><h5 id="ww1202140" class="GlossTerm"><span></span>strategy</h5><p id="ww1202141" class="GlossDef"><span></span>In Lattice Diamond, a strategy is a collection of settings for controlling the different stages of the design implementation process, including logic synthesis, mapping, and place and route. Each implementation (version) of a design project in Lattice Diamond is associated with a specific strategy. A default strategy, Strategy1, is automatically assigned to a new project. A strategy can also be a predefined strategy or a customized strategy, and any number of them can be applied to a project to find the best solution to meet design objectives. See also <a href="../../Reference%20Guides/Glossary/glossary.44.09.htm#ww1188580" title="I">implementation</a>.</p><h5 id="ww1202272" class="GlossTerm"><span></span>.sty</h5><p id="ww1202295" class="GlossDef"><span></span>An .sty file is a Lattice Diamond strategy file.</p><h5 id="ww1202100" class="GlossTerm"><span></span>.svf</h5><p id="ww1202088" class="GlossDef"><span></span>An .svf file is a file in serial vector format, which is a software language that is tailored to drive test access port controllers. An .svf file is an ASCII file that stores programming data for programming one or more fixed algorithm devices in automatic test equipment-type programming environments.</p><h5 id="ww1189587" class="GlossTerm"><span></span>SVF</h5><p id="ww1189588" class="GlossDef"><span></span>SVF is an abbreviation for serial vector format, which is a software language that is tailored to drive test access port controllers. See also <a href="../../Reference%20Guides/Glossary/glossary.44.19.htm#ww1189636" title="T">TAP</a>.</p><h5 id="ww1189592" class="GlossTerm"><span></span>SWL</h5><p id="ww1189593" class="GlossDef"><span></span>SWL is an abbreviation for soft-wired lookup table, which is a fast, programmable connection between the LUTs in an PFU that allows for very wide combinational functions. See also <a href="../../Reference%20Guides/Glossary/glossary.44.11.htm#ww1188802" title="L">lookup table (LUT)</a>.</p><h5 id="ww1189597" class="GlossTerm"><span></span>_sy</h5><p id="ww1189598" class="GlossDef"><span></span>A -sy file is a Symbol Editor log file.</p><h5 id="ww1189599" class="GlossTerm"><span></span>.sym</h5><p id="ww1189600" class="GlossDef"><span></span>An .sym file is a Symbol Editor file.</p><h5 id="ww1189603" class="GlossTerm"><span></span>symbol</h5><p id="ww1189604" class="GlossDef"><span></span>A symbol is a graphical representation of one level of hierarchy.</p><h5 id="ww1189605" class="GlossTerm"><span></span>symbol attributes</h5><p id="ww1189606" class="GlossDef"><span></span>Symbol attributes are characteristics or properties associated with a symbol.</p><h5 id="ww1189607" class="GlossTerm"><span></span>Symbol Editor</h5><p id="ww1189608" class="GlossDef"><span></span>Symbol Editor is an application that comes with a standard symbol library. Use Symbol Editor to create symbols or primitive elements that represent an independent schematic module. You can also use Symbol Editor to create decorative symbols, such as title blocks.</p><h5 id="ww1189609" class="GlossTerm"><span></span>symbol origin</h5><p id="ww1189610" class="GlossDef"><span></span>The symbol origin is the point on a symbol that attaches to the cursor when the symbol is placed in Schematic Editor.</p><h5 id="ww1189611" class="GlossTerm"><span></span>symbolic state machine</h5><p id="ww1189612" class="GlossDef"><span></span>A symbolic state machine is a state machine that makes no reference to the actual values stored in the state register for the different states in the state table. The software determines what these values should be. All that is defined in a symbolic state machine is the relationship among the states in terms of how input signals affect transitions between them, the values of the outputs during each state, and in some cases, the initial state.</p><h5 id="ww1189613" class="GlossTerm"><span></span>synchronous</h5><p id="ww1189614" class="GlossDef"><span></span>Synchronous describes an entity that is synchronized to a shared signal like a clock.</p><h5 id="ww1189615" class="GlossTerm"><span></span>synchronous clock</h5><p id="ww1189616" class="GlossDef"><span></span>A synchronous clock is a synchronous control in which flip-flops are set or reset on the rising edge of the clock.</p><h5 id="ww1189617" class="GlossTerm"><span></span>Synplify Pro for Lattice</h5><p id="ww1189618" class="GlossDef"><span></span>Synplify Pro® for Lattice is a synthesis tool from Synopsys that is integrated into the suite of the Diamond software tools. It supports logic synthesis for device designs in VHDL or Verilog. It can be invoked from the main window or run as a stand-alone process. Synplify starts with high-level designs written in Verilog or VHDL hardware description languages (HDLs) and converts the HDL into small, high-performance design netlists that are optimized for Lattice Semiconductor devices.</p><h5 id="ww1189619" class="GlossTerm"><span></span>synthesis</h5><p id="ww1189620" class="GlossDef"><span></span>Synthesis is the process of translating a high-level RTL design description (which might consist of state machines, truth tables, Boolean equations, or all three) into a process-specific gate-level implementation.</p><h5 id="ww1202325" class="GlossTerm"><span></span>synthesis constraint file</h5><p id="ww1202329" class="GlossDef"><span></span>A synthesis constraint file is a source file that describes the design intent and surrounding constraints for synthesis, clocking, timing, power, test, and environmental and operating conditions. See also <a href="../../Reference%20Guides/Glossary/glossary.44.18.htm#ww1194802" title="S">SDC</a>, <a href="../../Reference%20Guides/Glossary/glossary.44.06.htm#ww1215339" title="F">.fdc</a>, and <a href="../../Reference%20Guides/Glossary/glossary.44.11.htm#ww1200067" title="L">.ldc</a>.</p><h5 id="ww1189621" class="GlossTerm"><span></span>synthesis package</h5><p id="ww1189622" class="GlossDef"><span></span>A synthesis package is a fixed library of cells, with each cell containing the implementation details in terms of primitive logic.</p><h5 id="ww1189623" class="GlossTerm"><span></span>sysCLOCK</h5><p id="ww1189624" class="GlossDef"><span></span>sysCLOCK is a Lattice PLL and DLL technology for managing clock distribution and skew to improve overall system performance. See also <a href="../../Reference%20Guides/Glossary/glossary.44.15.htm#ww1189174" title="P">PLL</a> and <a href="../../Reference%20Guides/Glossary/glossary.44.04.htm#ww1188282" title="D">DLL</a>.</p><h5 id="ww1189625" class="GlossTerm"><span></span>sysCONFIG</h5><p id="ww1189626" class="GlossDef"><span></span>sysCONFIG is a Lattice Semiconductor interface that provides multiple configuration modes, as well as the dedicated ispJTAG port and boundary scan, so that configuration memory can be loaded automatically at power-up, or any time that you want to update the device.</p><h5 id="ww1189627" class="GlossTerm"><span></span>sysDSP</h5><p id="ww1189628" class="GlossDef"><span></span>sysDSP is a Lattice DSP block used to develop digital signal processing functions.</p><h5 id="ww1189629" class="GlossTerm"><span></span>sysI/O</h5><p id="ww1189630" class="GlossDef"><span></span>sysI/O is a Lattice I/O buffer that supports a variety of single-ended and differential signaling standards, as well as the DQS strobe signal that is required for interfacing with the DDR memory.</p><h5 id="ww1189631" class="GlossTerm"><span></span>sysMEM</h5><p id="ww1189632" class="GlossDef"><span></span>sysMEM is a Lattice embedded block RAM that can operate as single-port or dual-port RAM.</p></div><div id="page_dates"><div class="ww_skin_page_publish_date"></div></div><!-- Related Topics --><!--                --><footer><!-- Disqus --><!--        --><!-- Google Translation --><!--                    --><br /></footer></div></div><noscript><div id="noscript_warning">This site works best with JavaScript enabled</div></noscript></body></html>