<!DOCTYPE html ><html xml:lang="en" lang="en" data-highlight-require-whitespace="false" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><title>C</title><link rel="Prev" href="glossary.44.02.htm" title="Previous" /><link rel="Next" href="glossary.44.04.htm" title="Next" /><link rel="StyleSheet" href="../../css/font-awesome/css/font-awesome.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/glossary.css" type="text/css" media="all" /><link rel="StyleSheet" href="../css/webworks.css" type="text/css" media="all" /><link rel="StyleSheet" href="../css/skin.css" type="text/css" media="all" /><link rel="StyleSheet" href="../css/social.css" type="text/css" media="all" /><link rel="StyleSheet" href="../css/print.css" type="text/css" media="print" /><script type="text/javascript" src="../scripts/common.js"></script><script type="text/javascript" src="../scripts/page.js"></script><script type="text/javascript" src="../scripts/search-client.js"></script><script type="text/javascript" src="../scripts/unidata.js"></script><script type="text/javascript" src="../scripts/unibreak.js"></script><noscript><div id="noscript_padding"></div></noscript></head><body id="peZ8JmWpbRRAsM2L7iUW7pA" class="ww_skin_page_body" onload="Page.OnLoad('../../index.htm#page/Reference%20Guides/Glossary/glossary.44.03.htm');"><div id="ww_content_container"><header id="wwconnect_header"><div class="ww_skin_page_toolbar"><a class="ww_behavior_print ww_skin ww_skin_print" title="Print" href="#"><i class="fa"></i></a></div><!-- was this helpful button --><!--                         --><!-- Moved breadcrumbs to bottom of the header so that the print --><!-- button would float to the right of the breadcrumbs. --><!-- PH 4June2019 --><div class="ww_skin_breadcrumbs"><a class="WebWorks_Breadcrumb_Link" href="../Strategies/strategy_settings.htm">Reference Guides</a> &gt; <a class="WebWorks_Breadcrumb_Link" href="glossary.44.01.htm#1188065">Glossary</a> &gt; C</div></header><div id="page_content_container" style="background-color: White; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px"><div id="page_content"><h2 id="ww1188065" class="Heading1"><span></span>C</h2><h5 id="ww1188066" class="GlossTerm"><span></span>C/C++ SPE</h5><p id="ww1188067" class="GlossDef"><span></span>C/C++ SPE is an abbreviation for the C/C++ Software Project Environment. See <a href="../../Reference%20Guides/Glossary/glossary.44.18.htm#ww1197467" title="S">SPE</a>.</p><h5 id="ww1188068" class="GlossTerm"><span></span>CAM</h5><p id="ww1188069" class="GlossDef"><span></span>CAM is an abbreviation for content addressable memory. Also known as “associative storage,” it is a memory chip in which each bit position can be compared. In regular dynamic RAM (DRAM) and static RAM (SRAM) chips, the contents are addressed by bit location and then transferred to the arithmetic logic unit (ALU) in the CPU for comparison. In CAM chips, the content is compared in each bit cell, allowing for very fast table lookups.</p><h5 id="ww1188070" class="GlossTerm"><span></span>capacitance</h5><p id="ww1188071" class="GlossDef"><span></span>Capacitance is the ability of a conductor to store electric charge or a certain number of electrons. It is expressed in farads.</p><h5 id="ww1188072" class="GlossTerm"><span></span>capacitive reactance</h5><p id="ww1188073" class="GlossDef"><span></span>Capacitive reactance is the opposition to current flow provided by a capacitor. It is measured in ohms and varies inversely with frequency.</p><h5 id="ww1188074" class="GlossTerm"><span></span>carry logic</h5><p id="ww1188075" class="GlossDef"><span></span>Carry logic is logic that is designed to speed up and reduce the area of counters, adders, incrementors, decrementors, comparators, and subtractors. It is a special interconnect that speeds up the carry path of adders and counters.</p><h5 id="ww1188076" class="GlossTerm"><span></span>CDR</h5><p id="ww1188079" class="GlossDef"><span></span>CDR is an abbreviation for clock data recovery. See <a href="../../Reference%20Guides/Glossary/glossary.44.03.htm#ww1188118" title="C">clock data recovery</a>.</p><h5 id="ww1188081" class="GlossTerm"><span></span>CDT</h5><p id="ww1188082" class="GlossDef"><span></span>CDT is an abbreviation for C/C++ development tools, which are components, or plug-ins, of the Eclipse development environment on which LatticeMico™ System is based.</p><h5 id="ww1188083" class="GlossTerm"><span></span>cell library</h5><p id="ww1188084" class="GlossDef"><span></span>A cell library is the collective name given to a set of logic functions as defined by the manufacturer.</p><h5 id="ww1188085" class="GlossTerm"><span></span>cell symbol</h5><p id="ww1188086" class="GlossDef"><span></span>A cell symbol is a schematic symbol that represents the primitive cells, such as transistors, resistors, and diodes, used to design integrated circuits.</p><h5 id="ww1188087" class="GlossTerm"><span></span>CFI</h5><p id="ww1188088" class="GlossDef"><span></span>CFI is an abbreviation for Common Flash Interface (CFI) parallel flash memory, which is an open standard jointly developed by a number of chip vendors for a type of EEPROM that stores information without requiring a power source.</p><h5 id="ww1188089" class="GlossTerm"><span></span>chain file</h5><p id="ww1188093" class="GlossDef"><span></span>A chain file is an .xcf file. See <a href="../../Reference%20Guides/Glossary/glossary.44.23.htm#ww1189883" title="X">.xcf</a>.</p><h5 id="ww1188094" class="GlossTerm"><span></span>chip check</h5><p id="ww1188095" class="GlossDef"><span></span>A chip check is a physical design-rule check that examines a special class of checks for nets, components, or both at the chip level, such as placement rules with respect to one side of the device.</p><h5 id="ww1188096" class="GlossTerm"><span></span>CIB</h5><p id="ww1188097" class="GlossDef"><span></span>CIB is an abbreviation for a common interface block, which is a switch matrix that can be programmed to connect virtually any routing resource to any input or output of the logic element.</p><h5 id="ww1188098" class="GlossTerm"><span></span>CIP</h5><p id="ww1188099" class="GlossDef"><span></span>CIP is an abbreviation for configurable interconnect point, which refers to the switching circuitry that connects routing segments on a net. It provides one or more of three basic functions: signal switching, amplification, or isolation. A net running from a PFU or PIC output (source) to a PLC or PIC input (destination) consists of one or more routing segments connected by CIPs. In EPIC, the graphic representations of CIPs are also called nodes.</p><h5 id="ww1188103" class="GlossTerm"><span></span>cleanup routing</h5><p id="ww1188104" class="GlossDef"><span></span>Cleanup routing is the second stage of routing (also called delay reduction routing). During cleanup routing, the router takes the result of iterative routing, the first stage, and reroutes some connections to minimize the signal delays within the device.</p><h5 id="ww1188105" class="GlossTerm"><span></span>CLKFB divider</h5><p id="ww1188106" class="GlossDef"><span></span>CLKFB is an abbreviation for feedback clock divider, which is a PLL block that multiplies the output of a PLL. The CLKFB divider is used to divide the feedback signal. Effectively, this multiplies the output clock, because the divided feedback must speed up to match the input frequency into the PLL block. The PLL block increases the output frequency until the divided feedback frequency equals the input frequency. Like the input divider, the feedback loop divider can be set to an integer value of 1 to 16. The input and output of the feedback divider must be within the input and output frequency ranges specified in the device data sheet.</p><h5 id="ww1188107" class="GlossTerm"><span></span>CLKI divider</h5><p id="ww1188108" class="GlossDef"><span></span>CLKI is an abbreviation for input clock divider, which a PLL block that divides the output of a PLL. The CLKI divider is used to control the input clock frequency into the PLL block. It can be set to an integer value of 1 to 16. The divider setting directly corresponds to the divisor of the output clock. The input and output of the input divider must be within the input and output frequency ranges specified in the device data sheet.</p><h5 id="ww1188109" class="GlossTerm"><span></span>CLKOK divider</h5><p id="ww1188110" class="GlossDef"><span></span>CLKOK is an abbreviation for clock divider, which is a PLL block that obtains the divided value of the primary clock. The CLKOK divider feeds the global clock net. It divides the CLKOP signal of the PLL by the value of the divider. It can be set to values of 2, 4, 6, ...126,128.</p><h5 id="ww1188111" class="GlossTerm"><span></span>CLKOP divider</h5><p id="ww1188112" class="GlossDef"><span></span>CLKOP is an abbreviation for primary clock output divider, which is a PLL block that sets the VCO operating frequency. The CLKOP divider serves dual purposes of squaring the duty cycle of the VCO output and scaling up the VCO frequency into the 420-MHz to 840-MHz range to minimize jitter.</p><h5 id="ww1188113" class="GlossTerm"><span></span>clock</h5><p id="ww1188114" class="GlossDef"><span></span>A clock is a signal or square waveform used to synchronize the timing of the circuits in a digital integrated circuit. It switches between a high and a low state, usually with a 50-percent duty cycle.</p><h5 id="ww1188115" class="GlossTerm"><span></span>clock boosting</h5><p id="ww1188116" class="GlossDef"><span></span>Clock boosting is the timing optimization of designs through clock skew scheduling to improve the performance in a synchronous system. Clock boosting is achieved by scheduling clock delay signals at each register to relax critical paths.</p><h5 id="ww1188118" class="GlossTerm"><span></span>clock data recovery</h5><p id="ww1188119" class="GlossDef"><span></span>Clock data recovery is the process of eliminating channel-to-channel, clock-to-channel skew. It is implemented in the HSI embedded module. The clock signal is encoded in the data stream. This encoding scheme eliminates the need for a separate clock channel and assures that the clock and data are in phase, enabling higher bandwidth at lower cost.</p><h5 id="ww1188120" class="GlossTerm"><span></span>clock enable</h5><p id="ww1188121" class="GlossDef"><span></span>A clock enable is a binary signal that allows or prevents synchronous logic from changing with a clock signal. When enabled, this control signal permits a device to be clocked and to become active. There are four different states. The two active high states are CE 0 disabled and CE 1 enabled. The two active low states are CE 0 enabled and CE 1 disabled.</p><h5 id="ww1188123" class="GlossTerm"><span></span>clock frequency</h5><p id="ww1188124" class="GlossDef"><span></span>Clock frequency is the number of complete clock cycles that occur per unit of time. For example, a 50-MHz clock signal cycles 50 million times per second.</p><h5 id="ww1188126" class="GlossTerm"><span></span>clock gating</h5><p id="ww1188127" class="GlossDef"><span></span>Clock gating is the process of using combinational logic elements, such as an AND gate, to disable the clock signal in unused circuits. Clock gating prevents power dissipation due to unnecessary charging and discharging of the unused circuits.</p><h5 id="ww1188128" class="GlossTerm"><span></span>clock input path</h5><p id="ww1188129" class="GlossDef"><span></span>A clock input path is a path that starts either at an input of the chip or at the output of a flip-flop, latch, or RAM and ends at any clock pin on a flip-flip or latch enable. The clock input path time is the maximum time required for the signal to arrive at the flip-flop clock input. Clock input paths help to determine system-level design timing.</p><h5 id="ww1188130" class="GlossTerm"><span></span>clock latency</h5><p id="ww1188131" class="GlossDef"><span></span>Clock latency is the number of clock cycles that it takes data to propagate from input to output.</p><h5 id="ww1188132" class="GlossTerm"><span></span>clock pulse</h5><p id="ww1188133" class="GlossDef"><span></span>A click pulse is a signal that synchronizes the operation of an electronic system. Clock pulses are continuous, precisely spaced changes in voltage.</p><h5 id="ww1188135" class="GlossTerm"><span></span>clock skew</h5><p id="ww1188136" class="GlossDef"><span></span>Clock skew is the time differential between two or more destination pins in a path.</p><h5 id="ww1188137" class="GlossTerm"><span></span>clock tree</h5><p id="ww1188138" class="GlossDef"><span></span>A clock tree is a network of clock signals distributed throughout a design. An optimal clock tree replaces high-fanout nets with a balanced tree of buffers to minimize clock skew.</p><h5 id="ww1188139" class="GlossTerm"><span></span>clock-tree synthesis</h5><p id="ww1188140" class="GlossDef"><span></span>Clock-tree synthesis is the process of generating an optimal clock-tree network by inserting a tree of buffers to replace a high-fanout net, balancing the clock arrival times at the leaf nodes to minimize clock skew.</p><h5 id="ww1188141" class="GlossTerm"><span></span>code-relocator code</h5><p id="ww1188142" class="GlossDef"><span></span>Code-relocator code is code in LatticeMico™ System that copies the software application code to a destination memory and jumps to the application start address to run the application.</p><h5 id="ww1188144" class="GlossTerm"><span></span>combinational function</h5><p id="ww1188145" class="GlossDef"><span></span>A combinational function is a logic circuit whose output values depends on the current combination of values on its inputs at any given moment. See also <a href="../../Reference%20Guides/Glossary/glossary.44.18.htm#ww1189460" title="S">sequential function</a>.</p><h5 id="ww1188149" class="GlossTerm"><span></span>comparator</h5><p id="ww1188150" class="GlossDef"><span></span>A comparator is a logic function used to compare sets of binary values to see if they contain the same data.</p><h5 id="ww1188151" class="GlossTerm"><span></span>compiling</h5><p id="ww1188152" class="GlossDef"><span></span>Compiling is the process of changing the design entry format into Boolean equations, which serve as input to simulation and device implementation programs. In general, compiling a design involves running every process after design entry. These processes include compiling and optimizing steps that can be performed on a single source or on the entire design. The Lattice Diamond software accept several design entry formats. With the exception of EDIF, all designs must be either synthesized or compiled before being placed and routed.</p><h5 id="ww1188153" class="GlossTerm"><span></span>component</h5><p id="ww1188154" class="GlossDef"><span></span>A component is an instantiation or symbol reference from a library of logic elements that can be placed on a schematic. Components are constructed using primitive logic gates or primitives. For EPIC users, a component more specifically refers to a logical configuration that will, at some point, go into a site. Examples of components are logic blocks, I/O blocks, tristate buffers, GSRs, PCMs, and oscillators.</p><h5 id="ww1188155" class="GlossTerm"><span></span>component description file</h5><p id="ww1188159" class="GlossDef"><span></span>See <a href="../../Reference%20Guides/Glossary/glossary.44.23.htm#ww1189886" title="X">.xml</a>.</p><h5 id="ww1188160" class="GlossTerm"><span></span>component information structure declaration</h5><p id="ww1188161" class="GlossDef"><span></span>The component information structure declaration is specified as part of the component description (.xml) file in LatticeMico System and is copied into the platform description (.msb) file by the Mico System Builder (MSB). Each component in the platform is represented in the .msb file. The component’s information in the .msb file includes the details about the component’s source files that will need to be included in the build process. The information is then extracted from the .msb file by the build process and put into the DDStructs.h file. Each unique component must have its own unique component information structure defined within its component description file.</p><h5 id="ww1188162" class="GlossTerm"><span></span>component instance declaration</h5><p id="ww1188163" class="GlossDef"><span></span>The component instance declaration declares presence of an instantiated structure for those component instances that have a corresponding information structure in LatticeMico System. It originates in the component description (.xml) file.</p><h5 id="ww1188164" class="GlossTerm"><span></span>configuration</h5><p id="ww1188165" class="GlossDef"><span></span>Configuration is the process of loading design-specific bitstreams into one or more programmable devices to define the functional operation of the logical blocks, their interconnections, and the chip I/O.</p><h5 id="ww1188166" class="GlossTerm"><span></span>congestion</h5><p id="ww1188167" class="GlossDef"><span></span>Congestion is the ratio of the number of wires that are actually routed across the edge of a cell to the capacity of the edge to accept them</p><h5 id="ww1188168" class="GlossTerm"><span></span>constrained path</h5><p id="ww1188169" class="GlossDef"><span></span>A constrained path is a path that has a timing preference or requirement ascribed to it.</p><h5 id="ww1202901" class="GlossTerm"><span></span>constraint file</h5><p id="ww1202895" class="GlossDef"><span></span>A constraint file is a file that specifies design constraint (location and path delay) information in textual form. In Lattice Diamond, a constraint file can be a logical preference file or a synthesis constraint file. See also <a href="../../Reference%20Guides/Glossary/glossary.44.11.htm#ww1188807" title="L">.lpf</a>and <a href="../../Reference%20Guides/Glossary/glossary.44.18.htm#ww1202325" title="S">synthesis constraint file</a>.</p><h5 id="ww1190096" class="GlossTerm"><span></span>constraints</h5><p id="ww1190094" class="GlossDef"><span></span>Constraints are directives that are applied by the placement and routing programs to meet user objectives. Constraints can be declared as FPGA attributes in the HDL, schematic, or EDIF source files; or they can be declared as preferences in the logical preference file (.lpf). For designs that use the Lattice Synthesis Engine (LSE), constraints can also include Synopsys® Design constraints (SDC) that are directly interpreted by the synthesis engine.</p><h5 id="ww1196608" class="GlossTerm"><span></span>constructive placement</h5><p id="ww1188173" class="GlossDef"><span></span>Constructive placement is the first stage of placement. In this stage, PAR places components into sites on the basis of such factors as the constraints specified in the input file, the length of connections, the available routing resources, the cost tables that assign random weighted values to each of the relevant factors. See also <a href="../../Reference%20Guides/Glossary/glossary.44.14.htm#ww1189008" title="O">optimizing placement</a>.</p><h5 id="ww1188174" class="GlossTerm"><span></span>core</h5><p id="ww1188175" class="GlossDef"><span></span>A core is a relatively large block that implements a general-purpose logic function and is used as a building block in chip design. Examples of cores are microprocessor and DSP cores. Cores are also called IP (intellectual property).</p><h5 id="ww1188176" class="GlossTerm"><span></span>counter</h5><p id="ww1188177" class="GlossDef"><span></span>A counter is 1) a logic function composed of flip-flops that stores count values. The number of value states through which a counter sequences before returning to its original value is called the modulus. For example, a modulus that counts from 0 to 15 (decimal equivalent to binary) is called a modulo-16, or mod-16, counter. 2) A mechanism connected to the pattern comparator in the Reveal core that specifies the number of times that the sampled trigger bus data must match the selected pattern in order for an event to occur.</p><h5 id="ww1188178" class="GlossTerm"><span></span>coupling capacitance</h5><p id="ww1188179" class="GlossDef"><span></span>Coupling capacitance is the parasitic capacitance between two signals. It is used for allowing only certain AC signals to pass to other circuits.</p><h5 id="ww1188180" class="GlossTerm"><span></span>CPLD</h5><p id="ww1188181" class="GlossDef"><span></span>CPLD is an abbreviation for complex programmable logic device, which is an erasable programmable logic device that can be programmed with a schematic or a behavioral design. CPLDs constitute a type of complex PLD based on EPROM or EEPROM technology. They are characterized by an architecture offering high speed, predictable timing, and simple software. The basic CPLD cell is called a macrocell, which is the CPLD implementation of a GLB. It is composed of AND gate arrays and is surrounded by the interconnect area.</p><h5 id="ww1188182" class="GlossTerm"><span></span>critical path</h5><p id="ww1188183" class="GlossDef"><span></span>The critical path is the path through a circuit that determines the maximum speed at which the circuit can operate. The critical path is a signal in a section of combinatorial logic that limits the speed of the logic. Storage elements begin and end a critical path, which may include I/O pads.</p><h5 id="ww1188184" class="GlossTerm"><span></span>cross-probing</h5><p id="ww1188185" class="GlossDef"><span></span>Cross-probing is 1) the inter-process communication between the synthesis or simulation results and the source code from which it originated 2) selecting an element in one view in Lattice Diamond and displaying the corresponding logical or physical element in a different view.</p><h5 id="ww1188186" class="GlossTerm"><span></span>crosstalk</h5><p id="ww1188187" class="GlossDef"><span></span>Crosstalk is a charge injected on a net by capacitive or inductive coupling when coupled signals switch voltage.</p><h5 id="ww1188188" class="GlossTerm"><span></span>CSR</h5><p id="ww1188189" class="GlossDef"><span></span>CSR is an abbreviation for a control and status register, which is a register in most CPUs that stores additional information about the results of machine instructions, for example, comparisons. It usually consists of several independent flags, such as carry, overflow, and zero. The CSR is mainly used to determine the outcome of conditional branch instructions or other forms of conditional execution.</p><h5 id="ww1188192" class="GlossTerm"><span></span>.csv</h5><p id="ww1188193" class="GlossDef"><span></span>A .csv file is a file in the comma-separated values delimited data format, in which fields are separated by the comma character and records are separated by newlines. Fields that contain a comma, a newline, or double quotation marks or that start or end with white spaces to be preserved are enclosed in double quotation marks.</p><h5 id="ww1188194" class="GlossTerm"><span></span>cycle stealing</h5><p id="ww1188195" class="GlossDef"><span></span>Cycle stealing is the timing optimization of designs through clock skew scheduling to improve the performance in a synchronous system. It is achieved by scheduling clock delay signals at each register to relax critical paths.</p></div><div id="page_dates"><div class="ww_skin_page_publish_date"></div></div><!-- Related Topics --><!--                --><footer><!-- Disqus --><!--        --><!-- Google Translation --><!--                    --><br /></footer></div></div><noscript><div id="noscript_warning">This site works best with JavaScript enabled</div></noscript></body></html>