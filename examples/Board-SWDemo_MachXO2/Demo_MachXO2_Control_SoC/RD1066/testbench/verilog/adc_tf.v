// --------------------------------------------------------------------
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
// --------------------------------------------------------------------
// Copyright (c) 2009 ~ 2010 by Lattice Semiconductor Corporation
// --------------------------------------------------------------------
//
// Permission:
//
//   Lattice Semiconductor grants permission to use this code for use
//   in synthesis for any Lattice programmable logic product.  Other
//   use of this code, including the selling or duplication of any
//   portion is strictly prohibited.
//
// Disclaimer:
//
//   This VHDL or Verilog source code is intended as a design reference
//   which illustrates how these types of functions can be implemented.
//   It is the user's responsibility to verify their design for
//   consistency and functionality through the use of formal
//   verification methods.  Lattice Semiconductor provides no warranty
//   regarding the use or functionality of this code.
//
// --------------------------------------------------------------------
//
//               Lattice Semiconductor Corporation
//               5555 NE Moore Court
//               Hillsboro, OR 97214
//               U.S.A
//
//               TEL: 1-800-Lattice (USA and Canada)
//
//               web: http://www.latticesemi.com/
//               email: techsupport@latticesemi.com
//   
// --------------------------------------------------------------------
//
// TOOL:     vlog2tf
// DATE:     10/11/2009 
// TITLE:    Lattice Semiconductor Corporation
// MODULE:   ADC
// DESIGN:   ADC
// FILENAME: adc_tf.v
// PROJECT:  lattice_adc
// VERSION:  1.0
// This file is auto generated by the ispLEVER


`timescale 1 ns / 1 ps

// Define Module for Test Fixture
module ADC_tf();

// Inputs to UUT
    reg clk;
    reg rstn;
    reg analog_cmp;

// Outputs from UUT
    wire [7:0] digital_out;
    wire analog_out;
	wire sample_rdy;


// Instantiate the UUT
// Please check and add your parameters manually
    ADC_top UUT (
        .clk_in(clk), 
        .rstn(rstn), 
        .digital_out(digital_out), 
        .analog_cmp(analog_cmp), 
        .analog_out(analog_out),
			  .sample_rdy(sample_rdy)
        );


// Initialize Inputs
    initial begin
            clk = 0;
            rstn = 0;
//			analog_cmp = 0;
    end


initial begin
$timeformat(-9,0," ns",10);
$display ("Asserting Reset");
#33 rstn = 1;
$display ("De-asserting Reset");
$display ("Applying 2KHz sawtooth input");
#2199967 ;
$display ("Simulation Finished");
$stop; // finish at 2.2ms
end


always
#8 clk = ~clk; //62.5MHz Source Clock

//  simulate analog input and low-pass feedback filter

parameter FULL_RANGE_BITS = 16;                 // bits for analog resolution (0-65535)
parameter FULL_RANGE = 2**FULL_RANGE_BITS;      

reg [FULL_RANGE_BITS-1:0] analog_input = 0;
reg [FULL_RANGE_BITS-1:0] integrator = FULL_RANGE/2;
wire [FULL_RANGE_BITS-1:0] increase;
wire [FULL_RANGE_BITS-1:0] decrease;

// Generate input sawtooth ramp
always@(posedge clk)
analog_input <= analog_input + 1;

// Calculate the integration delta 
assign increase = (FULL_RANGE - integrator) / (2**(FULL_RANGE_BITS-5));   // create a response time-constant
assign decrease = (integrator) / (2**(FULL_RANGE_BITS-5));


// Integrate the feedback
always@(posedge clk)
if (analog_out == 1)
    integrator <= integrator + increase;
else
    integrator <= integrator - decrease;

// Comparator
always@(negedge clk)
if (analog_input > integrator)
analog_cmp <= 1'b1;
else
analog_cmp <= 1'b0;


// monitor digital_out
time    sim_time;
always@(posedge clk or negedge rstn)
if (~rstn) //disable $display during reset 
sim_time <= 0;
else if (sample_rdy)
begin
sim_time <= $time;
$display ("Time: %t  digital output = %d", $time, digital_out);
end

endmodule // ADC_tf
