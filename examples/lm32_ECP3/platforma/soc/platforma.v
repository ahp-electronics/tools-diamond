//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006 by Lattice Semiconductor Corporation
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LatticeMico32 System.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      via the Lattice Open IP core license agreement.  Other use
//      of this code, including the selling or duplication of any
//      portion is strictly prohibited.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify their design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//
//      Project:           platformA
//      File:              platformA.v
//      Date:              Fri, 22 Jan 2010 08:43:04 PST
//      Version:           7.2.01.18
//      Targeted Family:   LFE3-70E-6FN672CES
//
//   =======================================================================

`timescale 1ns / 100 ps
module arbiter2(
// Multiple Master Port0
WBM0_ADR_O,
WBM0_DAT_O,
WBM0_DAT_I,
WBM0_SEL_O,
WBM0_WE_O,
WBM0_ACK_I,
WBM0_ERR_I,
WBM0_RTY_I,
WBM0_CTI_O,
WBM0_BTE_O,
WBM0_LOCK_O,
WBM0_CYC_O,
WBM0_STB_O,
// Multiple Master Port1
WBM1_ADR_O,
WBM1_DAT_O,
WBM1_DAT_I,
WBM1_SEL_O,
WBM1_WE_O,
WBM1_ACK_I,
WBM1_ERR_I,
WBM1_RTY_I,
WBM1_CTI_O,
WBM1_BTE_O,
WBM1_LOCK_O,
WBM1_CYC_O,
WBM1_STB_O,
// Single Slave Port
WBS_ADR_I,
WBS_DAT_I,
WBS_DAT_O,
WBS_SEL_I,
WBS_WE_I,
WBS_ACK_O,
WBS_ERR_O,
WBS_RTY_O,
WBS_CTI_I,
WBS_BTE_I,
WBS_LOCK_I,
WBS_CYC_I,
WBS_STB_I,
clk,reset);
input clk, reset;
input [31:0]WBM0_ADR_O;
input [31:0]WBM0_DAT_O;
output [31:0]WBM0_DAT_I;
input [3:0]WBM0_SEL_O;
input  WBM0_WE_O;
output  WBM0_ACK_I;
output  WBM0_ERR_I;
output  WBM0_RTY_I;
input [2:0]WBM0_CTI_O;
input [1:0]WBM0_BTE_O;
input  WBM0_LOCK_O;
input  WBM0_CYC_O;
input  WBM0_STB_O;
input [31:0]WBM1_ADR_O;
input [31:0]WBM1_DAT_O;
output [31:0]WBM1_DAT_I;
input [3:0]WBM1_SEL_O;
input  WBM1_WE_O;
output  WBM1_ACK_I;
output  WBM1_ERR_I;
output  WBM1_RTY_I;
input [2:0]WBM1_CTI_O;
input [1:0]WBM1_BTE_O;
input  WBM1_LOCK_O;
input  WBM1_CYC_O;
input  WBM1_STB_O;
output [31:0]WBS_ADR_I;
output [31:0]WBS_DAT_I;
input [31:0]WBS_DAT_O;
output [3:0]WBS_SEL_I;
output  WBS_WE_I;
input  WBS_ACK_O;
input  WBS_ERR_O;
input  WBS_RTY_O;
output [2:0]WBS_CTI_I;
output [1:0]WBS_BTE_I;
output  WBS_LOCK_I;
output  WBS_CYC_I;
output  WBS_STB_I;
reg [2-1:0] 		selected; // which master is selected.
reg locked;
always @(posedge clk or posedge reset)
 begin
if (reset) begin
	selected <= 0;
	locked   <= 0;
end else begin
if (selected == 0) begin
 if (WBM0_STB_O) begin
 selected <= 2'd1;
 locked   <= WBM0_LOCK_O;
end
else
 if (WBM1_STB_O) begin
 selected <= 2'd2;
 locked   <= WBM1_LOCK_O;
end
end
else if (selected == 2'd1) begin
if ((WBS_ACK_O | WBS_ERR_O | locked) && (WBM0_CTI_O == 3'b000 || WBM0_CTI_O == 3'b111 || locked) && 
!WBM0_LOCK_O)
begin selected <= 0; locked <= 0; end
end
else if (selected == 2'd2) begin
if ((WBS_ACK_O | WBS_ERR_O | locked) && (WBM1_CTI_O == 3'b000 || WBM1_CTI_O == 3'b111 || locked) && 
!WBM1_LOCK_O)
begin selected <= 0; locked <= 0; end
end
end end 
assign WBS_ADR_I = 
(selected == 2'd1 ? WBM0_ADR_O : 
(selected == 2'd2 ? WBM1_ADR_O : 
0));
assign WBS_DAT_I = 
(selected == 2'd1 ? WBM0_DAT_O : 
(selected == 2'd2 ? WBM1_DAT_O : 
0));
assign WBS_SEL_I = 
(selected == 2'd1 ? WBM0_SEL_O : 
(selected == 2'd2 ? WBM1_SEL_O : 
0));
assign WBS_WE_I = 
(selected == 2'd1 ? WBM0_WE_O : 
(selected == 2'd2 ? WBM1_WE_O : 
0));
assign WBS_CTI_I = 
(selected == 2'd1 ? WBM0_CTI_O : 
(selected == 2'd2 ? WBM1_CTI_O : 
0));
assign WBS_BTE_I = 
(selected == 2'd1 ? WBM0_BTE_O : 
(selected == 2'd2 ? WBM1_BTE_O : 
0));
assign WBS_LOCK_I = 
(selected == 2'd1 ? WBM0_LOCK_O : 
(selected == 2'd2 ? WBM1_LOCK_O : 
0));
assign WBS_CYC_I = 
(selected == 2'd1 ? WBM0_CYC_O : 
(selected == 2'd2 ? WBM1_CYC_O : 
0));
assign WBS_STB_I = 
(selected == 2'd1 ? WBM0_STB_O : 
(selected == 2'd2 ? WBM1_STB_O : 
0));
assign WBM0_DAT_I = WBS_DAT_O;
assign WBM0_ACK_I = (selected == 2'd1 ? WBS_ACK_O : 0);
assign WBM0_ERR_I = (selected == 2'd1 ? WBS_ERR_O : 0);
assign WBM0_RTY_I = (selected == 2'd1 ? WBS_RTY_O : 0);
assign WBM1_DAT_I = WBS_DAT_O;
assign WBM1_ACK_I = (selected == 2'd2 ? WBS_ACK_O : 0);
assign WBM1_ERR_I = (selected == 2'd2 ? WBS_ERR_O : 0);
assign WBM1_RTY_I = (selected == 2'd2 ? WBS_RTY_O : 0);
endmodule
`include "system_conf.v"
`include "../components/lm32_top/rtl/verilog/lm32_include_all.v"
`include "../components/asram_top/rtl/verilog/asram_core.v"
`include "../components/asram_top/rtl/verilog/asram_top.v"
`include "../components/wb_ebr_ctrl/rtl/verilog/wb_ebr_ctrl.v"
`include "../components/uart_core/rtl/verilog/uart_core.v"
`include "../components/timer/rtl/verilog/timer.v"
`include "../components/gpio/rtl/verilog/gpio.v"
`include "../components/gpio/rtl/verilog/tpio.v"


module platformA ( 
	clk_i,reset_n
, sramsram_wen
, sramsram_data
, sramsram_addr
, sramsram_csn
, sramsram_be
, sramsram_oen
, uartSIN
, uartSOUT
, LEDPIO_OUT
, gpio_7SegsPIO_OUT
);
input	clk_i, reset_n;
genvar i;
wire [31:0] zwire = 32'hZZZZZZZZ;
wire [31:0] zerowire = 32'h00000000;
wire [31:0] SHAREDBUS_ADR_I;
wire [31:0] SHAREDBUS_DAT_I;
wire [31:0] SHAREDBUS_DAT_O;
wire [3:0] SHAREDBUS_SEL_I;
wire   SHAREDBUS_WE_I;
wire   SHAREDBUS_ACK_O;
wire   SHAREDBUS_ERR_O;
wire   SHAREDBUS_RTY_O;
wire [2:0] SHAREDBUS_CTI_I;
wire [1:0] SHAREDBUS_BTE_I;
wire   SHAREDBUS_LOCK_I;
wire   SHAREDBUS_CYC_I;
wire   SHAREDBUS_STB_I;
wire SHAREDBUS_en;

wire [31:0] LM32I_ADR_O;
wire [31:0] LM32I_DAT_O;
wire [31:0] LM32I_DAT_I;
wire [3:0] LM32I_SEL_O;
wire   LM32I_WE_O;
wire   LM32I_ACK_I;
wire   LM32I_ERR_I;
wire   LM32I_RTY_I;
wire [2:0] LM32I_CTI_O;
wire [1:0] LM32I_BTE_O;
wire   LM32I_LOCK_O;
wire   LM32I_CYC_O;
wire   LM32I_STB_O;
wire [31:0] LM32D_ADR_O;
wire [31:0] LM32D_DAT_O;
wire [31:0] LM32D_DAT_I;
wire [3:0] LM32D_SEL_O;
wire   LM32D_WE_O;
wire   LM32D_ACK_I;
wire   LM32D_ERR_I;
wire   LM32D_RTY_I;
wire [2:0] LM32D_CTI_O;
wire [1:0] LM32D_BTE_O;
wire   LM32D_LOCK_O;
wire   LM32D_CYC_O;
wire   LM32D_STB_O;
wire [31:0] LM32DEBUG_DAT_O;
wire   LM32DEBUG_ACK_O;
wire   LM32DEBUG_ERR_O;
wire   LM32DEBUG_RTY_O;
wire LM32DEBUG_en;
wire [31:0] LM32interrupt_n;
`ifdef CFG_USER_ENABLED
input [31:0]  LM32user_result;
`endif // CFG_USER_ENABLED
`ifdef CFG_USER_ENABLED
input  LM32user_complete;
`endif // CFG_USER_ENABLED
`ifdef CFG_USER_ENABLED
output  LM32user_valid;
`endif // CFG_USER_ENABLED
`ifdef CFG_USER_ENABLED
output [10:0]  LM32user_opcode;
`endif // CFG_USER_ENABLED
`ifdef CFG_USER_ENABLED
output [31:0]  LM32user_operand_0;
`endif // CFG_USER_ENABLED
`ifdef CFG_USER_ENABLED
output [31:0]  LM32user_operand_1;
`endif // CFG_USER_ENABLED

wire [31:0] sramASRAM_DAT_O;
wire   sramASRAM_ACK_O;
wire   sramASRAM_ERR_O;
wire   sramASRAM_RTY_O;
wire sramASRAM_en;
output  sramsram_wen;
wire [32-1:0] sramsram_data_in;
wire [32-1:0] sramsram_data_out;
inout [32-1:0] sramsram_data;
  generate
    for (i=0; i<32; i=i+1)
      begin: u1
        BB bidi_cell
          (.I(sramsram_data_out[i]),
           .T(sramsram_wen),
           .O(sramsram_data_in[i]),
           .B(sramsram_data[i])
          );
      end
  endgenerate
output [23-1:0] sramsram_addr;
output  sramsram_csn;
output [4-1:0] sramsram_be;
output  sramsram_oen;

wire [31:0] ebrEBR_DAT_O;
wire   ebrEBR_ACK_O;
wire   ebrEBR_ERR_O;
wire   ebrEBR_RTY_O;
wire ebrEBR_en;

wire [31:0] uartUART_DAT_O;
wire   uartUART_ACK_O;
wire   uartUART_ERR_O;
wire   uartUART_RTY_O;
wire uartUART_en;
wire uartINTR;
input  uartSIN;
output  uartSOUT;
`ifdef RXRDY_ENABLE
output  uartRXRDY_N;
`endif // RXRDY_ENABLE
`ifdef TXRDY_ENABLE
output  uartTXRDY_N;
`endif // TXRDY_ENABLE
`ifdef MODEM
input  uartDCD_N;
`endif // MODEM
`ifdef MODEM
input  uartCTS_N;
`endif // MODEM
`ifdef MODEM
input  uartDSR_N;
`endif // MODEM
`ifdef MODEM
input  uartRI_N;
`endif // MODEM
`ifdef MODEM
output  uartDTR_N;
`endif // MODEM
`ifdef MODEM
output  uartRTS_N;
`endif // MODEM

wire [31:0] timerS_DAT_O;
wire   timerS_ACK_O;
wire   timerS_ERR_O;
wire   timerS_RTY_O;
wire timerS_en;
wire timerS_INT_O;

wire [31:0] LEDGPIO_DAT_O;
wire   LEDGPIO_ACK_O;
wire   LEDGPIO_ERR_O;
wire   LEDGPIO_RTY_O;
wire LEDGPIO_en;
wire LEDIRQ_O;
output [8-1:0] LEDPIO_OUT;

wire [31:0] gpio_7SegsGPIO_DAT_O;
wire   gpio_7SegsGPIO_ACK_O;
wire   gpio_7SegsGPIO_ERR_O;
wire   gpio_7SegsGPIO_RTY_O;
wire gpio_7SegsGPIO_en;
wire gpio_7SegsIRQ_O;
output [10-1:0] gpio_7SegsPIO_OUT;
wire reset_i = !reset_n;


wire one_zero = 1'b0;
wire[1:0] two_zero = 2'b00;
wire[2:0] three_zero = 3'b000;
wire[3:0] four_zero = 4'b0000;
wire[31:0] thirtytwo_zero = 32'b0000_0000_0000_0000_0000_0000_0000_0000;

arbiter2 arbiter (
.WBM0_ADR_O(LM32I_ADR_O),
.WBM0_DAT_O(LM32I_DAT_O),
.WBM0_DAT_I(LM32I_DAT_I),
.WBM0_SEL_O(LM32I_SEL_O),
.WBM0_WE_O(LM32I_WE_O),
.WBM0_ACK_I(LM32I_ACK_I),
.WBM0_ERR_I(LM32I_ERR_I),
.WBM0_RTY_I(LM32I_RTY_I),
.WBM0_CTI_O(LM32I_CTI_O),
.WBM0_BTE_O(LM32I_BTE_O),
.WBM0_LOCK_O(LM32I_LOCK_O),
.WBM0_CYC_O(LM32I_CYC_O),
.WBM0_STB_O(LM32I_STB_O),
.WBM1_ADR_O(LM32D_ADR_O),
.WBM1_DAT_O(LM32D_DAT_O),
.WBM1_DAT_I(LM32D_DAT_I),
.WBM1_SEL_O(LM32D_SEL_O),
.WBM1_WE_O(LM32D_WE_O),
.WBM1_ACK_I(LM32D_ACK_I),
.WBM1_ERR_I(LM32D_ERR_I),
.WBM1_RTY_I(LM32D_RTY_I),
.WBM1_CTI_O(LM32D_CTI_O),
.WBM1_BTE_O(LM32D_BTE_O),
.WBM1_LOCK_O(LM32D_LOCK_O),
.WBM1_CYC_O(LM32D_CYC_O),
.WBM1_STB_O(LM32D_STB_O),
.WBS_ADR_I(SHAREDBUS_ADR_I),
.WBS_DAT_I(SHAREDBUS_DAT_I),
.WBS_DAT_O(SHAREDBUS_DAT_O),
.WBS_SEL_I(SHAREDBUS_SEL_I),
.WBS_WE_I(SHAREDBUS_WE_I),
.WBS_ACK_O(SHAREDBUS_ACK_O),
.WBS_ERR_O(SHAREDBUS_ERR_O),
.WBS_RTY_O(SHAREDBUS_RTY_O),
.WBS_CTI_I(SHAREDBUS_CTI_I),
.WBS_BTE_I(SHAREDBUS_BTE_I),
.WBS_LOCK_I(SHAREDBUS_LOCK_I),
.WBS_CYC_I(SHAREDBUS_CYC_I),
.WBS_STB_I(SHAREDBUS_STB_I),
.clk(clk_i), .reset(reset_i));
assign SHAREDBUS_DAT_O = 
LM32DEBUG_en ? LM32DEBUG_DAT_O : 
sramASRAM_en ? sramASRAM_DAT_O : 
ebrEBR_en ? ebrEBR_DAT_O : 
uartUART_en ? uartUART_DAT_O : 
timerS_en ? timerS_DAT_O : 
LEDGPIO_en ? LEDGPIO_DAT_O : 
gpio_7SegsGPIO_en ? gpio_7SegsGPIO_DAT_O : 
0;
assign SHAREDBUS_ERR_O = SHAREDBUS_STB_I & !(
LM32DEBUG_en | 
sramASRAM_en | 
ebrEBR_en | 
uartUART_en | 
timerS_en | 
LEDGPIO_en | 
gpio_7SegsGPIO_en | 
0);
assign SHAREDBUS_ACK_O = 
LM32DEBUG_en ? LM32DEBUG_ACK_O : 
sramASRAM_en ? sramASRAM_ACK_O : 
ebrEBR_en ? ebrEBR_ACK_O : 
uartUART_en ? uartUART_ACK_O : 
timerS_en ? timerS_ACK_O : 
LEDGPIO_en ? LEDGPIO_ACK_O : 
gpio_7SegsGPIO_en ? gpio_7SegsGPIO_ACK_O : 
0;
assign SHAREDBUS_RTY_O = 
LM32DEBUG_en ? LM32DEBUG_RTY_O : 
sramASRAM_en ? sramASRAM_RTY_O : 
ebrEBR_en ? ebrEBR_RTY_O : 
uartUART_en ? uartUART_RTY_O : 
timerS_en ? timerS_RTY_O : 
LEDGPIO_en ? LEDGPIO_RTY_O : 
gpio_7SegsGPIO_en ? gpio_7SegsGPIO_RTY_O : 
0;
assign LM32DEBUG_en = ( SHAREDBUS_ADR_I[31:14] == 18'b000000000000000000);
lm32_top 
 LM32( 
.I_ADR_O(LM32I_ADR_O),
.I_DAT_O(LM32I_DAT_O),
.I_DAT_I(LM32I_DAT_I),
.I_SEL_O(LM32I_SEL_O),
.I_WE_O(LM32I_WE_O),
.I_ACK_I(LM32I_ACK_I),
.I_ERR_I(LM32I_ERR_I),
.I_RTY_I(LM32I_RTY_I),
.I_CTI_O(LM32I_CTI_O),
.I_BTE_O(LM32I_BTE_O),
.I_LOCK_O(LM32I_LOCK_O),
.I_CYC_O(LM32I_CYC_O),
.I_STB_O(LM32I_STB_O),
.D_ADR_O(LM32D_ADR_O),
.D_DAT_O(LM32D_DAT_O),
.D_DAT_I(LM32D_DAT_I),
.D_SEL_O(LM32D_SEL_O),
.D_WE_O(LM32D_WE_O),
.D_ACK_I(LM32D_ACK_I),
.D_ERR_I(LM32D_ERR_I),
.D_RTY_I(LM32D_RTY_I),
.D_CTI_O(LM32D_CTI_O),
.D_BTE_O(LM32D_BTE_O),
.D_LOCK_O(LM32D_LOCK_O),
.D_CYC_O(LM32D_CYC_O),
.D_STB_O(LM32D_STB_O),
.DEBUG_ADR_I(SHAREDBUS_ADR_I),
.DEBUG_DAT_I(SHAREDBUS_DAT_I),
.DEBUG_DAT_O(LM32DEBUG_DAT_O),
.DEBUG_SEL_I(SHAREDBUS_SEL_I),
.DEBUG_WE_I(SHAREDBUS_WE_I),
.DEBUG_ACK_O(LM32DEBUG_ACK_O),
.DEBUG_ERR_O(LM32DEBUG_ERR_O),
.DEBUG_RTY_O(LM32DEBUG_RTY_O),
.DEBUG_CTI_I(SHAREDBUS_CTI_I),
.DEBUG_BTE_I(SHAREDBUS_BTE_I),
.DEBUG_LOCK_I(SHAREDBUS_LOCK_I),
.DEBUG_CYC_I(SHAREDBUS_CYC_I & LM32DEBUG_en),
.DEBUG_STB_I(SHAREDBUS_STB_I & LM32DEBUG_en),
`ifdef CFG_USER_ENABLED
.user_result(LM32user_result),
`endif // CFG_USER_ENABLED
`ifdef CFG_USER_ENABLED
.user_complete(LM32user_complete),
`endif // CFG_USER_ENABLED
`ifdef CFG_USER_ENABLED
.user_valid(LM32user_valid),
`endif // CFG_USER_ENABLED
`ifdef CFG_USER_ENABLED
.user_opcode(LM32user_opcode),
`endif // CFG_USER_ENABLED
`ifdef CFG_USER_ENABLED
.user_operand_0(LM32user_operand_0),
`endif // CFG_USER_ENABLED
`ifdef CFG_USER_ENABLED
.user_operand_1(LM32user_operand_1),
`endif // CFG_USER_ENABLED
.interrupt_n(LM32interrupt_n),
.clk_i (clk_i), .rst_i (reset_i));
assign sramASRAM_en = ( SHAREDBUS_ADR_I[31:20] == 12'b000000000001);
asram_top 
#(
.READ_LATENCY(1),
.WRITE_LATENCY(1),
.SRAM_ADDR_WIDTH(23),
.SRAM_DATA_WIDTH(32),
.SRAM_BE_WIDTH(4),
.FLASH_SIGNALS(0),
.FLASH_BYTE(0),
.FLASH_BYTEN(1),
.FLASH_WP(0),
.FLASH_WPN(1),
.FLASH_RST(0),
.FLASH_RSTN(1))
 sram( 
.ASRAM_ADR_I(SHAREDBUS_ADR_I),
.ASRAM_DAT_I(SHAREDBUS_DAT_I),
.ASRAM_DAT_O(sramASRAM_DAT_O),
.ASRAM_SEL_I(SHAREDBUS_SEL_I),
.ASRAM_WE_I(SHAREDBUS_WE_I),
.ASRAM_ACK_O(sramASRAM_ACK_O),
.ASRAM_ERR_O(sramASRAM_ERR_O),
.ASRAM_RTY_O(sramASRAM_RTY_O),
.ASRAM_CTI_I(SHAREDBUS_CTI_I),
.ASRAM_BTE_I(SHAREDBUS_BTE_I),
.ASRAM_LOCK_I(SHAREDBUS_LOCK_I),
.ASRAM_CYC_I(SHAREDBUS_CYC_I & sramASRAM_en),
.ASRAM_STB_I(SHAREDBUS_STB_I & sramASRAM_en),
.sram_wen(sramsram_wen),
.sram_data_in(sramsram_data_in),
.sram_data_out(sramsram_data_out),
.sram_addr(sramsram_addr),
.sram_csn(sramsram_csn),
.sram_be(sramsram_be),
.sram_oen(sramsram_oen),
.clk_i (clk_i), .rst_i (reset_i));
assign ebrEBR_en = ( SHAREDBUS_ADR_I[31:14] == 18'b000000000010000000);
wb_ebr_ctrl 
#(
.SIZE(16384),
.EBR_DATA_WIDTH(32),
.INIT_FILE_NAME("none"),
.INIT_FILE_FORMAT("hex"))
 ebr( 
.EBR_ADR_I(SHAREDBUS_ADR_I),
.EBR_DAT_I(SHAREDBUS_DAT_I),
.EBR_DAT_O(ebrEBR_DAT_O),
.EBR_SEL_I(SHAREDBUS_SEL_I),
.EBR_WE_I(SHAREDBUS_WE_I),
.EBR_ACK_O(ebrEBR_ACK_O),
.EBR_ERR_O(ebrEBR_ERR_O),
.EBR_RTY_O(ebrEBR_RTY_O),
.EBR_CTI_I(SHAREDBUS_CTI_I),
.EBR_BTE_I(SHAREDBUS_BTE_I),
.EBR_LOCK_I(SHAREDBUS_LOCK_I),
.EBR_CYC_I(SHAREDBUS_CYC_I & ebrEBR_en),
.EBR_STB_I(SHAREDBUS_STB_I & ebrEBR_en),
.CLK_I (clk_i), .RST_I (reset_i));
assign uartUART_en = ( SHAREDBUS_ADR_I[31:7] == 25'b1000000000000000000000000);
uart_core 
#(
.ADDRWIDTH(5),
.DATAWIDTH(8),
.CLK_IN_MHZ(25.0),
.BAUD_RATE(115200),
.FIFO(0),
.STDOUT_SIM(0),
.STDOUT_SIMFAST(0))
 uart( 
.UART_ADR_I(SHAREDBUS_ADR_I),
.UART_DAT_I(SHAREDBUS_DAT_I),
.UART_DAT_O(uartUART_DAT_O),
.UART_SEL_I(SHAREDBUS_SEL_I),
.UART_WE_I(SHAREDBUS_WE_I),
.UART_ACK_O(uartUART_ACK_O),
.UART_ERR_O(uartUART_ERR_O),
.UART_RTY_O(uartUART_RTY_O),
.UART_CTI_I(SHAREDBUS_CTI_I),
.UART_BTE_I(SHAREDBUS_BTE_I),
.UART_LOCK_I(SHAREDBUS_LOCK_I),
.UART_CYC_I(SHAREDBUS_CYC_I & uartUART_en),
.UART_STB_I(SHAREDBUS_STB_I & uartUART_en),
.SIN(uartSIN),
.SOUT(uartSOUT),
`ifdef RXRDY_ENABLE
.RXRDY_N(uartRXRDY_N),
`endif // RXRDY_ENABLE
`ifdef TXRDY_ENABLE
.TXRDY_N(uartTXRDY_N),
`endif // TXRDY_ENABLE
`ifdef MODEM
.DCD_N(uartDCD_N),
`endif // MODEM
`ifdef MODEM
.CTS_N(uartCTS_N),
`endif // MODEM
`ifdef MODEM
.DSR_N(uartDSR_N),
`endif // MODEM
`ifdef MODEM
.RI_N(uartRI_N),
`endif // MODEM
`ifdef MODEM
.DTR_N(uartDTR_N),
`endif // MODEM
`ifdef MODEM
.RTS_N(uartRTS_N),
`endif // MODEM
.INTR(uartINTR),
.CLK(clk_i), .RESET(reset_i));
assign timerS_en = ( SHAREDBUS_ADR_I[31:7] == 25'b1000000000000000000000001);
timer 
#(
.PERIOD_NUM(32'h14),
.PERIOD_WIDTH(32'h20),
.WRITEABLE_PERIOD(1),
.READABLE_SNAPSHOT(1),
.START_STOP_CONTROL(1),
.WATCHDOG(0))
 timer( 
.S_ADR_I(SHAREDBUS_ADR_I),
.S_DAT_I(SHAREDBUS_DAT_I),
.S_DAT_O(timerS_DAT_O),
.S_SEL_I(SHAREDBUS_SEL_I),
.S_WE_I(SHAREDBUS_WE_I),
.S_ACK_O(timerS_ACK_O),
.S_ERR_O(timerS_ERR_O),
.S_RTY_O(timerS_RTY_O),
.S_CTI_I(SHAREDBUS_CTI_I),
.S_BTE_I(SHAREDBUS_BTE_I),
.S_LOCK_I(SHAREDBUS_LOCK_I),
.S_CYC_I(SHAREDBUS_CYC_I & timerS_en),
.S_STB_I(SHAREDBUS_STB_I & timerS_en),
.S_INT_O(timerS_INT_O),
.CLK_I (clk_i), .RST_I (reset_i));
assign LEDGPIO_en = ( SHAREDBUS_ADR_I[31:7] == 25'b1000000000000000000000010);
gpio 
#(
.OUTPUT_PORTS_ONLY(1),
.INPUT_PORTS_ONLY(0),
.TRISTATE_PORTS(0),
.BOTH_INPUT_AND_OUTPUT(0),
.DATA_WIDTH(32'h8),
.INPUT_WIDTH(32'h1),
.OUTPUT_WIDTH(32'h1),
.IRQ_MODE(0),
.LEVEL(0),
.EDGE(1),
.EITHER_EDGE_IRQ(0),
.POSE_EDGE_IRQ(1),
.NEGE_EDGE_IRQ(0))
 LED( 
.GPIO_ADR_I(SHAREDBUS_ADR_I),
.GPIO_DAT_I(SHAREDBUS_DAT_I),
.GPIO_DAT_O(LEDGPIO_DAT_O),
.GPIO_SEL_I(SHAREDBUS_SEL_I),
.GPIO_WE_I(SHAREDBUS_WE_I),
.GPIO_ACK_O(LEDGPIO_ACK_O),
.GPIO_ERR_O(LEDGPIO_ERR_O),
.GPIO_RTY_O(LEDGPIO_RTY_O),
.GPIO_CTI_I(SHAREDBUS_CTI_I),
.GPIO_BTE_I(SHAREDBUS_BTE_I),
.GPIO_LOCK_I(SHAREDBUS_LOCK_I),
.GPIO_CYC_I(SHAREDBUS_CYC_I & LEDGPIO_en),
.GPIO_STB_I(SHAREDBUS_STB_I & LEDGPIO_en),
.PIO_IN(),
.PIO_BOTH_IN(),
.PIO_OUT(LEDPIO_OUT),
.PIO_BOTH_OUT(),
.PIO_IO(),
.IRQ_O(LEDIRQ_O),
.CLK_I(clk_i), .RST_I(reset_i));
assign gpio_7SegsGPIO_en = ( SHAREDBUS_ADR_I[31:7] == 25'b1000000000000000000000011);
gpio 
#(
.OUTPUT_PORTS_ONLY(1),
.INPUT_PORTS_ONLY(0),
.TRISTATE_PORTS(0),
.BOTH_INPUT_AND_OUTPUT(0),
.DATA_WIDTH(32'ha),
.INPUT_WIDTH(32'h1),
.OUTPUT_WIDTH(32'h1),
.IRQ_MODE(0),
.LEVEL(0),
.EDGE(1),
.EITHER_EDGE_IRQ(0),
.POSE_EDGE_IRQ(1),
.NEGE_EDGE_IRQ(0))
 gpio_7Segs( 
.GPIO_ADR_I(SHAREDBUS_ADR_I),
.GPIO_DAT_I(SHAREDBUS_DAT_I),
.GPIO_DAT_O(gpio_7SegsGPIO_DAT_O),
.GPIO_SEL_I(SHAREDBUS_SEL_I),
.GPIO_WE_I(SHAREDBUS_WE_I),
.GPIO_ACK_O(gpio_7SegsGPIO_ACK_O),
.GPIO_ERR_O(gpio_7SegsGPIO_ERR_O),
.GPIO_RTY_O(gpio_7SegsGPIO_RTY_O),
.GPIO_CTI_I(SHAREDBUS_CTI_I),
.GPIO_BTE_I(SHAREDBUS_BTE_I),
.GPIO_LOCK_I(SHAREDBUS_LOCK_I),
.GPIO_CYC_I(SHAREDBUS_CYC_I & gpio_7SegsGPIO_en),
.GPIO_STB_I(SHAREDBUS_STB_I & gpio_7SegsGPIO_en),
.PIO_IN(),
.PIO_BOTH_IN(),
.PIO_OUT(gpio_7SegsPIO_OUT),
.PIO_BOTH_OUT(),
.PIO_IO(),
.IRQ_O(gpio_7SegsIRQ_O),
.CLK_I(clk_i), .RST_I(reset_i));
assign LM32interrupt_n[0] = !uartINTR ;
assign LM32interrupt_n[1] = !timerS_INT_O ;
assign LM32interrupt_n[2] = 1;
assign LM32interrupt_n[3] = 1;
assign LM32interrupt_n[4] = 1;
assign LM32interrupt_n[5] = 1;
assign LM32interrupt_n[6] = 1;
assign LM32interrupt_n[7] = 1;
assign LM32interrupt_n[8] = 1;
assign LM32interrupt_n[9] = 1;
assign LM32interrupt_n[10] = 1;
assign LM32interrupt_n[11] = 1;
assign LM32interrupt_n[12] = 1;
assign LM32interrupt_n[13] = 1;
assign LM32interrupt_n[14] = 1;
assign LM32interrupt_n[15] = 1;
assign LM32interrupt_n[16] = 1;
assign LM32interrupt_n[17] = 1;
assign LM32interrupt_n[18] = 1;
assign LM32interrupt_n[19] = 1;
assign LM32interrupt_n[20] = 1;
assign LM32interrupt_n[21] = 1;
assign LM32interrupt_n[22] = 1;
assign LM32interrupt_n[23] = 1;
assign LM32interrupt_n[24] = 1;
assign LM32interrupt_n[25] = 1;
assign LM32interrupt_n[26] = 1;
assign LM32interrupt_n[27] = 1;
assign LM32interrupt_n[28] = 1;
assign LM32interrupt_n[29] = 1;
assign LM32interrupt_n[30] = 1;
assign LM32interrupt_n[31] = 1;
endmodule
