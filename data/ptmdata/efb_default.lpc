[Device] //device information
Family=machxo2
PartType=LCMXO2-7000HC
PartName=LCMXO2-7000HC-5TG144C
SpeedGrade=5
Package=TQFP144
OperatingCondition=COM
Status=S

[IP]
VendorName=Lattice Semiconductor Corporation
CoreType=LPM
CoreStatus=Demo
CoreName=EFB
CoreRevision=1.0
ModuleName=efb_test
SourceFormat=Verilog HDL
ParameterFileVersion=1.0
Date=03/22/2012
Time=09:57:06

[Parameters]
Verilog=1
VHDL=0
EDIF=1
Destination=Synplicity
Expression=BusA(0 to 7)
Order=Big Endian [MSB:LSB]
IO=0
freq=
i2c1=0       //1 means using i2c
i2c1config=0
i2c1_addr=7-Bit Addressing  //or 10-Bit Addressing,for POJO2 7-bit is enough
i2c1_ce=0   //not necessary for POJO2, Enables the generic call response in slave mode.
i2c1_freq=100  /i2c frequency.100 means 100K
i2c1_sa=10000 //slave address  //sometimes is reserved
i2c1_we=0     //not necessary for POJO2,wake up enable, for powercontroller
i2c2=0
i2c2_addr=7-Bit Addressing
i2c2_ce=0
i2c2_freq=100
i2c2_sa=10000
i2c2_we=0
ufm_addr=7-Bit Addressing
ufm_sa=10000
pll=0
pll_cnt=1
spi=0         //1 means using spi
spi_clkinv=0  //not necessary,1 means invert clock
spi_cs=1      //not necessary,master chip select
spi_en=0   //o means interrupt output enable
spi_freq=1  //master desire frequency
spi_lsb=0    //spi msb or lsb,for POJO2 MSB
spi_mode=Slave //for POJO2 ususlly use Both, actually it is master
spi_ib=0
spi_ph=0   //not necessary, 1 means phase adjust
spi_hs=0   //not necessary,spi slave hand shake
spi_rxo=0  //rx overrun interrupt
spi_rxr=0  //rx ready interrupt
spi_txo=0  //tx overrun interrupt
spi_txr=0  //tx ready interrupt
spi_we=0 //not necessary for power controller
static_tc=Static //wishbone timer(Dynamic) or static timer, static is OK
tc=0  //using timer or not,should be 1
tc_clkinv=PCLOCK //posedge clock from PAD,enough for POJO2
tc_ctr=1 //set top counter value,yes, this is must
tc_div=1 //divider 0,1,8,64,256,1024
tc_ipcap=0
tc_mode=CTCM //using CTCM is OK
tc_ocr=32767 //compare value
tc_oflow=0 
tc_o=TOGGLE //here are four output model, differnt on tc_oc, same at tc_int,using tc_int is enough
tc_opcomp=0
tc_osc=0  //not necessary,on chip oscillator
tc_sa_oflow=1 //stand alone over flow should be 1
tc_top=65535 //timer top
ufm=0 //using UFM
ufm0=0
ufm1=0
ufm2=0
ufm3=0
ufm_cfg0=0
ufm_cfg1=0
wb_clk_freq=40 //frequency
ufm_usage=SHARED_EBR_TAG
ufm_ebr=
ufm_remain=
mem_size=1 //page number,one page is 128bit
ufm_start=
ufm_init=0 //all zero mem or using file
memfile=  //position
ufm_dt=hex //hex or binary
ufm0_ebr=
mem_size0=1
ufm0_init=0
memfile0=
ufm0_dt=hex
ufm1_ebr=
mem_size1=1
ufm1_init=0
memfile1=
ufm1_dt=hex
ufm2_ebr=
mem_size2=1
ufm2_init=0
memfile2=
ufm2_dt=hex
ufm3_ebr=
mem_size3=1
ufm3_init=0
memfile3=
ufm3_dt=hex
ufm_cfg0_ebr=
mem_size_cfg0=1
ufm_cfg0_init=0
memfile_cfg0=
ufm_cfg0_dt=hex
ufm_cfg1_ebr=
mem_size_cfg1=1
ufm_cfg1_init=0
memfile_cfg1=
ufm_cfg1_dt=hex
wb=1
boot_option=Internal
efb_ufm=0
boot_option_internal=Single Boot
internal_ufm0=0
internal_ufm1=0
efb_ufm_boot=
tamperdr=0
t_pwd=0
t_lockflash=0
t_manmode=0
t_jtagport=0
t_sspiport=0
t_sic2port=0
t_wbport=0
t_portlock=0
