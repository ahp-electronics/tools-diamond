<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE		SVF_Plus	SYSTEM	"SVF_Plus.dtd" >
<!--   comments
	egz, 06/30/2019, created.
-->
<SVF_Plus version="1.0">
<Header>
	<Device name="DEVICE_NAME"/>
</Header>
<Setup> <!-- use default Header, Trailer and Frequency value -->
	<Interface protocol="JTAG_1149.1"/>
</Setup>
<Parameter>
	<Instruction_Length value="INSTRUCTION_REGISTER_LENGTH"/> 
	<Row_Width			value="DEVICE_ROW_WIDTH"/> 
	<Address_Length		value="ADDRESS_REGISTER_LENGTH"/> 
	<Address length="ADDRESS_LENGTH">
		INI_ADDRESS			
	</Address>
	<ID_Length 			value="DEVICE_ID_LENGTH"/>
	<Usercode_Length 	value="DEVICE_USERCODE_LENGTH"/>
	<BSCAN_Length value="BSCAN_REGISTER_LENGTH"/> 
	<Bscan length="BSCAN_LENGTH">
		BSCAN_DATA
	</Bscan>
	<BscanMask length="BSCAN_LENGTH">
		BSCAN_MASK
	</BscanMask>
	<TotalFuse value="TOTAL_FUSE_MAP"/>
	<PWP	value="PROGRAMING_PULSE_WIDTH"/>
	<PWV	value="VERIFY_PULSE_WIDTH"/>
	<PWE	value="ERASE_PULSE_WIDTH"/>
	<SkipRow value="1"/>
	<MDRDelay value="MDR_DELAY"/>
	<Instruction>
		EXTEST	 			= 0x15;
		EXTEST_PULSE        = 0x2D;
		EXTEST_TRAIN        = 0x2E;
		INTEST              = 0x2C;
		CLAMP               = 0x78;
		HIGHZ               = 0x18;
		LSC_PRELOAD         = 0x1C;
		LSC_SAMPLE          = 0x1C;
		BYPASS              = 0xFF;
		VERIFY_ID			= 0xE2;
		IDCODE_PUB          = 0xE0;
		LSC_UIDCODE_PUB     = 0x19;
		USERCODE            = 0xC0;
		LSC_READ_TEMP       = 0xE8;
		LSC_DEVICE_CTRL     = 0x7D;
		LSC_READ_STATUS0     = 0x3C;
		LSC_READ_STATUS1     = 0x3D;
		LSC_CHECK_BUSY      = 0xF0;
		LSC_REFRESH         = 0x79;
		LSC_I2CI_CRBR_WT    = 0x9C;
		LSC_I2CI_TXDR_WT    = 0x9D;
		LSC_I2CI_RXDR_RD    = 0x9E;
		LSC_I2CI_SR_RD      = 0x9F;
		LSC_IP_A            = 0x32;
		LSC_IP_B            = 0x38;
		LSC_IPTEST_A        = 0x33;
		LSC_IPTEST_B        = 0x39;
		LSC_PROG_SPI        = 0x3A;
		LSC_PROG_SPI1       = 0x3E;
		LSC_IDCODE_PRV      = 0x16;
		LSC_READ_PES        = 0x11;
		LSC_MANUFACTURE_SHIFT = 0x90;
		ISC_ENABLE          = 0xC6;
		LSC_ENABLE_X        = 0x74;
		ISC_DISABLE         = 0x26;
		ISC_PROGRAM         = 0x67;
		ISC_NOOP            = 0x30;
		ISC_PROGRAM_USERCODE = 0xC2;
		ISC_READ            = 0x80;
		ISC_ERASE           = 0x0E;
		ISC_DISCHARGE       = 0x14;
		ISC_PROGRAM_DONE    = 0x5E;
		ISC_ERASE_DONE      = 0x24;
		ISC_PROGRAM_SECURITY = 0xCE;
		LSC_PROGRAM_SECPLUS = 0xCF;
		ISC_DATA_SHIFT      = 0x05;
		ISC_ADDRESS_SHIFT   = 0x42;
		LSC_INIT_ADDRESS    = 0x46;
		LSC_WRITE_ADDRESS   = 0xB4;
		LSC_PROG_INCR_RTI   = 0x82;
		LSC_PROG_INCR_ENC   = 0xB6;
		LSC_PROG_INCR_CMP   = 0xB8;
		LSC_PROG_INCR_CNE   = 0xBA;
		LSC_READ_INCR 	    = 0x6A;
		LSC_PROG_CTRL0      = 0x22;
		LSC_READ_CTRL0      = 0x20;
		LSC_PROG_CTRL1      = 0x23;
		LSC_READ_CTRL1      = 0x21;
		LSC_PROG_NV_CR1      = 0x21;
		LSC_RESET_CRC       = 0x3B;
		LSC_READ_CRC        = 0x60;
		LSC_PROG_SED_CRC    = 0xA2;
		LSC_READ_SED_CRC    = 0xA4;
		LSC_SHIFT_PASSWORD  = 0xBC;
		LSC_PROG_PASSWORD   = 0xF1;
		LSC_READ_PASSWORD   = 0xF2;
		LSC_PROG_CIPHER_KEY = 0xF3;
		LSC_READ_CIPHER_KEY = 0xF4;
		LSC_PROG_FEATURE    = 0xE4;          
		LSC_READ_FEATURE    = 0xE7;      
		LSC_PROG_FEABITS    = 0xF8;
		LSC_READ_FEABITS    = 0xFB;
		LSC_PROG_OTP        = 0xF9;
		LSC_READ_OTP        = 0xFA;
		LSC_WRITE_COMP_DIC  = 0x02;
		LSC_WRITE_BUS_ADDR  = 0xF6;
		LSC_PCS_WRITE       = 0x72;
		LSC_PCS_READ        = 0xF7;
		LSC_EBR_WRITE       = 0xB2;
		LSC_EBR_READ        = 0xB0;
		LSC_PROG_INCR_NV    = 0x70;
		LSC_READ_INCR_NV    = 0x73;
		LSC_INIT_ADDR_UFM   = 0x47;
		LSC_READ_TAG        = 0xCA;
		LSC_ERASE_UFM       = 0xCB;
		LSC_PROG_UFM        = 0xC9;
		LSC_READ_UFM        = 0xCA;
		LSC_STORE           = 0xD0;
		LSC_BITSTREAM_BURST = 0x7A;
		LSC_PROG_PES        = 0xD0;
		LSC_PROG_MES        = 0xD1;
		LSC_PROG_MAIN_RED   = 0xD3;
		LSC_PROG_MAIN_RCR   = 0xD4;
		LSC_PROG_MAIN_RMR   = 0xD5;
		LSC_PROG_NV_RED     = 0xD6;
		LSC_PROG_NV_RMR     = 0xD7;
		LSC_READ_MES        = 0xD8; 
		LSC_READ_TRIM       = 0xD1;
		LSC_PROG_TRIM       = 0xD1;
		LSC_READ_MAIN_RED   = 0xDA;
		LSC_READ_MAIN_RCR   = 0xDC;
		LSC_READ_MAIN_RMR   = 0xDC;
		LSC_READ_NV_RED     = 0xDD;
		LSC_READ_NV_RMR     = 0xDE;
		LSC_MFG_MTEST       = 0x96;
		LSC_MFG_MTRIM       = 0x69;
		LSC_MFG_MDATA       = 0x8F;
		LSC_ISCAN           = 0xDF;	
		LSC_SPI_CTRL		= 0xD9;
		LSC_PASSIVE_CMD		= 0xD1;
		LSC_PASSIVE_READ	= 0xD2;
		LSC_READ_MFG_STATUS	= 0x3A;
		LSC_PROG_CTRL		= 0xD6;
		LSC_FLASH_CTRL		= 0x7F;
		LSC_FLASH_REGWT		= 0x3E;
		LSC_FLASH_REGRD		= 0x3F;
	</Instruction>
</Parameter>
<Data>
	<DataField	name="IDTDI">
		<FieldBlock	row_width="DEVICE_ID_LENGTH">
			ID_DATA
		</FieldBlock>
	</DataField>	
</Data>
<Operation_List>
	"Bypass" = "INIT 	! Initialize"	;
			
	"Slave SPI Disable Only" = "SPIINIT 	! Initialize, 
	 			 				SPIDISABLE ! Exit the programming mode"	;
								
	"Slave SPI Enable Only" = "SPIINIT_DIRECT 	! Initialize, 
						   	   SPIREAD_ID	! Check the IDCODE,
						  	   SPISRAM_ENABLE	! Enable PROGRAM mode"	;	
							   
	"Slave SPI Re-Initialize" = "SPIINIT_DIRECT 	! Initialize,  
							 SPIREAD_ID	! Check the IDCODE,
						  	 SPISRAM_ENABLE	! Enable programming mode, 
							 SPISRAM_ERASE	! Erase the device, 
							 SPIDISABLE ! Exit the programming mode"	;								 									

	"Slave SPI SRAM Fast Configuration" = "SPIINIT_DIRECT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,								 
										SPISRAM_ENABLE	! Enable programming mode,
										SPICHECK_PASSWORD ! Check the Password,  
										SPICHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
										SPISRAM_ERASE	! Erase the device, 
										SPIBURST_PROGRAM	! Program Fuse Map,
										SPISRAM_VERIFY_USERCODE		! Verify USERCODE,
										SPIDISABLE ! Exit the programming mode"	;			
	
	"Slave SPI SRAM Erase,Program,Verify" ="SPIINIT_DIRECT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPISRAM_ENABLE	! Enable the SRAM,
									SPICHECK_PASSWORD ! Check the Password,
									SPICHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
									SPISRAM_ERASE	! Erase the device,
									SPIPROGRAM_CONTROL0	! Program Control Register0,
									SPIPROGRAM_CONTROL1	! Program Control Register1,
				 			 		SPISRAM_PROGRAM	! Program SRAM,
									SPISRAM_VERIFY	! Verify CFG,									
									SPISRAM_PROGRAM_USERCODE	! Program USERCODE,
									SPIVERIFY_USERCODE		! Verify USERCODE,																		
									SPISRAMPROGRAM_DONE_BIT	! Program DONE bit,	
				 			 		SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI SRAM Verify Only" = 		"SPIINIT 	! Initialize, 
							SPIREAD_ID	! Check the IDCODE, 
							SPISRAM_ENABLE	! Enable the SRAM,
							SPICHECK_PASSWORD ! Check the Password,  
							SPICHECK_SRAM_READ_LOCK ! Check the SRAM Read Lock, 
							SPIVERIFY_CONTROL0 ! Verify Control Register0,
							SPIVERIFY_CONTROL1 ! Verify Control Register1,
							SPISRAM_VERIFY	! Verify the SRAM, 
							SPIVERIFY_USERCODE	! Verify USERCODE, 							
							SPIDISABLE ! Exit the programming mode";
										 			 					 			 														
	"Slave SPI SRAM Erase Only"	="SPIINIT_DIRECT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE,
								SPISRAM_ENABLE	! Enable programming mode,
								SPICHECK_PASSWORD ! Check the Password,  
								SPICHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
								SPISRAM_ERASE	! Erase the device, 
								SPIDISABLE ! Exit the programming mode"	;	
	
	"Slave SPI SRAM Verify ID" = 	"SPIINIT_DIRECT 	! Initialize, 
						 			SPIREAD_ID ! Check the IDCODE"; 

	"Slave SPI SRAM Display ID" = "SPIINIT_DIRECT, SPIREAD_ID, SPISAVE_ID";

	"Slave SPI SRAM Program Control Register0" = "SPIINIT_DIRECT ! Initialize,
								 SPIREAD_ID	! Check the IDCODE,
								 SPISRAM_ENABLE	! Enable SRAM programming mode, 
					             SPICHECK_PASSWORD ! Check the Password, 
 								 SPICHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
								 SPIPROGRAM_CONTROL0 ! Program Control Register 0,
					             SPIDISABLE";	

	"Slave SPI SRAM Display Control Register0" = "SPIINIT ! Initialize,
								 SPIREAD_ID	! Check the IDCODE,
								 SPISAVE_ID,
								 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								 SPICHECK_PASSWORD ! Check the Password,
					 			 SPISAVE_CONTROL0 !Read Control Register 0,
					             SPIDISABLE";	

	"Slave SPI SRAM Program Control Register1" = "SPIINIT_DIRECT ! Initialize,
								 SPIREAD_ID	! Check the IDCODE,
					 			 SPISRAM_ENABLE	! Enable SRAM programming mode, 
					             SPICHECK_PASSWORD ! Check the Password,  
					             SPICHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
					 			 SPISRAM_PROGRAM_CONTROL1 ! Program Control Register 1,
					             SPIDISABLE";

	"Slave SPI SRAM Display Control Register1" = "SPIINIT ! Initialize,
								 SPIREAD_ID	! Check the IDCODE,
								 SPISAVE_ID,
								 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								 SPICHECK_PASSWORD ! Check the Password,
					 			 SPISAVE_CONTROL1 !Read Control Register 1,
					             SPIDISABLE";	

	"Slave SPI SRAM Verify USERCODE"	=	"SPIINIT 	! Initialize, 
											 SPIREAD_ID	! Check the IDCODE,
											 SPISRAM_TRANSPARENT_READ_ENABLE,
											 SPIVERIFY_USERCODE		! Verify USERCODE,
											 SPIDISABLE"; 
								
	"Slave SPI SRAM Display USERCODE"	=	"SPIINIT, 
											 SPIREAD_ID, 
											 SPISAVE_ID,
											 SPISRAM_TRANSPARENT_READ_ENABLE,
											 SPISAVE_USERCODE,
											 SPIDISABLE";								
								
	"Slave SPI SRAM Read and Save"	=	"SPIINIT, 
										 SPIREAD_ID, 
										 SPISAVE_ID, 
										 SPISRAM_TRANSPARENT_READ_ENABLE, 
										 SPICHECK_PASSWORD ! Check the Password,
										 SPICHECK_SRAM_READ_LOCK ! Check the SRAM Read Lock, 
										 SPISAVE_CONTROL0,
										 SPISRAM_SAVE_ARRAY, 
										 SPISAVE_USERCODE, 
										 SPIDISABLE";								
								
	"Slave SPI SRAM Read Status Register" = "SPIINIT ! Initialize,
								 			 SPIREAD_ID	! Check the IDCODE,
								 			 SPISAVE_ID, 
								 			 SPISRAM_ENABLE	! Enable SRAM programming mode, 
								 			 SPISAVE_STATUS,
								 			 SPIDISABLE";									
								
	"Slave SPI SRAM Refresh" = "SPIINIT_DIRECT !Initialize,
								SPIREAD_ID !Check the IDCODE,
								SPIREFRESH_FUNCTION ! Refresh";								
	
	"Slave SPI SRAM Secure Plus" = "SPIINIT_DIRECT !Initialize,
							SPIREAD_ID !Check the IDCODE,
							SPISRAM_ENABLE	! Enable SRAM programming mode, 								             
							SPICHECK_PASSWORD ! Check the Password,  
							SPICHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
							SPISRAM_SECURE ! Secure the SRAM,
							SPIDISABLE";
														
	"Slave SPI SRAM Bypass"	=	"INIT";						

	"I2C SRAM Fast Configuration" = "	I2CINIT_DIRECT 	! Initialize,   
										I2CREAD_ID	! Check the IDCODE,
										I2CSRAM_ENABLE	! Enable SRAM programming mode, 
										I2CCHECK_PASSWORD ! Check the Password,  
										I2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
										I2CSRAM_ERASE	! Erase the SRAM, 
										I2CBURST_PROGRAM	! Program Fuse Map,
										I2CSRAM_VERIFY_USERCODE		! Verify USERCODE,
										I2CDISABLE ! Exit the programming mode"	;
										
	"I2C SRAM Erase,Program,Verify" = "	I2CINIT_DIRECT 	! Initialize,   
										I2CREAD_ID	! Check the IDCODE,
										I2CSRAM_ENABLE	! Enable SRAM programming mode, 
										I2CCHECK_PASSWORD ! Check the Password,  
										I2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
										I2CSRAM_ERASE	! Erase the SRAM, 
										I2CPROGRAM_CONTROL0	! Program Control Register0,
										I2CPROGRAM_CONTROL1	! Program Control Register1,
										I2CSRAM_PROGRAM	! Program Fuse Map,
										I2CSRAM_PROGRAM_USERCODE	! Program USERCODE,
										I2CCHECK_SRAM_READ_LOCK ! Check the SRAM read Lock,
										I2CSRAM_VERIFY	! Verify Fuse Map, 
										I2CVERIFY_USERCODE		! Verify USERCODE,
										I2CSRAMPROGRAM_DONE_BIT	! Program DONE bit,
										I2CDISABLE ! Exit the programming mode"	;	
										
	"I2C SRAM Verify Only"	=	"	I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,  
							I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
							I2CCHECK_PASSWORD ! Check the Password,  
							I2CCHECK_SRAM_READ_LOCK ! Check the SRAM Read Lock,
							I2CVERIFY_CONTROL0	! Verify Control Register0,
							I2CVERIFY_CONTROL1	! Verify Control Register1,
							I2CSRAM_VERIFY	! Verify Fuse Map, 
							I2CVERIFY_USERCODE		! Verify USERCODE, 
		 			 		I2CDISABLE ! Exit the programming mode"	;
							
	"I2C SRAM Erase Only"	=	"	I2CINIT_DIRECT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,
							I2CSRAM_ENABLE	! Enable SRAM programming mode, 
							I2CCHECK_PASSWORD ! Check the Password, 
							I2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
							I2CSRAM_ERASE	! Erase the SRAM, 
		 			 		I2CDISABLE ! Exit the programming mode"	;

	"I2C SRAM Verify ID" = 	"I2CINIT 	! Initialize, 
						 	 I2CREAD_ID ! Check the IDCODE"; 

	"I2C SRAM Display ID" = "I2CINIT, I2CREAD_ID, I2CSAVE_ID";

	"I2C SRAM Program Control Register0" = "I2CINIT_DIRECT ! Initialize,
								 I2CREAD_ID	! Check the IDCODE,
					 			 I2CSRAM_ENABLE	! Enable SRAM programming mode, 
					             I2CCHECK_PASSWORD ! Check the Password,  
					             I2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
								 I2CPROGRAM_CONTROL0 ! Program Control Register 0,
					             I2CDISABLE";	

	"I2C SRAM Display Control Register0" = "I2CINIT ! Initialize,
								 I2CREAD_ID	! Check the IDCODE,
								 I2CSAVE_ID,
								 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode,  
								 I2CCHECK_PASSWORD ! Check the Password, 
					 			 I2CSAVE_CONTROL0 !Read Control Register 0,
					             I2CDISABLE";	

	"I2C SRAM Program Control Register1" = "I2CINIT_DIRECT ! Initialize,
								 I2CREAD_ID	! Check the IDCODE,
					 			 I2CSRAM_ENABLE	! Enable SRAM programming mode, 
					             I2CCHECK_PASSWORD ! Check the Password, 
					             I2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
								 I2CSRAM_PROGRAM_CONTROL1 ! Program Control Register 1,
					             I2CDISABLE";

	"I2C SRAM Display Control Register1" = "I2CINIT ! Initialize,
								 I2CREAD_ID	! Check the IDCODE,
								 I2CSAVE_ID,
								 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								 I2CCHECK_PASSWORD ! Check the Password, 
					 			 I2CSAVE_CONTROL1 !Read Control Register 1,
					             I2CDISABLE";	

	"I2C SRAM Verify USERCODE"	=	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE,
									I2CSRAM_TRANSPARENT_READ_ENABLE,
									I2CVERIFY_USERCODE		! Verify USERCODE,
									I2CDISABLE"	; 
								
	"I2C SRAM Display USERCODE"	=	"I2CINIT, 
									 I2CREAD_ID, 
									 I2CSAVE_ID,
									 I2CSRAM_TRANSPARENT_READ_ENABLE,
									 I2CSAVE_USERCODE,
									 I2CDISABLE";								
								
	"I2C SRAM Read and Save"	=	"I2CINIT, 
									 I2CREAD_ID, 
									 I2CSAVE_ID, 
									 I2CSRAM_TRANSPARENT_READ_ENABLE, 
									 I2CCHECK_PASSWORD ! Check the Password, 
									 I2CCHECK_SRAM_READ_LOCK ! Check the SRAM Read Lock,  
									 I2CSAVE_CONTROL0,
									 I2CSRAM_SAVE_ARRAY, 
									 I2CSAVE_USERCODE, 
									 I2CDISABLE";								
								
	"I2C SRAM Read Status Register" = "I2CINIT ! Initialize,
					 			 		I2CREAD_ID	! Check the IDCODE,
					 			 		I2CSAVE_ID,
					 			 		I2CSAVE_STATUS";									
								
	"I2C SRAM Refresh" = " 	I2CINIT_DIRECT !Initialize,
							I2CREAD_ID !Check the IDCODE,
							I2CREFRESH_FUNCTION ! Refresh";								
	
	
	"I2C SRAM Secure Plus" = "I2CINIT_DIRECT !Initialize,
						I2CREAD_ID !Check the IDCODE,
						I2CSRAM_ENABLE	! Enable SRAM programming mode, 								             
						I2CCHECK_PASSWORD ! Check the Password,  
						I2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
						I2CSRAM_SECURE ! Secure the SRAM,
						I2CDISABLE";
														
	"I2C SRAM Bypass"	=	"INIT";
	
	"JTAGI2C SRAM Fast Configuration" = "JTAGI2CINIT_DIRECT 	! Initialize,   
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
										JTAGI2CCHECK_PASSWORD ! Check the Password,  
										JTAGI2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
										JTAGI2CSRAM_ERASE	! Erase the SRAM, 
										JTAGI2CBURST_PROGRAM	! Program Fuse Map,
										JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
										JTAGI2CDISABLE ! Exit the programming mode"	;
										
	"JTAGI2C SRAM Erase,Program,Verify" = "NOT_SUPPORTED"	;	
										
	"JTAGI2C SRAM Verify Only"	=	"NOT_SUPPORTED"	;
							
	"JTAGI2C SRAM Erase Only"	=	"	JTAGI2CINIT_DIRECT 	! Initialize, 
							JTAGI2CREAD_ID	! Check the IDCODE,
							JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
							JTAGI2CCHECK_PASSWORD ! Check the Password, 
							JTAGI2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
							JTAGI2CSRAM_ERASE	! Erase the SRAM, 
		 			 		JTAGI2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C SRAM Verify ID" = 	"JTAGI2CINIT 	! Initialize, 
						 		 JTAGI2CREAD_ID ! Check the IDCODE"; 

	"JTAGI2C SRAM Display ID" = "JTAGI2CINIT, JTAGI2CREAD_ID, JTAGI2CSAVE_ID";

	"JTAGI2C SRAM Program Control Register0" = "JTAGI2CINIT_DIRECT ! Initialize,
								 JTAGI2CREAD_ID	! Check the IDCODE,
					 			 JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
					             JTAGI2CCHECK_PASSWORD ! Check the Password,  
					             JTAGI2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
								 JTAGI2CPROGRAM_CONTROL0 ! Program Control Register 0,
					             JTAGI2CDISABLE";	

	"JTAGI2C SRAM Display Control Register0" = "JTAGI2CINIT ! Initialize,
								 JTAGI2CREAD_ID	! Check the IDCODE,
								 JTAGI2CSAVE_ID,
								 JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode,
								 JTAGI2CCHECK_PASSWORD ! Check the Password,  
					 			 JTAGI2CSAVE_CONTROL0 !Read Control Register 0,
					             JTAGI2CDISABLE";	

	"JTAGI2C SRAM Program Control Register1" = "JTAGI2CINIT_DIRECT ! Initialize,
								 JTAGI2CREAD_ID	! Check the IDCODE,
					 			 JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
					             JTAGI2CCHECK_PASSWORD ! Check the Password, 
					             JTAGI2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
								 JTAGI2CSRAM_PROGRAM_CONTROL1 ! Program Control Register 1,
					             JTAGI2CDISABLE";

	"JTAGI2C SRAM Display Control Register1" = "JTAGI2CINIT ! Initialize,
								 JTAGI2CREAD_ID	! Check the IDCODE,
								 JTAGI2CSAVE_ID,
								 JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
								 JTAGI2CCHECK_PASSWORD ! Check the Password, 
								 JTAGI2CSAVE_CONTROL1 !Read Control Register 1,
					             JTAGI2CDISABLE";	

	"JTAGI2C SRAM Verify USERCODE"	=	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CSRAM_ENABLE,
									JTAGI2CSRAM_VERIFY_USERCODE		! Verify USERCODE,
									JTAGI2CDISABLE"	; 
								
	"JTAGI2C SRAM Display USERCODE"	=	"JTAGI2CINIT, 
									 JTAGI2CREAD_ID, 
									 JTAGI2CSAVE_ID,
									 JTAGI2CSRAM_ENABLE,
									 JTAGI2CSAVE_USERCODE,
									 JTAGI2CDISABLE";								
								
	"JTAGI2C SRAM Read and Save"	=	"NOT_SUPPORTED";								
								
	"JTAGI2C SRAM Read Status Register" = "JTAGI2CINIT ! Initialize,
					 			 		JTAGI2CREAD_ID	! Check the IDCODE,
					 			 		JTAGI2CSAVE_ID,
					 			 		JTAGI2CSAVE_STATUS";									
								
	"JTAGI2C SRAM Refresh" = " 	JTAGI2CINIT !Initialize,
							JTAGI2CREAD_ID !Check the IDCODE,
							JTAGI2CREFRESH_FUNCTION ! Refresh";								
	
	
	"JTAGI2C SRAM Secure Plus" = "JTAGI2CINIT_DIRECT !Initialize,
						JTAGI2CREAD_ID !Check the IDCODE,
						JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 								             
						JTAGI2CCHECK_PASSWORD ! Check the Password,  
						JTAGI2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
						JTAGI2CSRAM_SECURE ! Secure the SRAM,
						JTAGI2CDISABLE";
														
	"JTAGI2C SRAM Bypass"	=	"INIT";	
	
	"Slave SPI XSRAM SEI Fast Program" 	= "	SPIINIT 	! Initialize,   
									SPIREAD_ID	! Check the IDCODE,
									SPISRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									SPICHECK_PASSWORD ! Check the Password,  
								 	SPICHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
									SPIBURST_PROGRAM	! Program Fuse Map,
									SPIDISABLE ! Exit the programming mode"	;


	"Slave SPI XSRAM Verify ID" = 	"	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE"	; 


	"Slave SPI XSRAM Display ID" = "SPIINIT, SPIREAD_ID, SPISAVE_ID";	

	"Slave SPI XSRAM Display Control Register0" = "SPIINIT ! Initialize,
												 SPIREAD_ID	! Check the IDCODE,
												 SPISAVE_ID,
												 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
												 SPICHECK_PASSWORD ! Check the Password,  
									 			 SPISAVE_CONTROL0 ! Read Control Register 0,
									             SPIDISABLE";	

	"Slave SPI XSRAM Display Control Register1" = "SPIINIT ! Initialize,
												 SPIREAD_ID	! Check the IDCODE,
												 SPISAVE_ID,
												 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
												 SPICHECK_PASSWORD ! Check the Password,  
									 			 SPISAVE_CONTROL1 ! Read Control Register 1,
									             SPIDISABLE";		

	"Slave SPI XSRAM Read and Save"	=	"SPIINIT, 
										 SPIREAD_ID, 
										 SPISAVE_ID, 
										 SPISRAM_TRANSPARENT_READ_ENABLE, 
										 SPICHECK_PASSWORD ! Check the Password,  
										 SPICHECK_SRAM_READ_LOCK ! Check the SRAM Read Lock,  
										 SPISAVE_CONTROL0,
										 SPISRAM_SAVE_ARRAY, 
										 SPISAVE_USERCODE, 
										 SPIDISABLE";			
	
	"Slave SPI XSRAM Display USERCODE"	=	"SPIINIT, 
											 SPIREAD_ID, 
											 SPISAVE_ID,
											 SPISRAM_TRANSPARENT_READ_ENABLE,
											 SPISAVE_USERCODE,
											 SPIDISABLE";
		
	"Slave SPI XSRAM Read Status Register" = "SPIINIT ! Initialize,
								 			 SPIREAD_ID	! Check the IDCODE,
								 			 SPISAVE_ID,
								 			 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,
								 			 SPISAVE_STATUS,
								 			 SPIDISABLE ! Exit the programming mode";	

	"Slave SPI XSRAM Refresh" = "	SPIINIT 	! Initialize,   
									SPIREAD_ID	! Check the IDCODE,
									SPIREFRESH_FUNCTION ! Refresh" ;

	"Slave SPI XSRAM Bypass"	=	"INIT"	;
	
	"I2C XSRAM SEI Fast Program" 	= "	I2CINIT 	! Initialize,   
									I2CREAD_ID	! Check the IDCODE,
									I2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									I2CCHECK_PASSWORD ! Check the Password,  
								 	I2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
									I2CBURST_PROGRAM	! Program Fuse Map,
									I2CDISABLE ! Exit the programming mode"	;


	"I2C XSRAM Verify ID" = 	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE"	; 


	"I2C XSRAM Display ID" = "I2CINIT, I2CREAD_ID, I2CSAVE_ID";	

	"I2C XSRAM Display Control Register0" = "I2CINIT ! Initialize,
											 I2CREAD_ID	! Check the IDCODE,
											 I2CSAVE_ID,
											 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode,
											 I2CCHECK_PASSWORD ! Check the Password,   
								 			 I2CSAVE_CONTROL0 ! Read Control Register 0,
								             I2CDISABLE";	

	"I2C XSRAM Display Control Register1" = "I2CINIT ! Initialize,
											 I2CREAD_ID	! Check the IDCODE,
											 I2CSAVE_ID,
											 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
											 I2CCHECK_PASSWORD ! Check the Password,  
								 			 I2CSAVE_CONTROL1 ! Read Control Register 1,
								             I2CDISABLE";		

	"I2C XSRAM Read and Save"	=	"I2CINIT, 
									 I2CREAD_ID, 
									 I2CSAVE_ID, 
									 I2CSRAM_TRANSPARENT_READ_ENABLE, 
									 I2CCHECK_PASSWORD ! Check the Password,  
									 I2CCHECK_SRAM_READ_LOCK ! Check the SRAM Read Lock, 
									 I2CSAVE_CONTROL0,
									 I2CSRAM_SAVE_ARRAY, 
									 I2CSAVE_USERCODE, 
									 I2CDISABLE";			
	
	"I2C XSRAM Display USERCODE"	=	"I2CINIT, 
										I2CREAD_ID, 
										I2CSAVE_ID,
										I2CSRAM_TRANSPARENT_READ_ENABLE,
										I2CSAVE_USERCODE,
										I2CDISABLE";
		
	"I2C XSRAM Read Status Register" = "I2CINIT ! Initialize,
							 			 I2CREAD_ID	! Check the IDCODE,
							 			 I2CSAVE_ID,
							 			 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,
							 			 I2CSAVE_STATUS,
							 			 I2CDISABLE ! Exit the programming mode";	

	"I2C XSRAM Refresh" = "	I2CINIT 	! Initialize,   
							I2CREAD_ID	! Check the IDCODE,
							I2CREFRESH_FUNCTION ! Refresh" ;

	"I2C XSRAM Bypass"	=	"INIT"	;

	"JTAGI2C XSRAM SEI Fast Program" 	= "	JTAGI2CINIT 	! Initialize,   
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									JTAGI2CCHECK_PASSWORD ! Check the Password,  
								 	JTAGI2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
									JTAGI2CBURST_PROGRAM	! Program Fuse Map,
									JTAGI2CDISABLE ! Exit the programming mode"	;


	"JTAGI2C XSRAM Verify ID" = 	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE"	; 


	"JTAGI2C XSRAM Display ID" = "JTAGI2CINIT, JTAGI2CREAD_ID, JTAGI2CSAVE_ID";	

	"JTAGI2C XSRAM Display Control Register0" = "JTAGI2CINIT ! Initialize,
											 JTAGI2CREAD_ID	! Check the IDCODE,
											 JTAGI2CSAVE_ID,
											 JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode,  
											 JTAGI2CCHECK_PASSWORD ! Check the Password,
								 			 JTAGI2CSAVE_CONTROL0 ! Read Control Register 0,
								             JTAGI2CDISABLE";	

	"JTAGI2C XSRAM Display Control Register1" = "JTAGI2CINIT ! Initialize,
											 JTAGI2CREAD_ID	! Check the IDCODE,
											 JTAGI2CSAVE_ID,
											 JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode,  
											 JTAGI2CCHECK_PASSWORD ! Check the Password,
								 			 JTAGI2CSAVE_CONTROL1 ! Read Control Register 1,
								             JTAGI2CDISABLE";		

	"JTAGI2C XSRAM Read and Save"	=	"NOT_SUPPORTED";			
	
	"JTAGI2C XSRAM Display USERCODE"	=	"JTAGI2CINIT, 
										JTAGI2CREAD_ID, 
										JTAGI2CSAVE_ID,
										JTAGI2CSRAM_TRANSPARENT_READ_ENABLE,
										JTAGI2CSAVE_USERCODE,
										JTAGI2CDISABLE";
		
	"JTAGI2C XSRAM Read Status Register" = "JTAGI2CINIT ! Initialize,
							 			 JTAGI2CREAD_ID	! Check the IDCODE,
							 			 JTAGI2CSAVE_ID,
							 			 JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,
							 			 JTAGI2CSAVE_STATUS,
							 			 JTAGI2CDISABLE ! Exit the programming mode";	

	"JTAGI2C XSRAM Refresh" = "JTAGI2CINIT 	! Initialize,   
							JTAGI2CREAD_ID	! Check the IDCODE,
							JTAGI2CREFRESH_FUNCTION ! Refresh" ;

	"JTAGI2C XSRAM Bypass"	=	"INIT"	;								 
						
	"Slave SPI Program Feature Row" = " SPIINIT_DIRECT ! Initialize,
	                                  SPIREAD_ID ! Verify ID,
	                                  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_FEA ! Select feature Row,
	                                  SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  SPICHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  SPIFEATURE_ERASE ! Erase Feature Row,
									  SPICHECK_STATUS ! Read the Status bits,
									  SPIFEATURE_PROGRAM ! Program Verify Feature Row,
									  SPICHECK_STATUS ! Read the Status bits,
	                                  SPIDISABLE ! Exit the programming mode"	;                              

	"Slave SPI Update Feature Row" = " SPIINIT_DIRECT ! Initialize,
	                                  SPIREAD_ID ! Verify ID,
	                                  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_FEA ! Select Feature Row,
	                                  SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  SPICHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  SPIFEATURE_ERASE ! Erase Feature Row,
									  SPICHECK_STATUS ! Read the Status bits,
									  SPIFEATURE_PROGRAM ! Program Verify Feature Row,
									  SPICHECK_STATUS ! Read the Status bits,
	                                  SPIDISABLE ! Exit the programming mode"	; 

	"Slave SPI Program Feature Row and Lock" = " SPIINIT_DIRECT ! Initialize,
											  SPIREAD_ID ! Verify ID,
											  SPIFLASH_ENABLE	! Enable the FLASH,
											  SPISELECT_FEA ! Select Feature Row,
											  SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
											  SPICHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
											  SPIFEATURE_ERASE ! Erase Feature Row,
											  SPICHECK_STATUS ! Read the Status bits,
											  SPIFEATURE_PROGRAM ! Program Verify Feature Row,
											  SPICHECK_STATUS ! Read the Status bits,
											  SPIFEA_PROGRAM_SECURITY ! Program Security Bits,
											  SPICHECK_STATUS ! Read the Status bits,
											  SPIDISABLE ! Exit the programming mode"	;     

	"Slave SPI Program Feature Row Lock" = " SPIINIT_DIRECT ! Initialize,
	                                  SPIREAD_ID ! Verify ID,
	                                  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_FEA ! Select Feature Row,
	                                  SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  SPICHECK_PROGRAM_SECURITY ! Check Feature Row Program Security,
									  SPIFEA_PROGRAM_SECURITY ! Program Security Bits,
									  SPICHECK_STATUS ! Read the Status bits,
	                                  SPIDISABLE ! Exit the programming mode"	;  
									  
	"Slave SPI Erase Feature Row" = " SPIINIT_DIRECT ! Initialize,
	                                  SPIREAD_ID ! Verify ID,
	                                  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_FEA ! Select Feature Row,
	                                  SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  SPICHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  SPIFEATURE_ERASE ! Erase Feature Row,
									  SPICHECK_STATUS ! Read the Status bits,
	                                  SPIDISABLE ! Exit the programming mode"	;  
									  
	"Slave SPI Read Feature Row" = " SPIINIT ! Initialize,
	                                  SPIREAD_ID ! Verify ID,
									  SPISAVE_ID ! Save ID,
	                                  SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
									  SPISELECT_FEA ! Select Feature Row,
	                                  SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  SPICHECK_READ_SECURITY ! Check Feature Row Erase Security,
									  SPIFEATURE_ROW_READ ! Read Feature Row,
	                                  SPIDISABLE ! Exit the programming mode"	;   
								  
	"Slave SPI Program Control NV Register1" = " SPIINIT_DIRECT ! Initialize,
	                                  SPIREAD_ID ! Verify ID,
	                                  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_FEA ! Select Feature Row,
	                                  SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  SPICHECK_READ_SECURITY ! Check Feature Row Read Security,
	                                  SPICHECK_PROGRAM_SECURITY ! Check Feature Row Program Security,
	                                  SPIPROGRAM_CONTROL_NV1 ! Program Control NV Register1,
	                                  SPIDISABLE ! Exit the programming mode"	;                              

	"Slave SPI Display Control NV Register1" = " SPIINIT ! Initialize,
	                                  SPIREAD_ID ! Verify ID,
	                                  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_FEA ! Select Feature Row,
	                                  SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  SPICHECK_READ_SECURITY ! Check Feature Row Read Security,
									  SPISAVE_CONTROL_NV1 ! Read Control NV Register1,
	                                  SPIDISABLE ! Exit the programming mode"	;  

	
	"Slave SPI Security Secure Plus" ="SPIINIT_DIRECT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,									
									SPICHECK_PASSWORD ! Check Password Protect,
									SPICSEC_PROGRAM_LOCK	! Program sector's lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C Security Secure Plus" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_PASSWORD ! Check Password Protect,  
									I2CCSEC_PROGRAM_LOCK	! Program sector's lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C Security Secure Plus" ="JTAGI2CINIT_DIRECT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_PASSWORD ! Check Password Protect,  
										JTAGI2CCSEC_PROGRAM_LOCK	! Program sector's lock,
										JTAGI2CDISABLE	! Exit the programming mode";
										

	"Slave SPI Security Update Locks Policies" ="SPIINIT_DIRECT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_PASSWORD ! Check Password Protect, 
									SPICSEC_PROGRAM_LOCK	! Program sector's lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C Security Update Locks Policies" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_PASSWORD ! Check Password Protect,  
									I2CCSEC_PROGRAM_LOCK	! Program sector's lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C Security Update Locks Policies" ="JTAGI2CINIT_DIRECT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_PASSWORD ! Check Password Protect,  
										JTAGI2CCSEC_PROGRAM_LOCK	! Program sector's lock,
										JTAGI2CDISABLE	! Exit the programming mode";
	
	"Slave SPI Security Read Locks Policies" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPISAVE_ID,
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
									SPICHECK_CFG_PASSWORD ! Check Password Protect,  
									SPICHECK_UFM_PASSWORD ! Check Password Protect,  
									SPICHECK_FEATURE_PASSWORD ! Check Password Protect,  
									SPICFG_READ_CENTRAL_LOCK	! Read sector's lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C Security Read Locks Policies" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CSAVE_ID,
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
									I2CCHECK_CFG_PASSWORD ! Check Password Protect,  
									I2CCHECK_UFM_PASSWORD ! Check Password Protect,  
									I2CCHECK_FEATURE_PASSWORD ! Check Password Protect,  
									I2CCFG_READ_CENTRAL_LOCK	! Read sector's lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C Security Read Locks Policies" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CSAVE_ID,
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
										JTAGI2CCHECK_CFG_PASSWORD ! Check Password Protect,  
										JTAGI2CCHECK_UFM_PASSWORD ! Check Password Protect,  
										JTAGI2CCHECK_FEATURE_PASSWORD ! Check Password Protect,  
										JTAGI2CCFG_READ_CENTRAL_LOCK	! Read sector's lock,
										JTAGI2CDISABLE	! Exit the programming mode";
																			
	"Slave SPI Security Program Password Key" ="SPIINIT_DIRECT 	! Initialize, 
										  SPIREAD_ID	! Check the IDCODE, 
										  SPIFLASH_ENABLE	! Enable the FLASH, 
										  SPISELECT_FEA ! Select Feature Sector,
										  SPICHECK_PROGRAM_SECURITY ! Check Feature Row Program Security, 
										  SPIPROG_PASSWORD ! Program Password,
										  SPIDISABLE ! Exit the programming mode" ;

	"Slave SPI Security Read Password Key" =  "SPIINIT 	! Initialize, 
											 SPIREAD_ID	! Check the IDCODE,									 
											 SPIFLASH_ENABLE	! Enable the FLASH,
											 SPISELECT_FEA ! Select Feature Row,
											 SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
											 SPICHECK_READ_SECURITY ! Check Feature Row Read Security, 								   
											 SPIREAD_PASSWORD ! Read the Password key,
											 SPIDISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program TraceID" = "SPIINIT_DIRECT 	! Initialize, 
										    SPIREAD_ID	! Check the IDCODE,
										    SPIFLASH_ENABLE	! Enable the programming mode,
										    SPISELECT_FEA ! Select Feature Sector, 		
										    SPICHECK_FEATURE_PASSWORD ! Check the Password, 						  
										    SPICHECK_PROGRAM_SECURITY ! Check the FeatureRow Program Security,
										    SPIPROGRAM_TRACEID ! Program the TraceID,
										    SPIDISABLE ! Exit the programming mode";
	
	"Slave SPI Security Read TraceID" = "SPIINIT	! Initialize, 
										 SPISAVE_TRACEID ! Save TraceID";
	
	"I2C Program Feature Row" = " I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
									  I2CSELECT_FEA ! Select Feature Row,
	                                  I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  I2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  I2CFEATURE_ERASE ! Erase Feature Row,
									  I2CFEATURE_PROGRAM ! Program Feature Row,
									  I2CDISABLE_NEW_ADDR ! Exit the programming mode"	;  

	"I2C Update Feature Row" = " I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
									  I2CSELECT_FEA ! Select Feature Row,
	                                  I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  I2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  I2CFEATURE_ERASE ! Erase Feature Row,
									  I2CFEATURE_PROGRAM ! Program Verify Feature Row,
									  I2CDISABLE ! Exit the programming mode"	; 

	"I2C Program Feature Row and Lock" = " I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
									  I2CSELECT_FEA ! Select Feature Row,
	                                  I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  I2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  I2CFEATURE_ERASE ! Erase Feature Row,
									  I2CFEATURE_PROGRAM ! Program Feature Row,
									  I2CFEA_PROGRAM_SECURITY_NEW_ADDR ! Program Security Bits,
									  I2CDISABLE_NEW_ADDR ! Exit the programming mode"	; 

	"I2C Program Feature Row Lock" = " I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
									  I2CSELECT_FEA ! Select Feature Row,
	                                  I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  I2CCHECK_PROGRAM_SECURITY ! Check Feature Row Program Security,
									  I2CFEA_PROGRAM_SECURITY ! Program Security Bits,
									  I2CCHECK_STATUS ! Read the Status bits,
	                                  I2CDISABLE ! Exit the programming mode"	; 

	"I2C Erase Feature Row" = " I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
									  I2CSELECT_FEA ! Select Feature Row,
	                                  I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  I2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  I2CFEATURE_ERASE ! Erase Feature Row,
									  I2CDISABLE_DEFAULT ! Exit the programming mode"	; 
									  
	"I2C Read Feature Row" = " I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
									  I2CSELECT_FEA ! Select Feature Row,
	                                  I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  I2CCHECK_READ_SECURITY ! Check Feature Row Erase Security,
									  I2CFEATURE_ROW_READ ! Read Feature Row,
	                                  I2CDISABLE ! Exit the programming mode"	;   
									   									 							  
	"I2C Program Control NV Register1" = " I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
									  I2CSELECT_FEA ! Select Feature Row,
	                                  I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  I2CCHECK_READ_SECURITY ! Check Feature Row Read Security,
	                                  I2CCHECK_PROGRAM_SECURITY ! Check Feature Row Program Security,
	                                  I2CPROGRAM_CONTROL_NV1 ! Program Control NV Register1,
	                                  I2CDISABLE ! Exit the programming mode"	;                              

	"I2C Display Control NV Register1" = " I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
									  I2CSELECT_FEA ! Select Feature Row,
	                                  I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  I2CCHECK_READ_SECURITY ! Check Feature Row Read Security,
									  I2CSAVE_CONTROL_NV1 ! Read Control NV Register1,
	                                  I2CDISABLE ! Exit the programming mode"	;  

	"I2C Security Program Password Key" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the FLASH, 
								  I2CSELECT_FEA ! Select Feature Row,
								  I2CCHECK_PROGRAM_SECURITY ! Check Feature Row Program Security, 
								  I2CPROG_PASSWORD ! Program Password,
								  I2CDISABLE ! Exit the programming mode" ;

	"I2C Security Read Password Key" =  "I2CINIT 	! Initialize, 
											 I2CREAD_ID	! Check the IDCODE,									 
											 I2CFLASH_ENABLE	! Enable the FLASH,
											 I2CSELECT_FEA ! Select Feature Row,
											 I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
											 I2CCHECK_READ_SECURITY ! Check Feature Row Read Security, 								   
											 I2CREAD_PASSWORD ! Read the Password key,
											 I2CDISABLE ! Exit the programming mode" ;									  

	"I2C Security Program TraceID" = "I2CINIT 	! Initialize, 
										    I2CREAD_ID	! Check the IDCODE,
										    I2CFLASH_ENABLE	! Enable the programming mode,
										    I2CSELECT_FEA ! Select Feature Row,		
										    I2CCHECK_FEATURE_PASSWORD ! Check the Password, 						  
										    I2CCHECK_PROGRAM_SECURITY ! Check the FeatureRow Program Security,
										    I2CPROGRAM_TRACEID ! Program the TraceID,
										    I2CDISABLE ! Exit the programming mode";
	
	"I2C Security Read TraceID" = "I2CINIT	! Initialize, 
										 I2CSAVE_TRACEID ! Save TraceID";											 
											 
	"JTAGI2C Program Feature Row" = " JTAGI2CINIT_DIRECT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
									  JTAGI2CSELECT_FEA ! Select Feature Row,
	                                  JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  JTAGI2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  JTAGI2CFEATURE_ERASE ! Erase Feature Row,
									  JTAGI2CFEATURE_PROGRAM ! Program Feature Row,
									  JTAGI2CDISABLE_NEW_ADDR ! Exit the programming mode"	; 

	"JTAGI2C Update Feature Row" = " JTAGI2CINIT_DIRECT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
									  JTAGI2CSELECT_FEA ! Select Feature Row,
	                                  JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  JTAGI2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  JTAGI2CFEATURE_ERASE ! Erase Feature Row,
									  JTAGI2CFEATURE_PROGRAM ! Program Verify Feature Row,
	                                  JTAGI2CDISABLE ! Exit the programming mode"	; 
									  
	"JTAGI2C Program Feature Row and Lock" = " JTAGI2CINIT_DIRECT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
									  JTAGI2CSELECT_FEA ! Select Feature Row,
	                                  JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  JTAGI2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  JTAGI2CFEATURE_ERASE ! Erase Feature Row,
									  JTAGI2CFEATURE_PROGRAM ! Program Feature Row,
									  JTAGI2CFEA_PROGRAM_SECURITY_NEW_ADDR ! Program Security Bits,
									  JTAGI2CDISABLE_NEW_ADDR ! Exit the programming mode"	; 

	"JTAGI2C Program Feature Row Lock" = " JTAGI2CINIT_DIRECT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
									  JTAGI2CSELECT_FEA ! Select Feature Row,
	                                  JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  JTAGI2CCHECK_PROGRAM_SECURITY ! Check Feature Row Erase Security,
									  JTAGI2CFEA_PROGRAM_SECURITY ! Program Security Bits,
									  JTAGI2CCHECK_STATUS ! Read the Status bits,
	                                  JTAGI2CDISABLE ! Exit the programming mode"	; 

	"JTAGI2C Erase Feature Row" = " JTAGI2CINIT_DIRECT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
									  JTAGI2CSELECT_FEA ! Select Feature Row,
	                                  JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  JTAGI2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  JTAGI2CFEATURE_ERASE ! Erase Feature Row,
									  JTAGI2CDISABLE ! Exit the programming mode"	;  		
									  
	"JTAGI2C Read Feature Row" = " JTAGI2CINIT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
									  JTAGI2CSELECT_FEA ! Select Feature Row,
	                                  JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  JTAGI2CCHECK_READ_SECURITY ! Check Feature Row Erase Security,
									  JTAGI2CFEATURE_ROW_READ ! Read Feature Row,
	                                  JTAGI2CDISABLE ! Exit the programming mode"	;   
									  							  								  
	"JTAGI2C Program Control NV Register1" = " JTAGI2CINIT_DIRECT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
									  JTAGI2CSELECT_FEA ! Select Feature Row,
	                                  JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  JTAGI2CCHECK_READ_SECURITY ! Check Feature Row Read Security,
	                                  JTAGI2CCHECK_PROGRAM_SECURITY ! Check Feature Row Program Security,
	                                  JTAGI2CPROGRAM_CONTROL_NV1 ! Program Control NV Register1,
	                                  JTAGI2CDISABLE ! Exit the programming mode"	;                              

	"JTAGI2C Display Control NV Register1" = " JTAGI2CINIT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
									  JTAGI2CSELECT_FEA ! Select Feature Row,
	                                  JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  JTAGI2CCHECK_READ_SECURITY ! Check Feature Row Read Security,
									  JTAGI2CSAVE_CONTROL_NV1 ! Read Control NV Register1,
	                                  JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C Security Program Password Key" ="JTAGI2CINIT_DIRECT 	! Initialize, 
								  JTAGI2CREAD_ID	! Check the IDCODE, 
								  JTAGI2CFLASH_ENABLE	! Enable the FLASH, 
								  JTAGI2CSELECT_FEA ! Select Feature Row,
								  JTAGI2CCHECK_PROGRAM_SECURITY ! Check Feature Row Program Security, 
								  JTAGI2CPROG_PASSWORD ! Program Password,
								  JTAGI2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Read Password Key" =  "JTAGI2CINIT 	! Initialize, 
											 JTAGI2CREAD_ID	! Check the IDCODE,									 
											 JTAGI2CFLASH_ENABLE	! Enable the FLASH,
											 JTAGI2CSELECT_FEA ! Select Feature Row,
											 JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
											 JTAGI2CCHECK_READ_SECURITY ! Check Feature Row Read Security, 								   
											 JTAGI2CREAD_PASSWORD ! Read the Password key,
											 JTAGI2CDISABLE ! Exit the programming mode" ;										  

	"JTAGI2C Security Program TraceID" = "JTAGI2CINIT_DIRECT 	! Initialize, 
										    JTAGI2CREAD_ID	! Check the IDCODE,
										    JTAGI2CFLASH_ENABLE	! Enable the programming mode,
										    JTAGI2CSELECT_FEA ! Select Feature Sector, 		
										    JTAGI2CCHECK_FEATURE_PASSWORD ! Check the Password, 						  
										    JTAGI2CCHECK_PROGRAM_SECURITY ! Check the FeatureRow Program Security,
										    JTAGI2CPROGRAM_TRACEID ! Program the TraceID,
										    JTAGI2CDISABLE ! Exit the programming mode";
	
	"JTAGI2C Security Read TraceID" = "JTAGI2CINIT	! Initialize, 
										 JTAGI2CSAVE_TRACEID ! Save TraceID";	
											 
	"Slave SPI FLASH Erase,Program,Verify" = "SPIINIT_DIRECT ! Initialize,
											  SPIREAD_ID	! Check the IDCODE,
											  SPIFLASH_ENABLE	! Enable the FLASH,
											  SPIFLASH_PROGRAM_FULL ! Program Flash and UFM,
											  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH Erase,Program,Verify and Lock" = "SPIINIT_DIRECT ! Initialize,
													  SPIREAD_ID	! Check the IDCODE,
													  SPIFLASH_ENABLE	! Enable the FLASH,
													  SPIFLASH_PROGRAM_FULL ! Program Flash and UFM,
													  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
													  SPICFG_PROGRAM_SECURITY ! Program CFG Security Bits,
													  SPICHECK_UFM_PASSWORD ! Check CFG Password Protect,
													  SPIUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
													  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH Erase Only" = "SPIINIT_DIRECT ! Initialize,
									  SPIREAD_ID	! Check the IDCODE,
									  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_CFG ! Select CFG Sector,
									  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
									  SPICFG_ERASE ! ERASE CFG,
									  SPISELECT_UFM ! Select UFM Sector,
									  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
									  SPIUFM_ERASE ! ERASE UFM,
									  SPIDISABLE ! Exit the programming mode"	;  							  
							  
	"Slave SPI FLASH Verify Only" = "SPIINIT ! Initialize,
									  SPIREAD_ID	! Check the IDCODE,
									  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_CFG ! Select CFG Sector,
									  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
									  SPICFG_VERIFY_FULL ! Verify CFG,
									  SPISELECT_UFM ! Select UFM Sector,
									  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
									  SPIUFM_VERIFY_FULL ! Verify UFM,
									  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH CFG Erase,Program,Verify" = "SPIINIT_DIRECT ! Initialize,
												  SPIREAD_ID	! Check the IDCODE,
												  SPIFLASH_ENABLE	! Enable the FLASH,
												  SPIFLASH_CFG_PROGRAM_FULL ! Program CFG,
												  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH CFG Erase,Program,Verify and Lock" = "SPIINIT_DIRECT ! Initialize,
														  SPIREAD_ID	! Check the IDCODE,
														  SPIFLASH_ENABLE	! Enable the FLASH,
														  SPIFLASH_CFG_PROGRAM_FULL ! Program CFG,
														  SPICFG_PROGRAM_SECURITY ! Program CFG Security Bits,
														  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH CFG Erase Only" = "SPIINIT_DIRECT ! Initialize,
										  SPIREAD_ID	! Check the IDCODE,
										  SPIFLASH_ENABLE	! Enable the FLASH,
										  SPISELECT_CFG ! Select CFG Sector,
										  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
										  SPICFG_ERASE ! ERASE CFG,
										  SPIDISABLE ! Exit the programming mode"	;  
							  
							  
	"Slave SPI FLASH CFG Verify Only" = "SPIINIT ! Initialize,
										  SPIREAD_ID	! Check the IDCODE,
										  SPIFLASH_ENABLE	! Enable the FLASH,
										  SPISELECT_CFG ! Select CFG Sector,
										  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
										  SPICFG_VERIFY_FULL ! Verify CFG,
										  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH UFM Erase,Program,Verify" = "SPIINIT_DIRECT ! Initialize,
												  SPIREAD_ID	! Check the IDCODE,
												  SPIFLASH_ENABLE	! Enable the FLASH,
												  SPIFLASH_UFM_PROGRAM_FULL ! Program UFM,
												  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH UFM Erase,Program,Verify and Lock" = "SPIINIT_DIRECT ! Initialize,
														  SPIREAD_ID	! Check the IDCODE,
														  SPIFLASH_ENABLE	! Enable the FLASH,
														  SPIFLASH_UFM_PROGRAM_FULL ! Program UFM,
														  SPIUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
														  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH UFM Erase Only" = "SPIINIT_DIRECT ! Initialize,
										  SPIREAD_ID	! Check the IDCODE,
										  SPIFLASH_ENABLE	! Enable the FLASH,
										  SPISELECT_UFM ! Select UFM Sector,
										  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
										  SPIUFM_ERASE ! ERASE CFG,
										  SPIDISABLE ! Exit the programming mode"	;  
							  							  
	"Slave SPI FLASH UFM Verify Only" = "SPIINIT ! Initialize,
										  SPIREAD_ID	! Check the IDCODE,
										  SPIFLASH_ENABLE	! Enable the FLASH,
										  SPISELECT_UFM ! Select UFM Sector,
										  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
										  SPIUFM_VERIFY_FULL ! Verify UFM,
										  SPIDISABLE ! Exit the programming mode"	;  
									  
	"Slave SPI FLASH Verify ID" = " SPIINIT ! Initialize,
									SPIREAD_ID ! Verify ID" ;
	                   
	"Slave SPI FLASH Display ID" = " SPIINIT ! Initialize,
									SPISAVE_ID" ;
	
	"Slave SPI FLASH Display USERCODE" = " SPIINIT ! Initialize,
										   SPIREAD_ID ! Verify ID,
										   SPISAVE_ID,
										   SPIFLASH_ENABLE	! Enable the FLASH,
										   SPIDISPLAY_FLASH_USERCODE ! Save USERCODE,
										   SPIDISABLE ! Exit the programming mode";
	                                            
	"Slave SPI FLASH Read and Save" = " SPIINIT ! Initialize,
	                          SPIREAD_ID ! Verify ID,
	                          SPISAVE_ID,
	                          SPIFLASH_ENABLE	! Enable the FLASH,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_READ_SECURITY ! Check CFG Read Security,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_READ_SECURITY ! Check UFM Read Security,
	                          SPIFLASH_SAVE_USERCODE ! Save USERCODE,
	                          SPICFG_SAVE ! Save CFG array,
	                          SPISELECT_UFM ! Select UFM Sector,
	                          SPIUFM_SAVE ! Save UFM array,
	                          SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI FLASH Calculate Checksum" = " SPIINIT ! Initialize,
	                          SPIREAD_ID ! Verify ID,
	                          SPISAVE_ID,
	                          SPIFLASH_ENABLE	! Enable the FLASH,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_READ_SECURITY ! Check CFG Read Security,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_READ_SECURITY ! Check UFM Read Security,
	                          SPIFLASH_SAVE_USERCODE ! Save USERCODE,
	                          SPICFG_SAVE ! Save CFG array,
	                          SPISELECT_UFM ! Select UFM Sector,
	                          SPIUFM_SAVE ! Save UFM array,
	                          SPIDISABLE ! Exit the programming mode"	;	
	                              
	"Slave SPI FLASH Read Status Register" =  " SPIINIT ! Initialize,
	                                  SPIREAD_ID ! Verify ID,
	                                  SPISAVE_ID,
	                                  SPIFLASH_ENABLE	! Enable the FLASH,
	                                  SPISELECT_SECTOR0,
	                                  SPISAVE_STATUS ! Read status register,
	                                  SPIDISABLE ! Exit the programming mode"	;			
													  
	"Slave SPI FLASH Secure" = "SPIINIT_DIRECT ! Initialize,
								SPIREAD_ID	! Check the IDCODE,
								SPIFLASH_ENABLE	! Enable the FLASH,
								SPICFG_PROGRAM_SECURITY ! Program CFG Security Bits,
								SPIUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
								SPIDISABLE ! Exit the programming mode"	;  
								
	"Slave SPI FLASH Refresh" = " SPIINIT_DIRECT ! Initialize,
	                    SPIREAD_ID ! Verify ID,
	                    SPIREFRESH_FUNCTION ! Refresh";	
						
	"Slave SPI FLASH Bypass" = "INIT"; 

	"I2C FLASH Erase,Program,Verify" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH Erase,Program,Verify and Lock" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
							  I2CCHECK_UFM_PASSWORD ! Check CFG Password Protect,
							  I2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH Erase Only" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_ERASE ! ERASE CFG,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_ERASE ! ERASE UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  							  
	"I2C FLASH Verify Only" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_VERIFY_FULL ! Verify CFG,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_VERIFY_FULL ! Verify UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH CFG Erase,Program,Verify" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH CFG Erase,Program,Verify and Lock" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
							  I2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH CFG Erase Only" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_ERASE ! ERASE CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"I2C FLASH CFG Verify Only" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_VERIFY_FULL ! Verify CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH UFM Erase,Program,Verify" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH UFM Erase,Program,Verify and Lock" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
							  I2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH UFM Erase Only" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_ERASE ! ERASE CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"I2C FLASH UFM Verify Only" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_VERIFY_FULL ! Verify UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  
									  
	"I2C FLASH Verify ID" = " I2CINIT ! Initialize,
	                  		I2CREAD_ID ! Verify ID" ;
	                   
	"I2C FLASH Display ID" = " I2CINIT ! Initialize,
	                         I2CSAVE_ID" ;
	
	"I2C FLASH Display USERCODE" = " I2CINIT ! Initialize,
	                               I2CREAD_ID ! Verify ID,
	                               I2CSAVE_ID,
	                          	   I2CFLASH_ENABLE	! Enable the FLASH,
	                               I2CDISPLAY_FLASH_USERCODE ! Save USERCODE,
	                               I2CDISABLE ! Exit the programming mode";
	                                            
	"I2C FLASH Read and Save" = " I2CINIT ! Initialize,
	                          I2CREAD_ID ! Verify ID,
	                          I2CSAVE_ID,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_READ_SECURITY ! Check CFG Read Security,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_READ_SECURITY ! Check UFM Read Security,
	                          I2CFLASH_SAVE_USERCODE ! Save USERCODE,
	                          I2CCFG_SAVE ! Save CFG array,
	                          I2CSELECT_UFM ! Select UFM Sector,
	                          I2CUFM_SAVE ! Save UFM array,
	                          I2CDISABLE ! Exit the programming mode"	;
	
	"I2C FLASH Calculate Checksum" = " I2CINIT ! Initialize,
	                          I2CREAD_ID ! Verify ID,
	                          I2CSAVE_ID,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_READ_SECURITY ! Check CFG Read Security,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_READ_SECURITY ! Check UFM Read Security,
	                          I2CFLASH_SAVE_USERCODE ! Save USERCODE,
	                          I2CCFG_SAVE ! Save CFG array,
	                          I2CSELECT_UFM ! Select UFM Sector,
	                          I2CUFM_SAVE ! Save UFM array,
	                          I2CDISABLE ! Exit the programming mode"	;	                          
							  
	"I2C FLASH Secure" = "I2CINIT ! Initialize,
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_ENABLE	! Enable the FLASH,
								I2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
								I2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
								I2CDISABLE ! Exit the programming mode"	;
								
	"I2C FLASH Read Status Register" =  " I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CSAVE_ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
	                                  I2CSELECT_SECTOR0,
	                                  I2CSAVE_STATUS ! Read status register,
	                                  I2CDISABLE ! Exit the programming mode"	;	
	                              
	"I2C FLASH Refresh" = " I2CINIT ! Initialize,
	                    I2CREAD_ID ! Verify ID,
	                    I2CREFRESH_FUNCTION ! Refresh";										  

	"I2C FLASH Bypass" = "INIT";	
						
	"JTAGI2C FLASH Erase,Program,Verify" = "JTAGI2CINIT_DIRECT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH Erase,Program,Verify and Lock" = "JTAGI2CINIT_DIRECT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH Erase Only" = "JTAGI2CINIT_DIRECT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_ERASE ! ERASE CFG,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_ERASE ! ERASE UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  							  
	"JTAGI2C FLASH Verify Only" = "JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_VERIFY_FULL ! Verify CFG,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_VERIFY_FULL ! Verify UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH CFG Erase,Program,Verify" = "JTAGI2CINIT_DIRECT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH CFG Erase,Program,Verify and Lock" = "JTAGI2CINIT_DIRECT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
							  JTAGI2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH CFG Erase Only" = "JTAGI2CINIT_DIRECT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_ERASE ! ERASE CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"JTAGI2C FLASH CFG Verify Only" = "JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_VERIFY_FULL ! Verify CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH UFM Erase,Program,Verify" = "JTAGI2CINIT_DIRECT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH UFM Erase,Program,Verify and Lock" = "JTAGI2CINIT_DIRECT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
							  JTAGI2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH UFM Erase Only" = "JTAGI2CINIT_DIRECT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_ERASE ! ERASE CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"JTAGI2C FLASH UFM Verify Only" = "JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_VERIFY_FULL ! Verify UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
									  
	"JTAGI2C FLASH Verify ID" = " JTAGI2CINIT ! Initialize,
	                  		JTAGI2CREAD_ID ! Verify ID" ;
	                   
	"JTAGI2C FLASH Display ID" = " JTAGI2CINIT ! Initialize,
	                         JTAGI2CSAVE_ID" ;
	
	"JTAGI2C FLASH Display USERCODE" = " JTAGI2CINIT ! Initialize,
	                               JTAGI2CREAD_ID ! Verify ID,
	                               JTAGI2CSAVE_ID,
	                          	   JTAGI2CFLASH_ENABLE	! Enable the FLASH,
	                               JTAGI2CDISPLAY_FLASH_USERCODE ! Save USERCODE,
	                               JTAGI2CDISABLE ! Exit the programming mode";
	                                            
	"JTAGI2C FLASH Read and Save" = " JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID ! Verify ID,
	                          JTAGI2CSAVE_ID,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_READ_SECURITY ! Check CFG Read Security,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_READ_SECURITY ! Check UFM Read Security,
	                          JTAGI2CFLASH_SAVE_USERCODE ! Save USERCODE,
	                          JTAGI2CCFG_SAVE ! Save CFG array,
	                          JTAGI2CSELECT_UFM ! Select UFM Sector,
	                          JTAGI2CUFM_SAVE ! Save UFM array,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;
	                          
	"JTAGI2C FLASH Calculate Checksum" = " JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID ! Verify ID,
	                          JTAGI2CSAVE_ID,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_READ_SECURITY ! Check CFG Read Security,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_READ_SECURITY ! Check UFM Read Security,
	                          JTAGI2CFLASH_SAVE_USERCODE ! Save USERCODE,
	                          JTAGI2CCFG_SAVE ! Save CFG array,
	                          JTAGI2CSELECT_UFM ! Select UFM Sector,
	                          JTAGI2CUFM_SAVE ! Save UFM array,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;
		                              
	"JTAGI2C FLASH Read Status Register" =  " JTAGI2CINIT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CSAVE_ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
	                                  JTAGI2CSELECT_SECTOR0,
			                          JTAGI2CSAVE_STATUS ! Read status register,
	                                  JTAGI2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C FLASH Secure" = "JTAGI2CINIT_DIRECT ! Initialize,
								JTAGI2CREAD_ID	! Check the IDCODE,
								JTAGI2CFLASH_ENABLE	! Enable the FLASH,
								JTAGI2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
								JTAGI2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
								JTAGI2CDISABLE ! Exit the programming mode"	;
								
	"JTAGI2C FLASH Refresh" = " JTAGI2CINIT ! Initialize,
	                    JTAGI2CREAD_ID ! Verify ID,
	                    JTAGI2CREFRESH_FUNCTION ! Refresh";
						
	"JTAGI2C FLASH Bypass" = "INIT";						
	
	"Slave SPI XFLASH Erase,Program,Verify" = "SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPIFLASH_PROGRAM_FULL ! Program Flash and UFM,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH Erase,Program,Verify and Lock" = "SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPIFLASH_PROGRAM_FULL ! Program Flash and UFM,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPICFG_PROGRAM_SECURITY ! Program CFG Security Bits,
							  SPIUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH Erase Only" = "SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPICFG_ERASE ! ERASE CFG,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  SPIUFM_ERASE ! ERASE UFM,
	                          SPIDISABLE ! Exit the programming mode"	;  
							  
							  
	"Slave SPI XFLASH Verify Only" = "SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPICFG_VERIFY_FULL ! Verify CFG,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  SPIUFM_VERIFY_FULL ! Verify UFM,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH Program and TransFR" = "SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPIFLASH_PROGRAM_FULL ! Program CFG and UFM,								
									SPIDISABLE ! Exit the programming mode,									
									SPIREFRESH_FUNCTION ! Refresh,
									SPIVERIFY_SRAM_DONE_BIT ! Check SRAM Status Register";
	
	"Slave SPI XFLASH TransFR" = "SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE,
								  SPIREFRESH_FUNCTION ! Refresh";
							  
	"Slave SPI XFLASH CFG Erase,Program,Verify" = "SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPIFLASH_CFG_PROGRAM_FULL ! Program CFG,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH CFG Erase,Program,Verify and Lock" = "SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPIFLASH_CFG_PROGRAM_FULL ! Program CFG,
							  SPICFG_PROGRAM_SECURITY ! Program CFG Security Bits,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH CFG Erase Only" = "SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPICFG_ERASE ! ERASE CFG,
	                          SPIDISABLE ! Exit the programming mode"	;  
							  
							  
	"Slave SPI XFLASH CFG Verify Only" = "SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPICFG_VERIFY_FULL ! Verify CFG,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH UFM Erase,Program,Verify" = "SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPIFLASH_UFM_PROGRAM_FULL ! Program UFM,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH UFM Erase,Program,Verify and Lock" = "SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPIFLASH_UFM_PROGRAM_FULL ! Program UFM,
							  SPIUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH UFM Erase Only" = "SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  SPIUFM_ERASE ! ERASE CFG,
	                          SPIDISABLE ! Exit the programming mode"	;  
							  
							  
	"Slave SPI XFLASH UFM Verify Only" = "SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  SPIUFM_VERIFY_FULL ! Verify UFM,
	                          SPIDISABLE ! Exit the programming mode"	;  
									  
	"Slave SPI XFLASH Verify ID" = " SPIINIT ! Initialize,
	                  		SPIREAD_ID ! Verify ID" ;
	                   
	"Slave SPI XFLASH Display ID" = " SPIINIT ! Initialize,
	                         SPISAVE_ID" ;
	
	"Slave SPI XFLASH Display USERCODE" = " SPIINIT ! Initialize,
	                               SPIREAD_ID ! Verify ID,
	                               SPISAVE_ID,
	                          	   SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
	                               SPIDISPLAY_FLASH_USERCODE ! Save USERCODE,
	                               SPIDISABLE ! Exit the programming mode";
	                                            
	"Slave SPI XFLASH Read and Save" = " SPIINIT ! Initialize,
	                          SPIREAD_ID ! Verify ID,
	                          SPISAVE_ID,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_READ_SECURITY ! Check CFG Read Security,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_READ_SECURITY ! Check UFM Read Security,
	                          SPIFLASH_SAVE_USERCODE ! Save USERCODE,
	                          SPICFG_SAVE ! Save CFG array,
	                          SPISELECT_UFM ! Select UFM Sector,
	                          SPIUFM_SAVE ! Save UFM array,
	                          SPIDISABLE ! Exit the programming mode"	;
	                              
	"Slave SPI XFLASH Calculate Checksum" = " SPIINIT ! Initialize,
	                          SPIREAD_ID ! Verify ID,
	                          SPISAVE_ID,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_READ_SECURITY ! Check CFG Read Security,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_READ_SECURITY ! Check UFM Read Security,
	                          SPIFLASH_SAVE_USERCODE ! Save USERCODE,
	                          SPICFG_SAVE ! Save CFG array,
	                          SPISELECT_UFM ! Select UFM Sector,
	                          SPIUFM_SAVE ! Save UFM array,
	                          SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI XFLASH Read Status Register" =  " SPIINIT ! Initialize,
	                                  SPIREAD_ID ! Verify ID,
	                                  SPISAVE_ID,
	                                  SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
	                                  SPISAVE_STATUS ! Read status register,
	                                  SPIDISABLE ! Exit the programming mode"	;			

	"Slave SPI XFLASH Secure" = "SPIINIT ! Initialize,
								SPIREAD_ID	! Check the IDCODE,
								SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
								SPICFG_PROGRAM_SECURITY ! Program CFG Security Bits,
								SPIUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
								SPIDISABLE ! Exit the programming mode"	;
								
	"Slave SPI XFLASH Refresh" = " SPIINIT ! Initialize,
	                    SPIREAD_ID ! Verify ID,
	                    SPIREFRESH_FUNCTION ! Refresh";	
						
	"Slave SPI XFLASH Bypass" = "INIT"; 
						
	"I2C XFLASH Erase,Program,Verify" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH Erase,Program,Verify and Lock" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH Erase Only" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_ERASE ! ERASE CFG,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_ERASE ! ERASE UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"I2C XFLASH Verify Only" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_VERIFY_FULL ! Verify CFG,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_VERIFY_FULL ! Verify UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  
	"I2C XFLASH Program and TransFR" = "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									I2CFLASH_PROGRAM_FULL ! Program CFG and UFM,								
									I2CDISABLE_REFRESH ! Refresh,
									I2CVERIFY_SRAM_DONE_BIT ! Check SRAM Status Register";
	
	"I2C XFLASH TransFR" = "I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE,
								  I2CREFRESH_FUNCTION ! Refresh";

	"I2C XFLASH CFG Erase,Program,Verify" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH CFG Erase,Program,Verify and Lock" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
							  I2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH CFG Erase Only" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_ERASE ! ERASE CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"I2C XFLASH CFG Verify Only" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_VERIFY_FULL ! Verify CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH UFM Erase,Program,Verify" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH UFM Erase,Program,Verify and Lock" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
							  I2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH UFM Erase Only" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_ERASE ! ERASE CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"I2C XFLASH UFM Verify Only" = "I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_VERIFY_FULL ! Verify UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  
									  
	"I2C XFLASH Verify ID" = " I2CINIT ! Initialize,
	                  		I2CREAD_ID ! Verify ID" ;
	                   
	"I2C XFLASH Display ID" = " I2CINIT ! Initialize,
	                         I2CSAVE_ID" ;
	
	"I2C XFLASH Display USERCODE" = " I2CINIT ! Initialize,
	                               I2CREAD_ID ! Verify ID,
	                               I2CSAVE_ID,
	                          	   I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
	                               I2CDISPLAY_FLASH_USERCODE ! Save USERCODE,
	                               I2CDISABLE ! Exit the programming mode";
	                                            
	"I2C XFLASH Read and Save" = " I2CINIT ! Initialize,
	                          I2CREAD_ID ! Verify ID,
	                          I2CSAVE_ID,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_READ_SECURITY ! Check CFG Read Security,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_READ_SECURITY ! Check UFM Read Security,
	                          I2CFLASH_SAVE_USERCODE ! Save USERCODE,
	                          I2CCFG_SAVE ! Save CFG array,
	                          I2CSELECT_UFM ! Select UFM Sector,
	                          I2CUFM_SAVE ! Save UFM array,
	                          I2CDISABLE ! Exit the programming mode"	;
	                              
	"I2C XFLASH Calculate Checksum" = " I2CINIT ! Initialize,
	                          I2CREAD_ID ! Verify ID,
	                          I2CSAVE_ID,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_READ_SECURITY ! Check CFG Read Security,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_READ_SECURITY ! Check UFM Read Security,
	                          I2CFLASH_SAVE_USERCODE ! Save USERCODE,
	                          I2CCFG_SAVE ! Save CFG array,
	                          I2CSELECT_UFM ! Select UFM Sector,
	                          I2CUFM_SAVE ! Save UFM array,
	                          I2CDISABLE ! Exit the programming mode"	;

	"I2C XFLASH Read Status Register" =  " I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CSAVE_ID,
	                                  I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
	                                  I2CSAVE_STATUS ! Read status register,
	                                  I2CDISABLE ! Exit the programming mode"	;	

	"I2C XFLASH Secure" = "I2CINIT ! Initialize,
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
								I2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
								I2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
								I2CDISABLE ! Exit the programming mode"	;
								
	"I2C XFLASH Refresh" = " I2CINIT ! Initialize,
	                    I2CREAD_ID ! Verify ID,
	                    I2CREFRESH_FUNCTION ! Refresh";										  

	"I2C XFLASH Bypass" = "INIT";	
													     
	"JTAGI2C XFLASH Erase,Program,Verify" = "JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH Erase,Program,Verify and Lock" = "JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH Erase Only" = "JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_ERASE ! ERASE CFG,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_ERASE ! ERASE UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"JTAGI2C XFLASH Verify Only" = "JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_VERIFY_FULL ! Verify CFG,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_VERIFY_FULL ! Verify UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  
	"JTAGI2C XFLASH Program and TransFR" = "JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									JTAGI2CFLASH_PROGRAM_FULL ! Program CFG and UFM,											
									JTAGI2CDISABLE_REFRESH ! Refresh";
	
	"JTAGI2C XFLASH TransFR" = "JTAGI2CINIT 	! Initialize, 
								  JTAGI2CREAD_ID	! Check the IDCODE,
								  JTAGI2CREFRESH_FUNCTION ! Refresh";

	"JTAGI2C XFLASH CFG Erase,Program,Verify" = "JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH CFG Erase,Program,Verify and Lock" = "JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
							  JTAGI2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH CFG Erase Only" = "JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_ERASE ! ERASE CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"JTAGI2C XFLASH CFG Verify Only" = "JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_VERIFY_FULL ! Verify CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH UFM Erase,Program,Verify" = "JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH UFM Erase,Program,Verify and Lock" = "JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
							  JTAGI2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH UFM Erase Only" = "JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_ERASE ! ERASE CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"JTAGI2C XFLASH UFM Verify Only" = "JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_VERIFY_FULL ! Verify UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
									  
	"JTAGI2C XFLASH Verify ID" = " JTAGI2CINIT ! Initialize,
	                  		JTAGI2CREAD_ID ! Verify ID" ;
	                   
	"JTAGI2C XFLASH Display ID" = " JTAGI2CINIT ! Initialize,
	                         JTAGI2CSAVE_ID" ;
	
	"JTAGI2C XFLASH Display USERCODE" = " JTAGI2CINIT ! Initialize,
	                               JTAGI2CREAD_ID ! Verify ID,
	                               JTAGI2CSAVE_ID,
	                          	   JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
	                               JTAGI2CDISPLAY_FLASH_USERCODE ! Save USERCODE,
	                               JTAGI2CDISABLE ! Exit the programming mode";
	                                            
	"JTAGI2C XFLASH Read and Save" = " JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID ! Verify ID,
	                          JTAGI2CSAVE_ID,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_READ_SECURITY ! Check CFG Read Security,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_READ_SECURITY ! Check UFM Read Security,
	                          JTAGI2CFLASH_SAVE_USERCODE ! Save USERCODE,
	                          JTAGI2CCFG_SAVE ! Save CFG array,
	                          JTAGI2CSELECT_UFM ! Select UFM Sector,
	                          JTAGI2CUFM_SAVE ! Save UFM array,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;
	                              
	"JTAGI2C XFLASH Calculate Checksum" = " JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID ! Verify ID,
	                          JTAGI2CSAVE_ID,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_READ_SECURITY ! Check CFG Read Security,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_READ_SECURITY ! Check UFM Read Security,
	                          JTAGI2CFLASH_SAVE_USERCODE ! Save USERCODE,
	                          JTAGI2CCFG_SAVE ! Save CFG array,
	                          JTAGI2CSELECT_UFM ! Select UFM Sector,
	                          JTAGI2CUFM_SAVE ! Save UFM array,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C XFLASH Read Status Register" =  " JTAGI2CINIT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CSAVE_ID,
	                                  JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
	                                  JTAGI2CSAVE_STATUS ! Read status register,
	                                  JTAGI2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C XFLASH Secure" = "JTAGI2CINIT ! Initialize,
								JTAGI2CREAD_ID	! Check the IDCODE,
								JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
								JTAGI2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
								JTAGI2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
								JTAGI2CDISABLE ! Exit the programming mode"	;
								
	"JTAGI2C XFLASH Refresh" = " JTAGI2CINIT ! Initialize,
	                    JTAGI2CREAD_ID ! Verify ID,
	                    JTAGI2CREFRESH_FUNCTION ! Refresh";
						
	"JTAGI2C XFLASH Bypass" = "INIT";	
									                       					  				 			 	 					 
</Operation_List>
<Operation_List label="SingleSVFOperation">
	"Bypass" = "INIT ! Initialize"	;		 
	"Slave SPI Disable Only" = "SVF_SPIINIT 	! Initialize, 
	 			 				SPIDISABLE ! Exit the programming mode"	;
	"Slave SPI Enable Only" = "SVF_SPIINIT 	! Initialize, 
						   	   SPIREAD_ID	! Check the IDCODE,
						  	   SPISRAM_ENABLE	! Enable PROGRAM mode"	;						   
	"Slave SPI Re-Initialize" = "SVF_SPIINIT 	! Initialize,  
							 SPIREAD_ID	! Check the IDCODE,
						  	 SPISRAM_ENABLE	! Enable programming mode, 
							 SPISRAM_ERASE	! Erase the device, 
							 SPIDISABLE ! Exit the programming mode"	;																			 		  	 								
	"Slave SPI SRAM Fast Configuration" = "SVF_SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,								 
										SPISRAM_ENABLE	! Enable programming mode,
										SPICHECK_PASSWORD ! Check the Password,  
										SPICHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
										SPISRAM_ERASE	! Erase the device, 
										SPIBURST_PROGRAM	! Program Fuse Map,
										SPISRAM_VERIFY_USERCODE		! Verify USERCODE,
										SPIDISABLE ! Exit the programming mode"	;			
	
	"Slave SPI SRAM Erase,Program,Verify" = "SVF_SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPISRAM_ENABLE	! Enable the SRAM,
											SPICHECK_PASSWORD ! Check the Password,
											SPICHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
											SPISRAM_ERASE	! Erase the device,
											SPIPROGRAM_CONTROL0	! Program Control Register0,
											SPIPROGRAM_CONTROL1	! Program Control Register1,
						 			 		SPISRAM_PROGRAM	! Program SRAM,
											SPISRAM_VERIFY	! Verify CFG,									
											SPISRAM_PROGRAM_USERCODE	! Program USERCODE,
											SPIVERIFY_USERCODE		! Verify USERCODE,																		
											SPISRAMPROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI SRAM Verify Only" = 		"SVF_SPIINIT 	! Initialize, 
							SPIREAD_ID	! Check the IDCODE, 
							SPISRAM_ENABLE	! Enable the SRAM,
							SPICHECK_PASSWORD ! Check the Password,  
							SPICHECK_SRAM_READ_LOCK ! Check the SRAM Read Lock, 
							SPIVERIFY_CONTROL0 ! Verify Control Register0,
							SPIVERIFY_CONTROL1 ! Verify Control Register1,
							SPISRAM_VERIFY	! Verify the SRAM, 
							SPIVERIFY_USERCODE	! Verify USERCODE, 							
							SPIDISABLE ! Exit the programming mode";
										 			 					 			 														
	"Slave SPI SRAM Erase Only"	="SVF_SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE,
								SPISRAM_ENABLE	! Enable programming mode,
								SPICHECK_PASSWORD ! Check the Password,  
								SPICHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
								SPISRAM_ERASE	! Erase the device, 
								SPIDISABLE ! Exit the programming mode"	;	
	
	"Slave SPI SRAM Verify ID" = 	"SVF_SPIINIT 	! Initialize, 
						 			SPIREAD_ID ! Check the IDCODE"; 

	"Slave SPI SRAM Program Control Register0" = "SVF_SPIINIT ! Initialize,
								 SPIREAD_ID	! Check the IDCODE,
								 SPISRAM_ENABLE	! Enable SRAM programming mode, 
					             SPICHECK_PASSWORD ! Check the Password,  
								 SPIPROGRAM_CONTROL0 ! Program Control Register 0,
					             SPIDISABLE";	
					             	
	"Slave SPI SRAM Program Control Register1" = "SVF_SPIINIT ! Initialize,
								 SPIREAD_ID	! Check the IDCODE,
					 			 SPISRAM_ENABLE	! Enable SRAM programming mode, 
					             SPICHECK_PASSWORD ! Check the Password,  
					 			 SPISRAM_PROGRAM_CONTROL1 ! Program Control Register 1,
					             SPIDISABLE";

	"Slave SPI SRAM Verify USERCODE"	=	"SVF_SPIINIT 	! Initialize, 
											 SPIREAD_ID	! Check the IDCODE,
											 SPISRAM_TRANSPARENT_READ_ENABLE,
											 SPIVERIFY_USERCODE		! Verify USERCODE,
											 SPIDISABLE"; 									
	"Slave SPI SRAM Refresh" = "SVF_SPIINIT !Initialize,
								SPIREAD_ID !Check the IDCODE,
								SPIREFRESH_FUNCTION ! Refresh";								
	
	"Slave SPI SRAM Secure Plus" = "SVF_SPIINIT !Initialize,
							SPIREAD_ID !Check the IDCODE,
							SPISRAM_ENABLE	! Enable SRAM programming mode, 								             
							SPICHECK_PASSWORD ! Check the Password,  
							SPICHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
							SPISRAM_SECURE ! Secure the SRAM,
							SPIDISABLE";
														
	"Slave SPI SRAM Bypass"	=	"SVF_SPIINIT 	! Initialize";	
	
	
	"I2C SRAM Fast Configuration" = "	SVF_I2CINIT 	! Initialize,   
										I2CREAD_ID	! Check the IDCODE,
										I2CSRAM_ENABLE	! Enable SRAM programming mode, 
										I2CCHECK_PASSWORD ! Check the Password,  
										I2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
										I2CSRAM_ERASE	! Erase the SRAM, 
										I2CBURST_PROGRAM	! Program Fuse Map,
										I2CSRAM_VERIFY_USERCODE		! Verify USERCODE,
										I2CDISABLE ! Exit the programming mode"	;
										
	"I2C SRAM Erase,Program,Verify" = "	SVF_I2CINIT	! Initialize,   
										I2CREAD_ID	! Check the IDCODE,
										I2CSRAM_ENABLE	! Enable SRAM programming mode, 
										I2CCHECK_PASSWORD ! Check the Password,  
										I2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
										I2CSRAM_ERASE	! Erase the SRAM, 
										I2CPROGRAM_CONTROL0	! Program Control Register0,
										I2CPROGRAM_CONTROL1	! Program Control Register1,
										I2CSRAM_PROGRAM	! Program Fuse Map,
										I2CSRAM_PROGRAM_USERCODE	! Program USERCODE,
										I2CCHECK_SRAM_READ_LOCK ! Check the SRAM read Lock,
										I2CSRAM_VERIFY	! Verify Fuse Map, 
										I2CVERIFY_USERCODE		! Verify USERCODE,
										I2CSRAMPROGRAM_DONE_BIT	! Program DONE bit,
										I2CDISABLE ! Exit the programming mode"	;	
										
	"I2C SRAM Verify Only"	=	"	SVF_I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,  
							I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
							I2CCHECK_PASSWORD ! Check the Password,  
							I2CCHECK_SRAM_READ_LOCK ! Check the SRAM Read Lock,
							I2CVERIFY_CONTROL0	! Verify Control Register0,
							I2CVERIFY_CONTROL1	! Verify Control Register1,
							I2CSRAM_VERIFY	! Verify Fuse Map, 
							I2CVERIFY_USERCODE		! Verify USERCODE, 
		 			 		I2CDISABLE ! Exit the programming mode"	;
							
	"I2C SRAM Erase Only"	=	"	SVF_I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,
							I2CSRAM_ENABLE	! Enable SRAM programming mode, 
							I2CCHECK_PASSWORD ! Check the Password, 
							I2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
							I2CSRAM_ERASE	! Erase the SRAM, 
		 			 		I2CDISABLE ! Exit the programming mode"	;

	"I2C SRAM Verify ID" = 	"SVF_I2CINIT 	! Initialize, 
						 	 I2CREAD_ID ! Check the IDCODE"; 

	"I2C SRAM Program Control Register0" = "SVF_I2CINIT ! Initialize,
								 I2CREAD_ID	! Check the IDCODE,
					 			 I2CSRAM_ENABLE	! Enable SRAM programming mode, 
					             I2CCHECK_PASSWORD ! Check the Password,  
								 I2CPROGRAM_CONTROL0 ! Program Control Register 0,
					             I2CDISABLE";	

	"I2C SRAM Program Control Register1" = "SVF_I2CINIT ! Initialize,
								 I2CREAD_ID	! Check the IDCODE,
					 			 I2CSRAM_ENABLE	! Enable SRAM programming mode, 
					             I2CCHECK_PASSWORD ! Check the Password, 
								 I2CSRAM_PROGRAM_CONTROL1 ! Program Control Register 1,
					             I2CDISABLE";

	"I2C SRAM Verify USERCODE"	=	"SVF_I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE,
									I2CSRAM_TRANSPARENT_READ_ENABLE,
									I2CVERIFY_USERCODE		! Verify USERCODE,
									I2CDISABLE"	; 
																																								
								
	"I2C SRAM Refresh" = " 	SVF_I2CINIT !Initialize,
							I2CREAD_ID !Check the IDCODE,
							I2CREFRESH_FUNCTION ! Refresh";								
	
	
	"I2C SRAM Secure Plus" = "SVF_I2CINIT !Initialize,
						I2CREAD_ID !Check the IDCODE,
						I2CSRAM_ENABLE	! Enable SRAM programming mode, 								             
						I2CCHECK_PASSWORD ! Check the Password,  
						I2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
						I2CSRAM_SECURE ! Secure the SRAM,
						I2CDISABLE";
														
	"I2C SRAM Bypass"	=	"SVF_I2CINIT 	! Initialize";
	
	"JTAGI2C SRAM Fast Configuration" = "SVF_JTAGI2CINIT 	! Initialize,   
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
										JTAGI2CCHECK_PASSWORD ! Check the Password,  
										JTAGI2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
										JTAGI2CSRAM_ERASE	! Erase the SRAM, 
										JTAGI2CBURST_PROGRAM	! Program Fuse Map,
										JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
										JTAGI2CDISABLE ! Exit the programming mode"	;
										
	"JTAGI2C SRAM Erase,Program,Verify" = "NOT_SUPPORTED"	;	
										
	"JTAGI2C SRAM Verify Only"	=	"NOT_SUPPORTED"	;
							
	"JTAGI2C SRAM Erase Only"	=	"	SVF_JTAGI2CINIT 	! Initialize, 
							JTAGI2CREAD_ID	! Check the IDCODE,
							JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
							JTAGI2CCHECK_PASSWORD ! Check the Password, 
							JTAGI2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
							JTAGI2CSRAM_ERASE	! Erase the SRAM, 
		 			 		JTAGI2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C SRAM Verify ID" = 	"SVF_JTAGI2CINIT 	! Initialize, 
						 		 JTAGI2CREAD_ID ! Check the IDCODE"; 

	"JTAGI2C SRAM Program Control Register0" = "SVF_JTAGI2CINIT ! Initialize,
								 JTAGI2CREAD_ID	! Check the IDCODE,
					 			 JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
					             JTAGI2CCHECK_PASSWORD ! Check the Password,  
								 JTAGI2CPROGRAM_CONTROL0 ! Program Control Register 0,
					             JTAGI2CDISABLE";	
	
	"JTAGI2C SRAM Program Control Register1" = "SVF_JTAGI2CINIT ! Initialize,
								 JTAGI2CREAD_ID	! Check the IDCODE,
					 			 JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
					             JTAGI2CCHECK_PASSWORD ! Check the Password, 
								 JTAGI2CSRAM_PROGRAM_CONTROL1 ! Program Control Register 1,
					             JTAGI2CDISABLE";	

	"JTAGI2C SRAM Verify USERCODE"	=	"SVF_JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CSRAM_ENABLE,
									JTAGI2CSRAM_VERIFY_USERCODE		! Verify USERCODE,
									JTAGI2CDISABLE"	; 																
									
	"JTAGI2C SRAM Refresh" = " 	SVF_JTAGI2CINIT !Initialize,
							JTAGI2CREAD_ID !Check the IDCODE,
							JTAGI2CREFRESH_FUNCTION ! Refresh";								
	
	
	"JTAGI2C SRAM Secure Plus" = "SVF_JTAGI2CINIT !Initialize,
						JTAGI2CREAD_ID !Check the IDCODE,
						JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 								             
						JTAGI2CCHECK_PASSWORD ! Check the Password,  
						JTAGI2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
						JTAGI2CSRAM_SECURE ! Secure the SRAM,
						JTAGI2CDISABLE";
														
	"JTAGI2C SRAM Bypass"	=	"SVF_JTAGI2CINIT 	! Initialize";	
	
	"Slave SPI XSRAM SEI Fast Program" 	= "	SVF_SPIINIT 	! Initialize,   
									SPIREAD_ID	! Check the IDCODE,
									SPISRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									SPICHECK_PASSWORD ! Check the Password,  
								 	SPICHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
									SPIBURST_PROGRAM	! Program Fuse Map,
									SPIDISABLE ! Exit the programming mode"	;


	"Slave SPI XSRAM Verify ID" = 	"	SVF_SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE"	; 
		

	"Slave SPI XSRAM Refresh" = "	SVF_SPIINIT 	! Initialize,   
									SPIREAD_ID	! Check the IDCODE,
									SPIREFRESH_FUNCTION ! Refresh" ;

	"Slave SPI XSRAM Bypass"	=	"SVF_SPIINIT 	! Initialize"	;
	
	"I2C XSRAM SEI Fast Program" 	= "SVF_I2CINIT 	! Initialize,   
									I2CREAD_ID	! Check the IDCODE,
									I2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									I2CCHECK_PASSWORD ! Check the Password,  
								 	I2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
									I2CBURST_PROGRAM	! Program Fuse Map,
									I2CDISABLE ! Exit the programming mode"	;


	"I2C XSRAM Verify ID" = 	"SVF_I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE"	; 
	
	"I2C XSRAM Refresh" = "	SVF_I2CINIT 	! Initialize,   
							I2CREAD_ID	! Check the IDCODE,
							I2CREFRESH_FUNCTION ! Refresh" ;

	"I2C XSRAM Bypass"	=	"	SVF_I2CINIT 	! Initialize"	;

	"JTAGI2C XSRAM SEI Fast Program" 	= "	SVF_JTAGI2CINIT 	! Initialize,   
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									JTAGI2CCHECK_PASSWORD ! Check the Password,  
								 	JTAGI2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
									JTAGI2CBURST_PROGRAM	! Program Fuse Map,
									JTAGI2CDISABLE ! Exit the programming mode"	;


	"JTAGI2C XSRAM Verify ID" = 	"SVF_JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE"	; 


	"JTAGI2C XSRAM Display ID" = "JTAGI2CINIT, JTAGI2CREAD_ID, JTAGI2CSAVE_ID";			

	"JTAGI2C XSRAM Refresh" = "SVF_JTAGI2CINIT 	! Initialize,   
							JTAGI2CREAD_ID	! Check the IDCODE,
							JTAGI2CREFRESH_FUNCTION ! Refresh" ;

	"JTAGI2C XSRAM Bypass"	=	"SVF_JTAGI2CINIT 	! Initialize"	;							 
						
	"Slave SPI Program Feature Row" = " SVF_SPIINIT ! Initialize,
	                                  SPIREAD_ID ! Verify ID,
	                                  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_FEA ! Select Feature Row,
	                                  SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  SPICHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  SPIFEATURE_ERASE ! Erase Feature Row,
									  SPICHECK_STATUS ! Read the Status bits,
									  SPIFEATURE_PROGRAM ! Program Verify Feature Row,
									  SPICHECK_STATUS ! Read the Status bits,									  
	                                  SPIDISABLE ! Exit the programming mode"	;                              	

	"Slave SPI Program Feature Row and Lock" = " SVF_SPIINIT ! Initialize,
											  SPIREAD_ID ! Verify ID,
											  SPIFLASH_ENABLE	! Enable the FLASH,
											  SPISELECT_FEA ! Select Feature Row,
											  SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
											  SPICHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
											  SPIFEATURE_ERASE ! Erase Feature Row,
											  SPICHECK_STATUS ! Read the Status bits,
											  SPIFEATURE_PROGRAM ! Program Verify Feature Row,
											  SPICHECK_STATUS ! Read the Status bits,
											  SPIFEA_PROGRAM_SECURITY ! Program Feature Row Security Bits,
											  SPICHECK_STATUS ! Read the Status bits,
											  SPIDISABLE ! Exit the programming mode"	;     

	"Slave SPI Program Feature Row Lock" = " SVF_SPIINIT ! Initialize,
	                                  SPIREAD_ID ! Verify ID,
	                                  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_FEA ! Select Feature Row,
	                                  SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  SPICHECK_PROGRAM_SECURITY ! Check Feature Row Program Security,
									  SPIFEA_PROGRAM_SECURITY ! Program Feature Row Security Bits,
									  SPICHECK_STATUS ! Read the Status bits,
	                                  SPIDISABLE ! Exit the programming mode"	;  
									  	
	
	"Slave SPI Erase Feature Row" = " SVF_SPIINIT ! Initialize,
	                                  SPIREAD_ID ! Verify ID,
	                                  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_FEA ! Select Feature Row,
	                                  SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  SPICHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  SPIFEATURE_ERASE ! Erase Feature Row,
									  SPICHECK_STATUS ! Read the Status bits,
	                                  SPIDISABLE ! Exit the programming mode"	;  
	                                  							  
	"Slave SPI Program Control NV Register1" = " SVF_SPIINIT ! Initialize,
	                                  SPIREAD_ID ! Verify ID,
	                                  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_FEA ! Select Feature Row,
	                                  SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  SPICHECK_READ_SECURITY ! Check Feature Row Read Security,
	                                  SPICHECK_PROGRAM_SECURITY ! Check Feature Row Program Security,
	                                  SPIPROGRAM_CONTROL_NV1 ! Program Control NV Register1,
	                                  SPIDISABLE ! Exit the programming mode"	;                              
	
	"Slave SPI Security Secure Plus" ="SVF_SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,									
									SPICHECK_PASSWORD ! Check Password Protect,
									SPICSEC_PROGRAM_LOCK	! Program sector's lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C Security Secure Plus" ="SVF_I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_PASSWORD ! Check Password Protect,  
									I2CCSEC_PROGRAM_LOCK	! Program sector's lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C Security Secure Plus" ="SVF_JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_PASSWORD ! Check Password Protect,  
										JTAGI2CCSEC_PROGRAM_LOCK	! Program sector's lock,
										JTAGI2CDISABLE	! Exit the programming mode";										
										
	"Slave SPI Security Program Password Key" ="SVF_SPIINIT 	! Initialize, 
										  SPIREAD_ID	! Check the IDCODE, 
										  SPIFLASH_ENABLE	! Enable the FLASH, 
										  SPISELECT_FEA ! Select Feature Sector,
										  SPICHECK_PROGRAM_SECURITY ! Check Feature Row Program Security, 
										  SPIPROG_PASSWORD ! Program Password,
										  SPIDISABLE ! Exit the programming mode" ;	
	
	"Slave SPI Security Program TraceID" = "SVF_SPIINIT 	! Initialize, 
										    SPIREAD_ID	! Check the IDCODE,
										    SPIFLASH_ENABLE	! Enable the programming mode,
										    SPISELECT_FEA ! Select Feature Sector, 		
										    SPICHECK_FEATURE_PASSWORD ! Check the Password, 						  
										    SPICHECK_PROGRAM_SECURITY ! Check the FeatureRow Program Security,
										    SPIPROGRAM_TRACEID ! Program the TraceID,
										    SPIDISABLE ! Exit the programming mode";	
	
	"I2C Program Feature Row" = " SVF_I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
									  I2CSELECT_FEA ! Select Feature Row,
	                                  I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  I2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  I2CFEATURE_ERASE ! Erase Feature Row,
									  I2CFEATURE_PROGRAM ! Program Feature Row,
									  I2CDISABLE_NEW_ADDR  ! Exit the programming mode"	;  
	
	"I2C Program Feature Row and Lock" = " SVF_I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
									  I2CSELECT_FEA ! Select Feature Row,
	                                  I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  I2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  I2CFEATURE_ERASE ! Erase Feature Row,
									  I2CFEATURE_PROGRAM ! Program Feature Row,
									  I2CFEA_PROGRAM_SECURITY_NEW_ADDR ! Program Feature Row Security Bits,
									  I2CDISABLE_NEW_ADDR  ! Exit the programming mode"	; 

	"I2C Program Feature Row Lock" = " SVF_I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
									  I2CSELECT_FEA ! Select Feature Row,
	                                  I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  I2CCHECK_PROGRAM_SECURITY ! Check Feature Row Program Security,
									  I2CFEA_PROGRAM_SECURITY ! Program Feature Row Security Bits,
									  I2CCHECK_STATUS ! Read the Status bits,
	                                  I2CDISABLE ! Exit the programming mode"	; 

	"I2C Erase Feature Row" = " SVF_I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
									  I2CSELECT_FEA ! Select Feature Row,
	                                  I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  I2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  I2CFEATURE_ERASE ! Erase Feature Row,
									  I2CDISABLE_DEFAULT ! Exit the programming mode"	; 									  
									   									 							  
	"I2C Program Control NV Register1" = " SVF_I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
									  I2CSELECT_FEA ! Select Feature Row,
	                                  I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  I2CCHECK_READ_SECURITY ! Check Feature Row Read Security,
	                                  I2CCHECK_PROGRAM_SECURITY ! Check Feature Row Program Security,
	                                  I2CPROGRAM_CONTROL_NV1 ! Program Control NV Register1,
	                                  I2CDISABLE ! Exit the programming mode"	;                              	

	"I2C Security Program Password Key" ="SVF_I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the FLASH, 
								  I2CSELECT_FEA ! Select Feature Sector,
								  I2CCHECK_PROGRAM_SECURITY ! Check Feature Row Program Security, 
								  I2CPROG_PASSWORD ! Program Password,
								  I2CDISABLE ! Exit the programming mode" ;
	
	"I2C Security Program TraceID" = "SVF_I2CINIT 	! Initialize, 
										    I2CREAD_ID	! Check the IDCODE,
										    I2CFLASH_ENABLE	! Enable the programming mode,
										    I2CSELECT_FEA ! Select Feature Sector, 		
										    I2CCHECK_FEATURE_PASSWORD ! Check the Password, 						  
										    I2CCHECK_PROGRAM_SECURITY ! Check the FeatureRow Program Security,
										    I2CPROGRAM_TRACEID ! Program the TraceID,
										    I2CDISABLE ! Exit the programming mode";
	
	"JTAGI2C Program Feature Row" = " SVF_JTAGI2CINIT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
									  JTAGI2CSELECT_FEA ! Select Feature Row,
	                                  JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  JTAGI2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  JTAGI2CFEATURE_ERASE ! Erase Feature Row,
									  JTAGI2CFEATURE_PROGRAM ! Program Feature Row,
									  JTAGI2CDISABLE_NEW_ADDR ! Exit the programming mode"	; 	
									  
	"JTAGI2C Program Feature Row and Lock" = " SVF_JTAGI2CINIT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
									  JTAGI2CSELECT_FEA ! Select Feature Row,
	                                  JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  JTAGI2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  JTAGI2CFEATURE_ERASE ! Erase Feature Row,
									  JTAGI2CFEATURE_PROGRAM ! Program Feature Row,
									  JTAGI2CFEA_PROGRAM_SECURITY_NEW_ADDR ! Program Feature Row Security Bits,
									  JTAGI2CDISABLE_NEW_ADDR ! Exit the programming mode"	; 

	"JTAGI2C Program Feature Row Lock" = " SVF_JTAGI2CINIT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
									  JTAGI2CSELECT_FEA ! Select Feature Row,
	                                  JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  JTAGI2CCHECK_PROGRAM_SECURITY ! Check Feature Row Erase Security,
									  JTAGI2CFEA_PROGRAM_SECURITY ! Program Feature Row Security Bits,
									  JTAGI2CCHECK_STATUS ! Read the Status bits,
	                                  JTAGI2CDISABLE ! Exit the programming mode"	; 

	"JTAGI2C Erase Feature Row" = " SVF_JTAGI2CINIT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
									  JTAGI2CSELECT_FEA ! Select Feature Row,
	                                  JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  JTAGI2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  JTAGI2CFEATURE_ERASE ! Erase Feature Row,
									  JTAGI2CDISABLE ! Exit the programming mode"	;  		
									  
	"JTAGI2C Program Control NV Register1" = " SVF_JTAGI2CINIT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
									  JTAGI2CSELECT_FEA ! Select Feature Row,
	                                  JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  JTAGI2CCHECK_READ_SECURITY ! Check Feature Row Read Security,
	                                  JTAGI2CCHECK_PROGRAM_SECURITY ! Check Feature Row Program Security,
	                                  JTAGI2CPROGRAM_CONTROL_NV1 ! Program Control NV Register1,
	                                  JTAGI2CDISABLE ! Exit the programming mode"	;                              

	"JTAGI2C Security Program Password Key" ="SVF_JTAGI2CINIT 	! Initialize, 
								  JTAGI2CREAD_ID	! Check the IDCODE, 
								  JTAGI2CFLASH_ENABLE	! Enable the FLASH, 
								  JTAGI2CSELECT_FEA ! Select Feature Sector,
								  JTAGI2CCHECK_PROGRAM_SECURITY ! Check Feature Row Program Security, 
								  JTAGI2CPROG_PASSWORD ! Program Password,
								  JTAGI2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Program TraceID" = "SVF_JTAGI2CINIT 	! Initialize, 
										    JTAGI2CREAD_ID	! Check the IDCODE,
										    JTAGI2CFLASH_ENABLE	! Enable the programming mode,
										    JTAGI2CSELECT_FEA ! Select Feature Sector, 		
										    JTAGI2CCHECK_FEATURE_PASSWORD ! Check the Password, 						  
										    JTAGI2CCHECK_PROGRAM_SECURITY ! Check the FeatureRow Program Security,
										    JTAGI2CPROGRAM_TRACEID ! Program the TraceID,
										    JTAGI2CDISABLE ! Exit the programming mode";
	
	"Slave SPI FLASH Erase,Program,Verify" = "SVF_SPIINIT ! Initialize,
											  SPIREAD_ID	! Check the IDCODE,
											  SPIFLASH_ENABLE	! Enable the FLASH,
											  SPIFLASH_PROGRAM_FULL ! Program Flash and UFM,
											  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH Erase,Program,Verify and Lock" = "SVF_SPIINIT ! Initialize,
													  SPIREAD_ID	! Check the IDCODE,
													  SPIFLASH_ENABLE	! Enable the FLASH,
													  SPIFLASH_PROGRAM_FULL ! Program Flash and UFM,
													  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
													  SPICFG_PROGRAM_SECURITY ! Program CFG Security Bits,
													  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
													  SPIUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
													  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH Erase Only" = "SVF_SPIINIT ! Initialize,
									  SPIREAD_ID	! Check the IDCODE,
									  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_CFG ! Select CFG Sector,
									  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
									  SPICFG_ERASE ! ERASE CFG,
									  SPISELECT_UFM ! Select UFM Sector,
									  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
									  SPIUFM_ERASE ! ERASE UFM,
									  SPIDISABLE ! Exit the programming mode"	;  							  
							  
	"Slave SPI FLASH Verify Only" = "SVF_SPIINIT ! Initialize,
									  SPIREAD_ID	! Check the IDCODE,
									  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_CFG ! Select CFG Sector,
									  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
									  SPICFG_VERIFY_FULL ! Verify CFG,
									  SPISELECT_UFM ! Select UFM Sector,
									  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
									  SPIUFM_VERIFY_FULL ! Verify UFM,
									  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH CFG Erase,Program,Verify" = "SVF_SPIINIT ! Initialize,
												  SPIREAD_ID	! Check the IDCODE,
												  SPIFLASH_ENABLE	! Enable the FLASH,
												  SPIFLASH_CFG_PROGRAM_FULL ! Program CFG,
												  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH CFG Erase,Program,Verify and Lock" = "SVF_SPIINIT ! Initialize,
														  SPIREAD_ID	! Check the IDCODE,
														  SPIFLASH_ENABLE	! Enable the FLASH,
														  SPIFLASH_CFG_PROGRAM_FULL ! Program CFG,
														  SPICFG_PROGRAM_SECURITY ! Program CFG Security Bits,
														  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH CFG Erase Only" = "SVF_SPIINIT ! Initialize,
										  SPIREAD_ID	! Check the IDCODE,
										  SPIFLASH_ENABLE	! Enable the FLASH,
										  SPISELECT_CFG ! Select CFG Sector,
										  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
										  SPICFG_ERASE ! ERASE CFG,
										  SPIDISABLE ! Exit the programming mode"	;  
							  
							  
	"Slave SPI FLASH CFG Verify Only" = "SVF_SPIINIT ! Initialize,
										  SPIREAD_ID	! Check the IDCODE,
										  SPIFLASH_ENABLE	! Enable the FLASH,
										  SPISELECT_CFG ! Select CFG Sector,
										  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
										  SPICFG_VERIFY_FULL ! Verify CFG,
										  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH UFM Erase,Program,Verify" = "SVF_SPIINIT ! Initialize,
												  SPIREAD_ID	! Check the IDCODE,
												  SPIFLASH_ENABLE	! Enable the FLASH,
												  SPIFLASH_UFM_PROGRAM_FULL ! Program UFM,
												  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH UFM Erase,Program,Verify and Lock" = "SVF_SPIINIT ! Initialize,
														  SPIREAD_ID	! Check the IDCODE,
														  SPIFLASH_ENABLE	! Enable the FLASH,
														  SPIFLASH_UFM_PROGRAM_FULL ! Program UFM,
														  SPIUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
														  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH UFM Erase Only" = "SVF_SPIINIT ! Initialize,
										  SPIREAD_ID	! Check the IDCODE,
										  SPIFLASH_ENABLE	! Enable the FLASH,
										  SPISELECT_UFM ! Select UFM Sector,
										  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
										  SPIUFM_ERASE ! ERASE CFG,
										  SPIDISABLE ! Exit the programming mode"	;  
							  							  
	"Slave SPI FLASH UFM Verify Only" = "SVF_SPIINIT ! Initialize,
										  SPIREAD_ID	! Check the IDCODE,
										  SPIFLASH_ENABLE	! Enable the FLASH,
										  SPISELECT_UFM ! Select UFM Sector,
										  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
										  SPIUFM_VERIFY_FULL ! Verify UFM,
										  SPIDISABLE ! Exit the programming mode"	;  
									  
	"Slave SPI FLASH Verify ID" = " SVF_SPIINIT ! Initialize,
									SPIREAD_ID ! Verify ID" ;
	                   
	"Slave SPI FLASH Secure" = "SVF_SPIINIT ! Initialize,
								SPIREAD_ID	! Check the IDCODE,
								SPIFLASH_ENABLE	! Enable the FLASH,
								SPICFG_PROGRAM_SECURITY ! Program CFG Security Bits,
								SPIUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
								SPIDISABLE ! Exit the programming mode"	;  
								
	"Slave SPI FLASH Refresh" = " SVF_SPIINIT ! Initialize,
	                    SPIREAD_ID ! Verify ID,
	                    SPIREFRESH_FUNCTION ! Refresh";	
						
	"Slave SPI FLASH Bypass" = " SVF_SPIINIT ! Initialize"; 

	"I2C FLASH Erase,Program,Verify" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH Erase,Program,Verify and Lock" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH Erase Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_ERASE ! ERASE CFG,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_ERASE ! ERASE UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  							  
	"I2C FLASH Verify Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_VERIFY_FULL ! Verify CFG,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_VERIFY_FULL ! Verify UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH CFG Erase,Program,Verify" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH CFG Erase,Program,Verify and Lock" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
							  I2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH CFG Erase Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_ERASE ! ERASE CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"I2C FLASH CFG Verify Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_VERIFY_FULL ! Verify CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH UFM Erase,Program,Verify" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH UFM Erase,Program,Verify and Lock" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
							  I2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH UFM Erase Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_ERASE ! ERASE CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"I2C FLASH UFM Verify Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_VERIFY_FULL ! Verify UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  
									  
	"I2C FLASH Verify ID" = " SVF_I2CINIT ! Initialize,
	                  		I2CREAD_ID ! Verify ID" ;
	                   
	"I2C FLASH Secure" = "SVF_I2CINIT ! Initialize,
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_ENABLE	! Enable the FLASH,
								I2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
								I2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
								I2CDISABLE ! Exit the programming mode"	;
								
	"I2C FLASH Refresh" = " SVF_I2CINIT ! Initialize,
	                    I2CREAD_ID ! Verify ID,
	                    I2CREFRESH_FUNCTION ! Refresh";										  

	"I2C FLASH Bypass" = " SVF_I2CINIT ! Initialize";	
						
	"JTAGI2C FLASH Erase,Program,Verify" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH Erase,Program,Verify and Lock" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH Erase Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_ERASE ! ERASE CFG,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_ERASE ! ERASE UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  							  
	"JTAGI2C FLASH Verify Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_VERIFY_FULL ! Verify CFG,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_VERIFY_FULL ! Verify UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH CFG Erase,Program,Verify" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH CFG Erase,Program,Verify and Lock" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
							  JTAGI2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH CFG Erase Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_ERASE ! ERASE CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"JTAGI2C FLASH CFG Verify Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_VERIFY_FULL ! Verify CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH UFM Erase,Program,Verify" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH UFM Erase,Program,Verify and Lock" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
							  JTAGI2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH UFM Erase Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_ERASE ! ERASE CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"JTAGI2C FLASH UFM Verify Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_VERIFY_FULL ! Verify UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
									  
	"JTAGI2C FLASH Verify ID" = " SVF_JTAGI2CINIT ! Initialize,
	                  		JTAGI2CREAD_ID ! Verify ID" ;
	                   
	"JTAGI2C FLASH Secure" = "SVF_JTAGI2CINIT ! Initialize,
								JTAGI2CREAD_ID	! Check the IDCODE,
								JTAGI2CFLASH_ENABLE	! Enable the FLASH,
								JTAGI2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
								JTAGI2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
								JTAGI2CDISABLE ! Exit the programming mode"	;
								
	"JTAGI2C FLASH Refresh" = " SVF_JTAGI2CINIT ! Initialize,
	                    JTAGI2CREAD_ID ! Verify ID,
	                    JTAGI2CREFRESH_FUNCTION ! Refresh";
						
	"JTAGI2C FLASH Bypass" = " SVF_JTAGI2CINIT ! Initialize";						
	
	"Slave SPI XFLASH Erase,Program,Verify" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPIFLASH_PROGRAM_FULL ! Program Flash and UFM,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH Erase,Program,Verify and Lock" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPIFLASH_PROGRAM_FULL ! Program Flash and UFM,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPICFG_PROGRAM_SECURITY ! Program CFG Security Bits,
							  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  SPIUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH Erase Only" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPICFG_ERASE ! ERASE CFG,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  SPIUFM_ERASE ! ERASE UFM,
	                          SPIDISABLE ! Exit the programming mode"	;  
							  
							  
	"Slave SPI XFLASH Verify Only" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPICFG_VERIFY_FULL ! Verify CFG,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  SPIUFM_VERIFY_FULL ! Verify UFM,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH Program and TransFR" = "SVF_SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPIFLASH_PROGRAM_FULL ! Program CFG and UFM,								
									SPIDISABLE ! Exit the programming mode,									
									SPIREFRESH_FUNCTION ! Refresh,
									SVF_SPIVERIFY_SRAM_DONE_BIT ! Check SRAM Status Register";
	
	"Slave SPI XFLASH TransFR" = "SVF_SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE,
								  SPIREFRESH_FUNCTION ! Refresh";
							  
	"Slave SPI XFLASH CFG Erase,Program,Verify" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPIFLASH_CFG_PROGRAM_FULL ! Program CFG,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH CFG Erase,Program,Verify and Lock" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPIFLASH_CFG_PROGRAM_FULL ! Program CFG,
							  SPICFG_PROGRAM_SECURITY ! Program CFG Security Bits,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH CFG Erase Only" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPICFG_ERASE ! ERASE CFG,
	                          SPIDISABLE ! Exit the programming mode"	;  
							  
							  
	"Slave SPI XFLASH CFG Verify Only" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPICFG_VERIFY_FULL ! Verify CFG,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH UFM Erase,Program,Verify" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPIFLASH_UFM_PROGRAM_FULL ! Program UFM,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH UFM Erase,Program,Verify and Lock" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPIFLASH_UFM_PROGRAM_FULL ! Program UFM,
							  SPIUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH UFM Erase Only" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  SPIUFM_ERASE ! ERASE CFG,
	                          SPIDISABLE ! Exit the programming mode"	;  
							  
							  
	"Slave SPI XFLASH UFM Verify Only" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  SPIUFM_VERIFY_FULL ! Verify UFM,
	                          SPIDISABLE ! Exit the programming mode"	;  
									  
	"Slave SPI XFLASH Verify ID" = " SVF_SPIINIT ! Initialize,
	                  		SPIREAD_ID ! Verify ID" ;
	                   
	"Slave SPI XFLASH Secure" = "SVF_SPIINIT ! Initialize,
								SPIREAD_ID	! Check the IDCODE,
								SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
								SPICFG_PROGRAM_SECURITY ! Program CFG Security Bits,
								SPIUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
								SPIDISABLE ! Exit the programming mode"	;
								
	"Slave SPI XFLASH Refresh" = " SVF_SPIINIT ! Initialize,
	                    SPIREAD_ID ! Verify ID,
	                    SPIREFRESH_FUNCTION ! Refresh";	
						
	"Slave SPI XFLASH Bypass" = " SVF_SPIINIT ! Initialize"; 
						
	"I2C XFLASH Erase,Program,Verify" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH Erase,Program,Verify and Lock" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH Erase Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_ERASE ! ERASE CFG,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_ERASE ! ERASE UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"I2C XFLASH Verify Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_VERIFY_FULL ! Verify CFG,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_VERIFY_FULL ! Verify UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  
	"I2C XFLASH Program and TransFR" = "SVF_I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									I2CFLASH_PROGRAM_FULL ! Program CFG and UFM,								
									I2CDISABLE_REFRESH ! Refresh";
	
	"I2C XFLASH TransFR" = "SVF_I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE,
								  I2CREFRESH_FUNCTION ! Refresh";

	"I2C XFLASH CFG Erase,Program,Verify" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH CFG Erase,Program,Verify and Lock" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
							  I2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH CFG Erase Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_ERASE ! ERASE CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"I2C XFLASH CFG Verify Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_VERIFY_FULL ! Verify CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH UFM Erase,Program,Verify" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH UFM Erase,Program,Verify and Lock" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
							  I2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH UFM Erase Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_ERASE ! ERASE CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"I2C XFLASH UFM Verify Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_VERIFY_FULL ! Verify UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  
									  
	"I2C XFLASH Verify ID" = " SVF_I2CINIT ! Initialize,
	                  		I2CREAD_ID ! Verify ID" ;
	                   
	"I2C XFLASH Secure" = "SVF_I2CINIT ! Initialize,
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
								I2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
								I2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
								I2CDISABLE ! Exit the programming mode"	;
								
	"I2C XFLASH Refresh" = " SVF_I2CINIT ! Initialize,
	                    I2CREAD_ID ! Verify ID,
	                    I2CREFRESH_FUNCTION ! Refresh";										  

	"I2C XFLASH Bypass" = " SVF_I2CINIT ! Initialize";	
													     
	"JTAGI2C XFLASH Erase,Program,Verify" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH Erase,Program,Verify and Lock" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH Erase Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_ERASE ! ERASE CFG,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_ERASE ! ERASE UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"JTAGI2C XFLASH Verify Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_VERIFY_FULL ! Verify CFG,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_VERIFY_FULL ! Verify UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  
	"JTAGI2C XFLASH Program and TransFR" = "SVF_JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									JTAGI2CFLASH_PROGRAM_FULL ! Program CFG and UFM,											
									JTAGI2CDISABLE_REFRESH ! Refresh";
	
	"JTAGI2C XFLASH TransFR" = "SVF_JTAGI2CINIT 	! Initialize, 
								  JTAGI2CREAD_ID	! Check the IDCODE,
								  JTAGI2CREFRESH_FUNCTION ! Refresh";

	"JTAGI2C XFLASH CFG Erase,Program,Verify" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH CFG Erase,Program,Verify and Lock" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
							  JTAGI2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH CFG Erase Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_ERASE ! ERASE CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"JTAGI2C XFLASH CFG Verify Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_VERIFY_FULL ! Verify CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH UFM Erase,Program,Verify" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH UFM Erase,Program,Verify and Lock" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
							  JTAGI2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH UFM Erase Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_ERASE ! ERASE CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"JTAGI2C XFLASH UFM Verify Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_VERIFY_FULL ! Verify UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
									  
	"JTAGI2C XFLASH Verify ID" = " SVF_JTAGI2CINIT ! Initialize,
	                  		JTAGI2CREAD_ID ! Verify ID" ;
	                   
	"JTAGI2C XFLASH Secure" = "SVF_JTAGI2CINIT ! Initialize,
								JTAGI2CREAD_ID	! Check the IDCODE,
								JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
								JTAGI2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
								JTAGI2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
								JTAGI2CDISABLE ! Exit the programming mode"	;
								
	"JTAGI2C XFLASH Refresh" = " SVF_JTAGI2CINIT ! Initialize,
	                    JTAGI2CREAD_ID ! Verify ID,
	                    JTAGI2CREFRESH_FUNCTION ! Refresh";
						
	"JTAGI2C XFLASH Bypass" = " SVF_JTAGI2CINIT ! Initialize";						 					 			 		              	 		     
</Operation_List>
<Operation_List label="TurboOperation">
					                
	"Bypass" = "INIT ! Initialize"	;
	                        							
</Operation_List>
<Operation_List label="ChainSVFOperation">
	
	"Bypass" = "SVFINIT ! Initialize" ;
						 				 		     
</Operation_List>
<Operation_List label="SingleSVFOperationRevC">
	"Bypass" = "INIT 	! Initialize"	;
			
	"Slave SPI Disable Only" = "SPIINIT 	! Initialize, 
	 			 				SPIDISABLE ! Exit the programming mode"	;
								
	"Slave SPI Enable Only" = "SPIINIT 	! Initialize, 
						   	   SPIREAD_ID	! Check the IDCODE,
						  	   SPISRAM_ENABLE	! Enable PROGRAM mode"	;
							   
	"Slave SPI Re-Initialize" = "SPIINIT 	! Initialize,  
							 SPIREAD_ID	! Check the IDCODE,
						  	 SPISRAM_ENABLE	! Enable programming mode, 
							 SPISRAM_ERASE	! Erase the device, 
							 SPIDISABLE ! Exit the programming mode"	;	
	"Slave SPI SRAM Fast Configuration" = "SVF_SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE,								 
											SPISRAM_ENABLE	! Enable programming mode,
											SPICHECK_PASSWORD ! Check Password Protect,
											SPICHECK_ERASE_SECURITY ! Check Erase Security,
											SPISRAM_ERASE	! Erase the device, 
											SPIBURST_PROGRAM	! Program Fuse Map,
											SPISRAM_VERIFY_USERCODE		! Verify USERCODE,
											SPIDISABLE ! Exit the programming mode"	;			
				 			 															
	"Slave SPI SRAM Erase,Program,Verify" =   "SVF_SPIINIT 	! Initialize, 
												SPIREAD_ID	! Check the IDCODE, 
												SPISRAM_ENABLE	! Enable the SRAM,
												SPICHECK_PASSWORD ! Check Password Protect,
												SPICHECK_ERASE_SECURITY ! Check Erase Security,
												SPISRAM_ERASE	! Erase the device,
												SPIPROGRAM_CONTROL0	! Program Control Register,
												SPIPROGRAM_CONTROL1	! Program Control Register,
												SPISRAM_PROGRAM	! Program SRAM,
												SPISRAM_VERIFY	! Verify CFG,									
												SPISRAM_PROGRAM_USERCODE	! Program USERCODE,
												SPIVERIFY_USERCODE		! Verify USERCODE,																		
												SPISRAMPROGRAM_DONE_BIT	! Program DONE bit,	
												SPIDISABLE ! Exit the programming mode"	;		 			 		
				 			 					 			 		
	"Slave SPI SRAM Verify Only" = 	"SVF_SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPISRAM_TRANSPARENT_READ_ENABLE	! Enable the SRAM,
									SPICHECK_PASSWORD ! Check Password Protect,
									SPICHECK_READ_SECURITY ! Check Read Security,
									SPIVERIFY_CONTROL0 ! Verify Control Register,
									SPIVERIFY_CONTROL1 ! Verify Control Register,
									SPISRAM_VERIFY	! Verify the SRAM, 
									SPIVERIFY_USERCODE	! Verify USERCODE, 
									SPIDISABLE ! Exit the programming mode";
							
	"Slave SPI SRAM Erase Only"	=		"SVF_SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPISRAM_ENABLE	! Enable programming mode,
										SPICHECK_PASSWORD ! Check Password Protect,
										SPICHECK_ERASE_SECURITY ! Check Erase Security,
										SPISRAM_ERASE	! Erase the device, 
										SPIDISABLE ! Exit the programming mode"	;	
										   
	"Slave SPI SRAM Verify ID" = "SVF_SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE";
				   
	"Slave SPI SRAM Program Control Register0" 	= "SVF_SPIINIT ! Initialize,
												   SPIREAD_ID	! Check the IDCODE,
												   SPISRAM_ENABLE	! Enable the SRAM,
												   SPICHECK_PASSWORD ! Check Password Protect,
												   SPIPROGRAM_CONTROL0	! Program Control Register,
												   SPIDISABLE ! Exit the programming mode";	
	
	"Slave SPI SRAM Program Control Register1" 		= "SVF_SPIINIT ! Initialize,
													   SPIREAD_ID	! Check the IDCODE,
													   SPISRAM_ENABLE	! Enable the SRAM,
													   SPICHECK_PASSWORD ! Check Password Protect,
													   SPISRAM_PROGRAM_CONTROL1	! Program Control Register,
													   SPIDISABLE ! Exit the programming mode";		

	"Slave SPI SRAM Verify USERCODE" =   "SVF_SPIINIT, 
										 SPIREAD_ID, 
										 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable the SRAM,
										 SPIVERIFY_USERCODE	! Verify USERCODE,
										 SPIDISABLE ! Exit the programming mode";
	
	"Slave SPI SRAM Secure Plus" = "SVF_SPIINIT !Initialize,
									SPIREAD_ID !Check the IDCODE,
									SPISRAM_ENABLE	! Enable SRAM programming mode, 								             
									SPICHECK_PASSWORD ! Check the Password,  
									SPICHECK_PROGRAM_SECURITY ! Check the SRAM Program Security,
									SPISRAM_SECURE ! Secure the SRAM,
									SPIDISABLE";
	
	"Slave SPI SRAM Refresh" = " 	SVF_SPIINIT ! Initialize,
									SPIREAD_ID,
									SPIREFRESH_FUNCTION ! Refresh";
					
	"Slave SPI SRAM Bypass"	=	"SVF_SPIINIT 	! Initialize";						

	"I2C SRAM Fast Configuration" = "SVF_I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,								 
										I2CSRAM_ENABLE	! Enable programming mode,
										I2CCHECK_PASSWORD ! Check Password Protect,
										I2CCHECK_ERASE_SECURITY ! Check Erase Security,
										I2CSRAM_ERASE	! Erase the device, 
										I2CBURST_PROGRAM	! Program Fuse Map,
										I2CSRAM_VERIFY_USERCODE		! Verify USERCODE,
										I2CDISABLE ! Exit the programming mode";			
				 			 																				
	"I2C SRAM Erase,Program,Verify" =   "SVF_I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CSRAM_ENABLE	! Enable the SRAM,
									I2CCHECK_PASSWORD ! Check Password Protect,
									I2CCHECK_ERASE_SECURITY ! Check Erase Security,
									I2CSRAM_ERASE	! Erase the device,
									I2CPROGRAM_CONTROL0	! Program Control Register,
									I2CPROGRAM_CONTROL1	! Program Control Register,
				 			 		I2CSRAM_PROGRAM	! Program SRAM,			
									I2CSRAM_PROGRAM_USERCODE	! Program USERCODE,
									I2CSRAM_VERIFY	! Verify CFG,						
									I2CVERIFY_USERCODE		! Verify USERCODE,																		
									I2CSRAMPROGRAM_DONE_BIT	! Program DONE bit,	
				 			 		I2CDISABLE ! Exit the programming mode";		 			 		
				 			 					 			 		
	"I2C SRAM Verify Only" = 	"SVF_I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE, 
							I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable the SRAM,
							I2CCHECK_PASSWORD ! Check Password Protect,
							I2CCHECK_READ_SECURITY ! Check Read Security,
							I2CVERIFY_CONTROL0 ! Verify Control Register,
							I2CVERIFY_CONTROL1 ! Verify Control Register,
							I2CSRAM_VERIFY	! Verify the SRAM, 
							I2CVERIFY_USERCODE	! Verify USERCODE, 
							I2CDISABLE ! Exit the programming mode";
		
	"I2C SRAM Erase Only"	=		"SVF_I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CSRAM_ENABLE	! Enable programming mode,
								I2CCHECK_PASSWORD ! Check Password Protect,
								I2CCHECK_ERASE_SECURITY ! Check Erase Security,
								I2CSRAM_ERASE	! Erase the device, 
								I2CDISABLE ! Exit the programming mode";
										   
	"I2C SRAM Verify ID" = "SVF_I2CINIT 	! Initialize, 
				   I2CREAD_ID	! Check the IDCODE";
				   
	"I2C SRAM Program Control Register0" 	= "SVF_I2CINIT ! Initialize,
							     		   I2CREAD_ID	! Check the IDCODE,
										   I2CSRAM_ENABLE	! Enable the SRAM,
										   I2CCHECK_PASSWORD ! Check Password Protect,
										   I2CPROGRAM_CONTROL0	! Program Control Register,
										   I2CDISABLE ! Exit the programming mode";	
										   
	"I2C SRAM Program Control Register1" 		= "SVF_I2CINIT ! Initialize,
											   I2CREAD_ID	! Check the IDCODE,
											   I2CSRAM_ENABLE	! Enable the SRAM,
											   I2CCHECK_PASSWORD ! Check Password Protect,
											   I2CSRAM_PROGRAM_CONTROL1	! Program Control Register,
											   I2CDISABLE ! Exit the programming mode";	
											   
	"I2C SRAM Verify USERCODE" =     "SVF_I2CINIT, 
								 I2CREAD_ID, 
								 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable the SRAM,
								 I2CVERIFY_USERCODE	! Verify USERCODE,
								 I2CDISABLE ! Exit the programming mode";
	
	"I2C SRAM Secure Plus" = "SVF_I2CINIT !Initialize,
								I2CREAD_ID !Check the IDCODE,
								I2CSRAM_ENABLE	! Enable SRAM programming mode, 								             
								I2CCHECK_PASSWORD ! Check the Password,  
								I2CCHECK_PROGRAM_SECURITY ! Check the SRAM Program Security,
								I2CSRAM_SECURE ! Secure the SRAM,
								I2CDISABLE";
							 
	"I2C SRAM Refresh" = " 	SVF_I2CINIT ! Initialize,
					I2CREAD_ID,
					I2CREFRESH_FUNCTION ! Refresh";
					
	"I2C SRAM Bypass"	=	"SVF_I2CINIT 	! Initialize";						

	"JTAGI2C SRAM Fast Configuration" = "SVF_JTAGI2CINIT 	! Initialize, 
								JTAGI2CREAD_ID	! Check the IDCODE,								 
								JTAGI2CSRAM_ENABLE	! Enable programming mode,
								JTAGI2CCHECK_PASSWORD ! Check Password Protect,
								JTAGI2CCHECK_ERASE_SECURITY ! Check Erase Security,
								JTAGI2CSRAM_ERASE	! Erase the device, 
								JTAGI2CBURST_PROGRAM	! Program Fuse Map,
								JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
								JTAGI2CDISABLE ! Exit the programming mode"	;			
				 			 																						
	"JTAGI2C SRAM Erase,Program,Verify" =   "SVF_JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CSRAM_ENABLE	! Enable the SRAM,
									JTAGI2CCHECK_PASSWORD ! Check Password Protect,
									JTAGI2CCHECK_ERASE_SECURITY ! Check Erase Security,
									JTAGI2CSRAM_ERASE	! Erase the device,
									JTAGI2CPROGRAM_CONTROL0	! Program Control Register,
									JTAGI2CPROGRAM_CONTROL1	! Program Control Register,
				 			 		JTAGI2CSRAM_PROGRAM	! Program SRAM,			
									JTAGI2CSRAM_PROGRAM_USERCODE	! Program USERCODE,
									JTAGI2CSRAM_VERIFY	! Verify CFG,						
									JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																		
									JTAGI2CSRAMPROGRAM_DONE_BIT	! Program DONE bit,	
				 			 		JTAGI2CDISABLE ! Exit the programming mode"	;		 			 		
				 			 					 			 		
	"JTAGI2C SRAM Verify Only" = 	"SVF_JTAGI2CINIT 	! Initialize, 
							JTAGI2CREAD_ID	! Check the IDCODE, 
							JTAGI2CSRAM_ENABLE	! Enable the SRAM,
							JTAGI2CCHECK_PASSWORD ! Check Password Protect,
							JTAGI2CCHECK_READ_SECURITY ! Check Read Security,
							JTAGI2CVERIFY_CONTROL0 ! Verify Control Register,
							JTAGI2CVERIFY_CONTROL1 ! Verify Control Register,
							JTAGI2CSRAM_VERIFY	! Verify the SRAM, 
							JTAGI2CVERIFY_USERCODE	! Verify USERCODE, 
							JTAGI2CDISABLE ! Exit the programming mode";

	"JTAGI2C SRAM Erase Only"	=		"SVF_JTAGI2CINIT 	! Initialize, 
								JTAGI2CREAD_ID	! Check the IDCODE,
								JTAGI2CSRAM_ENABLE	! Enable programming mode,
								JTAGI2CCHECK_PASSWORD ! Check Password Protect,
								JTAGI2CCHECK_ERASE_SECURITY ! Check Erase Security,
								JTAGI2CSRAM_ERASE	! Erase the device, 
								JTAGI2CDISABLE ! Exit the programming mode"	;	
										   
	"JTAGI2C SRAM Verify ID" = "SVF_JTAGI2CINIT 	! Initialize, 
				   JTAGI2CREAD_ID	! Check the IDCODE";
				   
	"JTAGI2C SRAM Program Control Register0" 	= "SVF_JTAGI2CINIT ! Initialize,
							     		   JTAGI2CREAD_ID	! Check the IDCODE,
										   JTAGI2CSRAM_ENABLE	! Enable the SRAM,
										   JTAGI2CCHECK_PASSWORD ! Check Password Protect,
										   JTAGI2CPROGRAM_CONTROL0	! Program Control Register,
										   JTAGI2CDISABLE ! Exit the programming mode";	
										   
	"JTAGI2C SRAM Program Control Register1" 		= "SVF_JTAGI2CINIT ! Initialize,
											   JTAGI2CREAD_ID	! Check the IDCODE,
											   JTAGI2CSRAM_ENABLE	! Enable the SRAM,
											   JTAGI2CCHECK_PASSWORD ! Check Password Protect,
											   JTAGI2CSRAM_PROGRAM_CONTROL1	! Program Control Register,
											   JTAGI2CDISABLE ! Exit the programming mode";	

	"JTAGI2C SRAM Verify USERCODE" =     "SVF_JTAGI2CINIT, 
								 JTAGI2CREAD_ID, 
							     JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable the SRAM,
								 JTAGI2CCHECK_READ_SECURITY ! Check Read Security,
								 JTAGI2CSRAM_VERIFY_USERCODE	! Verify USERCODE,
								 JTAGI2CDISABLE ! Exit the programming mode";
	
	"JTAGI2C SRAM Secure Plus" = "SVF_JTAGI2CINIT !Initialize,
								JTAGI2CREAD_ID !Check the IDCODE,
								JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 								             
								JTAGI2CCHECK_PASSWORD ! Check the Password,  
								JTAGI2CCHECK_PROGRAM_SECURITY ! Check the SRAM Program Security,
								JTAGI2CSRAM_SECURE ! Secure the SRAM,
								JTAGI2CDISABLE";
						
	"JTAGI2C SRAM Refresh" = " 	SVF_JTAGI2CINIT ! Initialize,
					JTAGI2CREAD_ID,
					JTAGI2CREFRESH_FUNCTION ! Refresh";
					
	"JTAGI2C SRAM Bypass"	=	"SVF_JTAGI2CINIT 	! Initialize";						
	
	"Slave SPI XSRAM SEI Fast Program" 	= "	SVF_SPIINIT 	! Initialize,   
									SPIREAD_ID	! Check the IDCODE,
								    SPISRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable the SRAM,
									SPICHECK_PASSWORD ! Check the Password,  
								 	SPICHECK_PROGRAM_SECURITY ! Check Program Security,
									SPIBURST_PROGRAM	! Program Fuse Map,
									SPIDISABLE ! Exit the programming mode"	;	
	
	"Slave SPI XSRAM Verify ID" = "SVF_SPIINIT 	! Initialize, 
				   		 SPIREAD_ID	! Check the IDCODE";
	
	"Slave SPI XSRAM Refresh" =      "SVF_SPIINIT ! Initialize,
							SPIREAD_ID,
							SPIREFRESH_FUNCTION ! Refresh";
							
	"Slave SPI XSRAM Bypass"	=	"	SVF_SPIINIT 	! Initialize"	;
								
	"I2C XSRAM SEI Fast Program" 	= "	SVF_I2CINIT 	! Initialize,   
									I2CREAD_ID	! Check the IDCODE,
								    I2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable the SRAM,
									I2CCHECK_PASSWORD ! Check the Password,  
								 	I2CCHECK_PROGRAM_SECURITY ! Check Program Security,
									I2CBURST_PROGRAM	! Program Fuse Map,
									I2CDISABLE ! Exit the programming mode"	;	
	
	"I2C XSRAM Verify ID" = "SVF_I2CINIT 	! Initialize, 
				   		 I2CREAD_ID	! Check the IDCODE";
	
	"I2C XSRAM Refresh" =      "SVF_I2CINIT ! Initialize,
							I2CREAD_ID,
							I2CREFRESH_FUNCTION ! Refresh";
							
	"I2C XSRAM Bypass"	=	"	SVF_I2CINIT 	! Initialize"	;							
	
	"JTAGI2C XSRAM SEI Fast Program" 	= "	SVF_JTAGI2CINIT 	! Initialize,   
									JTAGI2CREAD_ID	! Check the IDCODE,
								    JTAGI2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable the SRAM,
									JTAGI2CCHECK_PASSWORD ! Check the Password,  
								 	JTAGI2CCHECK_PROGRAM_SECURITY ! Check Program Security,
									JTAGI2CBURST_PROGRAM	! Program Fuse Map,
									JTAGI2CDISABLE ! Exit the programming mode"	;	
	
	"JTAGI2C XSRAM Verify ID" = "SVF_JTAGI2CINIT 	! Initialize, 
				   		 JTAGI2CREAD_ID	! Check the IDCODE";
	
	"JTAGI2C XSRAM Refresh" =      "SVF_JTAGI2CINIT ! Initialize,
									JTAGI2CREAD_ID,
									JTAGI2CREFRESH_FUNCTION ! Refresh";
							
	"JTAGI2C XSRAM Bypass"	=	"	SVF_JTAGI2CINIT 	! Initialize"	;								 
						
	"Slave SPI Program Feature Row" = " SVF_SPIINIT ! Initialize,
	                                  SPIREAD_ID ! Verify ID,
	                                  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_FEA ! Select Feature Row,
	                                  SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  SPICHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  SPIFEATURE_ERASE ! Erase Feature Row,
									  SPICHECK_STATUS ! Read the Status bits,
									  SPIFEATURE_PROGRAM ! Program Verify Feature Row,
									  SPICHECK_STATUS ! Read the Status bits,
	                                  SPIDISABLE ! Exit the programming mode"	;                              
	
	"Slave SPI Program Feature Row and Lock" = " SVF_SPIINIT ! Initialize,
											  SPIREAD_ID ! Verify ID,
											  SPIFLASH_ENABLE	! Enable the FLASH,
											  SPISELECT_FEA ! Select Feature Row,
											  SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
											  SPICHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
											  SPIFEATURE_ERASE ! Erase Feature Row,
											  SPICHECK_STATUS ! Read the Status bits,
											  SPIFEATURE_PROGRAM ! Program Verify Feature Row,
											  SPICHECK_STATUS ! Read the Status bits,
											  SPIFEA_PROGRAM_SECURITY ! Program Feature Row Security Bits,
											  SPICHECK_STATUS ! Read the Status bits,
											  SPIDISABLE ! Exit the programming mode"	;     

	"Slave SPI Program Feature Row Lock" = " SVF_SPIINIT ! Initialize,
	                                  SPIREAD_ID ! Verify ID,
	                                  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_FEA ! Select Feature Row,
	                                  SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  SPICHECK_PROGRAM_SECURITY ! Check Feature Row Program Security,
									  SPIFEA_PROGRAM_SECURITY ! Program Feature Row Security Bits,
									  SPICHECK_STATUS ! Read the Status bits,
	                                  SPIDISABLE ! Exit the programming mode"	;  
									  
	"Slave SPI Erase Feature Row" = " SVF_SPIINIT ! Initialize,
	                                  SPIREAD_ID ! Verify ID,
	                                  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_FEA ! Select Feature Row,
	                                  SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  SPICHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  SPIFEATURE_ERASE ! Erase Feature Row,
									  SPICHECK_STATUS ! Read the Status bits,
	                                  SPIDISABLE ! Exit the programming mode"	;  
									  
	"Slave SPI Program Control NV Register1" = " SVF_SPIINIT ! Initialize,
	                                  SPIREAD_ID ! Verify ID,
	                                  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_FEA ! Select Feature Row,
	                                  SPICHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  SPICHECK_READ_SECURITY ! Check Feature Row Read Security,
	                                  SPICHECK_PROGRAM_SECURITY ! Check Feature Row Program Security,
	                                  SPICHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  SPIPROGRAM_CONTROL_NV1 ! Program Control NV Register1,
	                                  SPIDISABLE ! Exit the programming mode"	;                              

	"Slave SPI Security Secure Plus" ="SVF_SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,									
									SPICHECK_PASSWORD ! Check Password Protect,
									SPICSEC_PROGRAM_LOCK	! Program sector's lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C Security Secure Plus" ="SVF_I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_PASSWORD ! Check Password Protect,  
									I2CCSEC_PROGRAM_LOCK	! Program sector's lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C Security Secure Plus" ="SVF_JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_PASSWORD ! Check Password Protect,  
										JTAGI2CCSEC_PROGRAM_LOCK	! Program sector's lock,
										JTAGI2CDISABLE	! Exit the programming mode";	
										
	"Slave SPI Security Program Password Key" ="SVF_SPIINIT 	! Initialize, 
										  SPIREAD_ID	! Check the IDCODE, 
										  SPIFLASH_ENABLE	! Enable the FLASH, 
										  SPISELECT_FEA ! Select Feature Sector,
										  SPICHECK_PROGRAM_SECURITY ! Check Feature Row Program Security, 
										  SPIPROG_PASSWORD ! Program Password,
										  SPIDISABLE ! Exit the programming mode" ;

	"Slave SPI Security Program TraceID" = "SVF_SPIINIT 	! Initialize, 
										    SPIREAD_ID	! Check the IDCODE,
										    SPIFLASH_ENABLE	! Enable the programming mode,
										    SPISELECT_FEA ! Select Feature Sector, 		
										    SPICHECK_FEATURE_PASSWORD ! Check the Password, 						  
										    SPICHECK_PROGRAM_SECURITY ! Check the FeatureRow Program Security,
										    SPIPROGRAM_TRACEID ! Program the TraceID,
										    SPIDISABLE ! Exit the programming mode";
	
	"I2C Program Feature Row" = " SVF_I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
									  I2CSELECT_FEA ! Select Feature Row,
	                                  I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  I2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  I2CFEATURE_ERASE ! Erase Feature Row,
									  I2CFEATURE_PROGRAM ! Program Feature Row,
									  I2CDISABLE_NEW_ADDR  ! Exit the programming mode"	;  

	"I2C Program Feature Row and Lock" = " SVF_I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
									  I2CSELECT_FEA ! Select Feature Row,
	                                  I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  I2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  I2CFEATURE_ERASE ! Erase Feature Row,
									  I2CCHECK_STATUS_DEFAULT ! Read the Status bits,
									  I2CFEATURE_PROGRAM ! Program Feature Row,
									  I2CFEA_PROGRAM_SECURITY_NEW_ADDR ! Program Feature Row Security Bits,
									  I2CDISABLE_NEW_ADDR  ! Exit the programming mode"	; 

	"I2C Program Feature Row Lock" = " SVF_I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
									  I2CSELECT_FEA ! Select Feature Row,
	                                  I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  I2CCHECK_PROGRAM_SECURITY ! Check Feature Row Program Security,
									  I2CFEA_PROGRAM_SECURITY ! Program Feature Row Security Bits,
									  I2CCHECK_STATUS ! Read the Status bits,
	                                  I2CDISABLE ! Exit the programming mode"	; 

	"I2C Erase Feature Row" = " SVF_I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
									  I2CSELECT_FEA ! Select Feature Row,
	                                  I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  I2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  I2CFEATURE_ERASE ! Erase Feature Row,
									  I2CCHECK_STATUS_DEFAULT ! Read the Status bits,
									  I2CDISABLE_DEFAULT ! Exit the programming mode"	; 
									  
	"I2C Program Control NV Register1" = " SVF_I2CINIT ! Initialize,
	                                  I2CREAD_ID ! Verify ID,
	                                  I2CFLASH_ENABLE	! Enable the FLASH,
									  I2CSELECT_FEA ! Select Feature Row,
	                                  I2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  I2CCHECK_READ_SECURITY ! Check Feature Row Read Security,
	                                  I2CCHECK_PROGRAM_SECURITY ! Check Feature Row Program Security,
	                                  I2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  I2CPROGRAM_CONTROL_NV1 ! Program Control NV Register1,
	                                  I2CDISABLE ! Exit the programming mode"	;                              

	"I2C Security Program Password Key" ="SVF_I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the FLASH, 
								  I2CSELECT_FEA ! Select Feature Sector,
								  I2CCHECK_PROGRAM_SECURITY ! Check Feature Row Program Security, 
								  I2CPROG_PASSWORD ! Program Password,
								  I2CDISABLE ! Exit the programming mode" ;

	"I2C Security Program TraceID" = "SVF_I2CINIT 	! Initialize, 
										    I2CREAD_ID	! Check the IDCODE,
										    I2CFLASH_ENABLE	! Enable the programming mode,
										    I2CSELECT_FEA ! Select Feature Sector, 		
										    I2CCHECK_FEATURE_PASSWORD ! Check the Password, 						  
										    I2CCHECK_PROGRAM_SECURITY ! Check the FeatureRow Program Security,
										    I2CPROGRAM_TRACEID ! Program the TraceID,
										    I2CDISABLE ! Exit the programming mode";
	
	"JTAGI2C Program Feature Row" = " SVF_JTAGI2CINIT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
									  JTAGI2CSELECT_FEA ! Select Feature Row,
	                                  JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  JTAGI2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  JTAGI2CFEATURE_ERASE ! Erase Feature Row,
									  JTAGI2CFEATURE_PROGRAM ! Program Feature Row,
									  JTAGI2CDISABLE_NEW_ADDR ! Exit the programming mode"	; 

	"JTAGI2C Program Feature Row and Lock" = " SVF_JTAGI2CINIT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
									  JTAGI2CSELECT_FEA ! Select Feature Row,
	                                  JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  JTAGI2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  JTAGI2CFEATURE_ERASE ! Erase Feature Row,
									  JTAGI2CFEATURE_PROGRAM ! Program Feature Row,
									  JTAGI2CFEA_PROGRAM_SECURITY_NEW_ADDR ! Program Feature Row Security Bits,
									  JTAGI2CDISABLE_NEW_ADDR ! Exit the programming mode"	; 

	"JTAGI2C Program Feature Row Lock" = " SVF_JTAGI2CINIT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
									  JTAGI2CSELECT_FEA ! Select Feature Row,
	                                  JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  JTAGI2CCHECK_PROGRAM_SECURITY ! Check Feature Row Erase Security,
									  JTAGI2CFEA_PROGRAM_SECURITY ! Program Feature Row Security Bits,
									  JTAGI2CCHECK_STATUS ! Read the Status bits,
	                                  JTAGI2CDISABLE ! Exit the programming mode"	; 

	"JTAGI2C Erase Feature Row" = " SVF_JTAGI2CINIT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
									  JTAGI2CSELECT_FEA ! Select Feature Row,
	                                  JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  JTAGI2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  JTAGI2CFEATURE_ERASE ! Erase Feature Row,
									  JTAGI2CDISABLE ! Exit the programming mode"	;  		
									  
	"JTAGI2C Program Control NV Register1" = " SVF_JTAGI2CINIT ! Initialize,
	                                  JTAGI2CREAD_ID ! Verify ID,
	                                  JTAGI2CFLASH_ENABLE	! Enable the FLASH,
									  JTAGI2CSELECT_FEA ! Select Feature Row,
	                                  JTAGI2CCHECK_FEATURE_PASSWORD ! Check Feature Row Password Protect,
	                                  JTAGI2CCHECK_READ_SECURITY ! Check Feature Row Read Security,
	                                  JTAGI2CCHECK_PROGRAM_SECURITY ! Check Feature Row Program Security,
	                                  JTAGI2CCHECK_ERASE_SECURITY ! Check Feature Row Erase Security,
									  JTAGI2CPROGRAM_CONTROL_NV1 ! Program Control NV Register1,
	                                  JTAGI2CDISABLE ! Exit the programming mode"	;                              

	"JTAGI2C Security Program Password Key" ="SVF_JTAGI2CINIT 	! Initialize, 
								  JTAGI2CREAD_ID	! Check the IDCODE, 
								  JTAGI2CFLASH_ENABLE	! Enable the FLASH, 
								  JTAGI2CSELECT_FEA ! Select Feature Sector,
								  JTAGI2CCHECK_PROGRAM_SECURITY ! Check Feature Row Program Security, 
								  JTAGI2CPROG_PASSWORD ! Program Password,
								  JTAGI2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Program TraceID" = "SVF_JTAGI2CINIT 	! Initialize, 
										    JTAGI2CREAD_ID	! Check the IDCODE,
										    JTAGI2CFLASH_ENABLE	! Enable the programming mode,
										    JTAGI2CSELECT_FEA ! Select Feature Sector, 		
										    JTAGI2CCHECK_FEATURE_PASSWORD ! Check the Password, 						  
										    JTAGI2CCHECK_PROGRAM_SECURITY ! Check the FeatureRow Program Security,
										    JTAGI2CPROGRAM_TRACEID ! Program the TraceID,
										    JTAGI2CDISABLE ! Exit the programming mode";
	
	"Slave SPI FLASH Erase,Program,Verify" = "SVF_SPIINIT ! Initialize,
											  SPIREAD_ID	! Check the IDCODE,
											  SPIFLASH_ENABLE	! Enable the FLASH,
											  SPIFLASH_PROGRAM_FULL ! Program Flash and UFM,
											  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH Erase,Program,Verify and Lock" = "SVF_SPIINIT ! Initialize,
													  SPIREAD_ID	! Check the IDCODE,
													  SPIFLASH_ENABLE	! Enable the FLASH,
													  SPIFLASH_PROGRAM_FULL ! Program Flash and UFM,
													  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
													  SPICFG_PROGRAM_SECURITY ! Program CFG Security Bits,
													  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
													  SPIUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
													  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH Erase Only" = "SVF_SPIINIT ! Initialize,
									  SPIREAD_ID	! Check the IDCODE,
									  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_CFG ! Select CFG Sector,
									  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
									  SPICFG_ERASE ! ERASE CFG,
									  SPISELECT_UFM ! Select UFM Sector,
									  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
									  SPIUFM_ERASE ! ERASE UFM,
									  SPIDISABLE ! Exit the programming mode"	;  							  
							  
	"Slave SPI FLASH Verify Only" = "SVF_SPIINIT ! Initialize,
									  SPIREAD_ID	! Check the IDCODE,
									  SPIFLASH_ENABLE	! Enable the FLASH,
									  SPISELECT_CFG ! Select CFG Sector,
									  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
									  SPICFG_VERIFY_FULL ! Verify CFG,
									  SPISELECT_UFM ! Select UFM Sector,
									  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
									  SPIUFM_VERIFY_FULL ! Verify UFM,
									  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH CFG Erase,Program,Verify" = "SVF_SPIINIT ! Initialize,
												  SPIREAD_ID	! Check the IDCODE,
												  SPIFLASH_ENABLE	! Enable the FLASH,
												  SPIFLASH_CFG_PROGRAM_FULL ! Program CFG,
												  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH CFG Erase,Program,Verify and Lock" = "SVF_SPIINIT ! Initialize,
														  SPIREAD_ID	! Check the IDCODE,
														  SPIFLASH_ENABLE	! Enable the FLASH,
														  SPIFLASH_CFG_PROGRAM_FULL ! Program CFG,
														  SPICFG_PROGRAM_SECURITY ! Program CFG Security Bits,
														  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH CFG Erase Only" = "SVF_SPIINIT ! Initialize,
										  SPIREAD_ID	! Check the IDCODE,
										  SPIFLASH_ENABLE	! Enable the FLASH,
										  SPISELECT_CFG ! Select CFG Sector,
										  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
										  SPICFG_ERASE ! ERASE CFG,
										  SPIDISABLE ! Exit the programming mode"	;  
							  
							  
	"Slave SPI FLASH CFG Verify Only" = "SVF_SPIINIT ! Initialize,
										  SPIREAD_ID	! Check the IDCODE,
										  SPIFLASH_ENABLE	! Enable the FLASH,
										  SPISELECT_CFG ! Select CFG Sector,
										  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
										  SPICFG_VERIFY_FULL ! Verify CFG,
										  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH UFM Erase,Program,Verify" = "SVF_SPIINIT ! Initialize,
												  SPIREAD_ID	! Check the IDCODE,
												  SPIFLASH_ENABLE	! Enable the FLASH,
												  SPIFLASH_UFM_PROGRAM_FULL ! Program UFM,
												  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH UFM Erase,Program,Verify and Lock" = "SVF_SPIINIT ! Initialize,
														  SPIREAD_ID	! Check the IDCODE,
														  SPIFLASH_ENABLE	! Enable the FLASH,
														  SPIFLASH_UFM_PROGRAM_FULL ! Program UFM,
														  SPIUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
														  SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI FLASH UFM Erase Only" = "SVF_SPIINIT ! Initialize,
										  SPIREAD_ID	! Check the IDCODE,
										  SPIFLASH_ENABLE	! Enable the FLASH,
										  SPISELECT_UFM ! Select UFM Sector,
										  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
										  SPIUFM_ERASE ! ERASE CFG,
										  SPIDISABLE ! Exit the programming mode"	;  
							  							  
	"Slave SPI FLASH UFM Verify Only" = "SVF_SPIINIT ! Initialize,
										  SPIREAD_ID	! Check the IDCODE,
										  SPIFLASH_ENABLE	! Enable the FLASH,
										  SPISELECT_UFM ! Select UFM Sector,
										  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
										  SPIUFM_VERIFY_FULL ! Verify UFM,
										  SPIDISABLE ! Exit the programming mode"	;  
									  
	"Slave SPI FLASH Verify ID" = " SVF_SPIINIT ! Initialize,
									SPIREAD_ID ! Verify ID" ;
	                   
	"Slave SPI FLASH Secure" = "SVF_SPIINIT ! Initialize,
								SPIREAD_ID	! Check the IDCODE,
								SPIFLASH_ENABLE	! Enable the FLASH,
								SPICFG_PROGRAM_SECURITY ! Program CFG Security Bits,
								SPIUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
								SPIDISABLE ! Exit the programming mode"	;  
								
	"Slave SPI FLASH Refresh" = " SVF_SPIINIT ! Initialize,
	                    SPIREAD_ID ! Verify ID,
	                    SPIREFRESH_FUNCTION ! Refresh";	
						
	"Slave SPI FLASH Bypass" = " SVF_SPIINIT ! Initialize"; 

	"I2C FLASH Erase,Program,Verify" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH Erase,Program,Verify and Lock" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH Erase Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_ERASE ! ERASE CFG,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_ERASE ! ERASE UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  							  
	"I2C FLASH Verify Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_VERIFY_FULL ! Verify CFG,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_VERIFY_FULL ! Verify UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH CFG Erase,Program,Verify" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH CFG Erase,Program,Verify and Lock" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
							  I2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH CFG Erase Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_ERASE ! ERASE CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"I2C FLASH CFG Verify Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_VERIFY_FULL ! Verify CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH UFM Erase,Program,Verify" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH UFM Erase,Program,Verify and Lock" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
							  I2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C FLASH UFM Erase Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_ERASE ! ERASE CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"I2C FLASH UFM Verify Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_ENABLE	! Enable the FLASH,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_VERIFY_FULL ! Verify UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  
									  
	"I2C FLASH Verify ID" = " SVF_I2CINIT ! Initialize,
	                  		I2CREAD_ID ! Verify ID" ;
	                   
	"I2C FLASH Secure" = "SVF_I2CINIT ! Initialize,
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_ENABLE	! Enable the FLASH,
								I2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
								I2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
								I2CDISABLE ! Exit the programming mode"	;
								
	"I2C FLASH Refresh" = " SVF_I2CINIT ! Initialize,
	                    I2CREAD_ID ! Verify ID,
	                    I2CREFRESH_FUNCTION ! Refresh";										  

	"I2C FLASH Bypass" = " SVF_I2CINIT ! Initialize";	
						
	"JTAGI2C FLASH Erase,Program,Verify" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH Erase,Program,Verify and Lock" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH Erase Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_ERASE ! ERASE CFG,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_ERASE ! ERASE UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  							  
	"JTAGI2C FLASH Verify Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_VERIFY_FULL ! Verify CFG,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_VERIFY_FULL ! Verify UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH CFG Erase,Program,Verify" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH CFG Erase,Program,Verify and Lock" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
							  JTAGI2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH CFG Erase Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_ERASE ! ERASE CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"JTAGI2C FLASH CFG Verify Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_VERIFY_FULL ! Verify CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH UFM Erase,Program,Verify" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH UFM Erase,Program,Verify and Lock" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
							  JTAGI2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C FLASH UFM Erase Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_ERASE ! ERASE CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"JTAGI2C FLASH UFM Verify Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_VERIFY_FULL ! Verify UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
									  
	"JTAGI2C FLASH Verify ID" = " SVF_JTAGI2CINIT ! Initialize,
	                  		JTAGI2CREAD_ID ! Verify ID" ;
	                   
	"JTAGI2C FLASH Secure" = "SVF_JTAGI2CINIT ! Initialize,
								JTAGI2CREAD_ID	! Check the IDCODE,
								JTAGI2CFLASH_ENABLE	! Enable the FLASH,
								JTAGI2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
								JTAGI2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
								JTAGI2CDISABLE ! Exit the programming mode"	;
								
	"JTAGI2C FLASH Refresh" = " SVF_JTAGI2CINIT ! Initialize,
	                    JTAGI2CREAD_ID ! Verify ID,
	                    JTAGI2CREFRESH_FUNCTION ! Refresh";
						
	"JTAGI2C FLASH Bypass" = " SVF_JTAGI2CINIT ! Initialize";						
	
	"Slave SPI XFLASH Erase,Program,Verify" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPIFLASH_PROGRAM_FULL ! Program Flash and UFM,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH Erase,Program,Verify and Lock" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPIFLASH_PROGRAM_FULL ! Program Flash and UFM,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPICFG_PROGRAM_SECURITY ! Program CFG Security Bits,
							  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  SPIUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH Erase Only" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPICFG_ERASE ! ERASE CFG,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  SPIUFM_ERASE ! ERASE UFM,
	                          SPIDISABLE ! Exit the programming mode"	;  
							  
							  
	"Slave SPI XFLASH Verify Only" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPICFG_VERIFY_FULL ! Verify CFG,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  SPIUFM_VERIFY_FULL ! Verify UFM,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH Program and TransFR" = "SVF_SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPIFLASH_PROGRAM_FULL ! Program CFG and UFM,								
									SPIDISABLE ! Exit the programming mode,									
									SPIREFRESH_FUNCTION ! Refresh,
									SVF_SPIVERIFY_SRAM_DONE_BIT ! Check SRAM Status Register";
	
	"Slave SPI XFLASH TransFR" = "SVF_SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE,
								  SPIREFRESH_FUNCTION ! Refresh";
							  
	"Slave SPI XFLASH CFG Erase,Program,Verify" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPIFLASH_CFG_PROGRAM_FULL ! Program CFG,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH CFG Erase,Program,Verify and Lock" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPIFLASH_CFG_PROGRAM_FULL ! Program CFG,
							  SPICFG_PROGRAM_SECURITY ! Program CFG Security Bits,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH CFG Erase Only" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPICFG_ERASE ! ERASE CFG,
	                          SPIDISABLE ! Exit the programming mode"	;  
							  
							  
	"Slave SPI XFLASH CFG Verify Only" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_CFG ! Select CFG Sector,
							  SPICHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  SPICFG_VERIFY_FULL ! Verify CFG,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH UFM Erase,Program,Verify" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPIFLASH_UFM_PROGRAM_FULL ! Program UFM,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH UFM Erase,Program,Verify and Lock" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPIFLASH_UFM_PROGRAM_FULL ! Program UFM,
							  SPIUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          SPIDISABLE ! Exit the programming mode"	;  

	"Slave SPI XFLASH UFM Erase Only" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  SPIUFM_ERASE ! ERASE CFG,
	                          SPIDISABLE ! Exit the programming mode"	;  
							  
							  
	"Slave SPI XFLASH UFM Verify Only" = "SVF_SPIINIT ! Initialize,
	                          SPIREAD_ID	! Check the IDCODE,
	                          SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  SPISELECT_UFM ! Select UFM Sector,
							  SPICHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  SPIUFM_VERIFY_FULL ! Verify UFM,
	                          SPIDISABLE ! Exit the programming mode"	;  
									  
	"Slave SPI XFLASH Verify ID" = " SVF_SPIINIT ! Initialize,
	                  		SPIREAD_ID ! Verify ID" ;
	                   
	"Slave SPI XFLASH Secure" = "SVF_SPIINIT ! Initialize,
								SPIREAD_ID	! Check the IDCODE,
								SPIFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
								SPICFG_PROGRAM_SECURITY ! Program CFG Security Bits,
								SPIUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
								SPIDISABLE ! Exit the programming mode"	;
								
	"Slave SPI XFLASH Refresh" = " SVF_SPIINIT ! Initialize,
	                    SPIREAD_ID ! Verify ID,
	                    SPIREFRESH_FUNCTION ! Refresh";	
						
	"Slave SPI XFLASH Bypass" = " SVF_SPIINIT ! Initialize"; 
						
	"I2C XFLASH Erase,Program,Verify" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH Erase,Program,Verify and Lock" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH Erase Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_ERASE ! ERASE CFG,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_ERASE ! ERASE UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"I2C XFLASH Verify Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_VERIFY_FULL ! Verify CFG,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_VERIFY_FULL ! Verify UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  
	"I2C XFLASH Program and TransFR" = "SVF_I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									I2CFLASH_PROGRAM_FULL ! Program CFG and UFM,								
									I2CDISABLE_REFRESH ! Refresh";
	
	"I2C XFLASH TransFR" = "SVF_I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE,
								  I2CREFRESH_FUNCTION ! Refresh";

	"I2C XFLASH CFG Erase,Program,Verify" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH CFG Erase,Program,Verify and Lock" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
							  I2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH CFG Erase Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_ERASE ! ERASE CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"I2C XFLASH CFG Verify Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_CFG ! Select CFG Sector,
							  I2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  I2CCFG_VERIFY_FULL ! Verify CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH UFM Erase,Program,Verify" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH UFM Erase,Program,Verify and Lock" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
							  I2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          I2CDISABLE ! Exit the programming mode"	;  

	"I2C XFLASH UFM Erase Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_ERASE ! ERASE CFG,
	                          I2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"I2C XFLASH UFM Verify Only" = "SVF_I2CINIT ! Initialize,
	                          I2CREAD_ID	! Check the IDCODE,
	                          I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  I2CSELECT_UFM ! Select UFM Sector,
							  I2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  I2CUFM_VERIFY_FULL ! Verify UFM,
	                          I2CDISABLE ! Exit the programming mode"	;  
									  
	"I2C XFLASH Verify ID" = " SVF_I2CINIT ! Initialize,
	                  		I2CREAD_ID ! Verify ID" ;
	                   
	"I2C XFLASH Secure" = "SVF_I2CINIT ! Initialize,
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
								I2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
								I2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
								I2CDISABLE ! Exit the programming mode"	;
								
	"I2C XFLASH Refresh" = " SVF_I2CINIT ! Initialize,
	                    I2CREAD_ID ! Verify ID,
	                    I2CREFRESH_FUNCTION ! Refresh";										  

	"I2C XFLASH Bypass" = " SVF_I2CINIT ! Initialize";	
													     
	"JTAGI2C XFLASH Erase,Program,Verify" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH Erase,Program,Verify and Lock" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_PROGRAM_FULL ! Program Flash and UFM,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH Erase Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_ERASE ! ERASE CFG,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_ERASE ! ERASE UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"JTAGI2C XFLASH Verify Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_VERIFY_FULL ! Verify CFG,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_VERIFY_FULL ! Verify UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  
	"JTAGI2C XFLASH Program and TransFR" = "SVF_JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									JTAGI2CFLASH_PROGRAM_FULL ! Program CFG and UFM,											
									JTAGI2CDISABLE_REFRESH ! Refresh";
	
	"JTAGI2C XFLASH TransFR" = "SVF_JTAGI2CINIT 	! Initialize, 
								  JTAGI2CREAD_ID	! Check the IDCODE,
								  JTAGI2CREFRESH_FUNCTION ! Refresh";

	"JTAGI2C XFLASH CFG Erase,Program,Verify" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH CFG Erase,Program,Verify and Lock" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_CFG_PROGRAM_FULL ! Program CFG,
							  JTAGI2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH CFG Erase Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_ERASE ! ERASE CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"JTAGI2C XFLASH CFG Verify Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_CFG ! Select CFG Sector,
							  JTAGI2CCHECK_CFG_PASSWORD ! Check CFG Password Protect,
							  JTAGI2CCFG_VERIFY_FULL ! Verify CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH UFM Erase,Program,Verify" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH UFM Erase,Program,Verify and Lock" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CFLASH_UFM_PROGRAM_FULL ! Program UFM,
							  JTAGI2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  

	"JTAGI2C XFLASH UFM Erase Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_ERASE ! ERASE CFG,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
							  
							  
	"JTAGI2C XFLASH UFM Verify Only" = "SVF_JTAGI2CINIT ! Initialize,
	                          JTAGI2CREAD_ID	! Check the IDCODE,
	                          JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
							  JTAGI2CSELECT_UFM ! Select UFM Sector,
							  JTAGI2CCHECK_UFM_PASSWORD ! Check UFM Password Protect,
							  JTAGI2CUFM_VERIFY_FULL ! Verify UFM,
	                          JTAGI2CDISABLE ! Exit the programming mode"	;  
									  
	"JTAGI2C XFLASH Verify ID" = " SVF_JTAGI2CINIT ! Initialize,
	                  		JTAGI2CREAD_ID ! Verify ID" ;
	                   
	"JTAGI2C XFLASH Secure" = "SVF_JTAGI2CINIT ! Initialize,
								JTAGI2CREAD_ID	! Check the IDCODE,
								JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the FLASH,
								JTAGI2CCFG_PROGRAM_SECURITY ! Program CFG Security Bits,
								JTAGI2CUFM_PROGRAM_SECURITY ! Program UFM Security Bits,
								JTAGI2CDISABLE ! Exit the programming mode"	;
								
	"JTAGI2C XFLASH Refresh" = " SVF_JTAGI2CINIT ! Initialize,
	                    JTAGI2CREAD_ID ! Verify ID,
	                    JTAGI2CREFRESH_FUNCTION ! Refresh";
						
	"JTAGI2C XFLASH Bypass" = " SVF_JTAGI2CINIT ! Initialize";						 							 				 			 									   						 		     
</Operation_List>
<Operation_List label="ChainSVFOperationRevC">
	"Bypass" = "SVFINIT 	! Initialize"	;
</Operation_List>
<Script>
<![CDATA[
int32 PasswordEn = 0;
int32 Temp_Row_Count = 0;
int32   Temp_UFM_Count = 0;
function NOT_SUPPORTED {
	set_return_code (-1);	
	print (1,"Operation is not supported for JTAGI2C Mode. Cannot continue.");	
}
function INIT {
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
	IF (Address_Length == 5624)
	{
		Temp_Row_Count = 24573;
		Temp_UFM_Count = 8191;
    }
}
function SPIINIT_DIRECT {
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
	ENDDR DRPAUSE;
	FREQUENCY 1E6 HZ;
	IF (Address_Length == 5624)
	{
		Temp_Row_Count = 24573;
		Temp_UFM_Count = 8191;
    }
    TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  	TDO (0x00800000)
				  	MASK(0x008C0000);
		setpin ISPEN HIGH;
	}
	ELSE
	{	
		//print (0,"Key activation...");
		setpin ISPEN HIGH;
		setpin TRST LOW;
		setpin TRST HIGH;
		RUN_TEST DELAY 10;
		setpin ISPEN LOW;
	    ! Shift in Key activation;
	    SDR 32 TDI(0x512F6325);
	    setpin ISPEN HIGH;
	    setpin TRST HIGH;
	    setpin TRST LOW;
	    RUN_TEST DELAY 10;
	}
}
function SPIINIT {
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
	ENDDR DRPAUSE;
	FREQUENCY 1E6 HZ;
	IF (Address_Length == 5624)
	{
		Temp_Row_Count = 24573;
		Temp_UFM_Count = 8191;
    }
    TRY 1 {
    	setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO (0x00800000)
				  	MASK(0x008C0000);
		setpin ISPEN HIGH;
		//print (0,"Done High...");
	}
	ELSE
	{
	    //print (0,"Key activation...");
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
	    ! Shift in Key activation;
	    SDR 32 TDI(0x512F6325);
	    setpin ISPEN HIGH;
	    RUN_TEST DELAY 10;
	}
}
function SVF_SPIINIT {
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
	ENDDR DRPAUSE;
	FREQUENCY 1E6 HZ;
	IF (Address_Length == 5624)
	{
		Temp_Row_Count = 24573;
		Temp_UFM_Count = 8191;
    }
	setpin TRST LOW;
	setpin TRST HIGH;
	RUN_TEST DELAY 10;
	setpin ISPEN LOW;
    ! Shift in Key activation;
    SDR 32 TDI(0x512F6325);
    setpin ISPEN HIGH;
    setpin TRST HIGH;
    setpin TRST LOW;
    RUN_TEST DELAY 10;
}
function I2CINIT_DIRECT {
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
	IF (Address_Length == 5624)
	{
		Temp_Row_Count = 24573;
		Temp_UFM_Count = 8191;
    }
    TRY 1 {
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  	TDO (0x00800000)
				  	MASK(0x008C0000);
		I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		//print (0,"Activation Key....");
		setpin TRST HIGH;
		RUN_TEST DELAY 10;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in Key activation;
		SDR 32 TDI(0x512F6325);
		I2C_STOP;
		setpin TRST LOW;
	    RUN_TEST DELAY 10;
	    
	}
}
function I2CINIT {
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
	IF (Address_Length == 5624)
	{
		Temp_Row_Count = 24573;
		Temp_UFM_Count = 8191;
    }
    TRY 1 {
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  	TDO (0x00800000)
				  	MASK(0x008C0000);
		I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		//print (0,"Activation Key....");
		setpin TRST HIGH;
		RUN_TEST DELAY 10;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in Key activation;
		SDR 32 TDI(0x512F6325);
		I2C_STOP;
		setpin TRST LOW;
	    RUN_TEST DELAY 10;
	    
	}   
}
function SVF_I2CINIT {
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
	IF (Address_Length == 5624)
	{
		Temp_Row_Count = 24573;
		Temp_UFM_Count = 8191;
    }
	//print (0,"Activation Key....");
	setpin TRST HIGH;
	RUN_TEST DELAY 10;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in Key activation;
	SDR 32 TDI(0x512F6325);
	I2C_STOP;
	setpin TRST LOW;
    RUN_TEST DELAY 10;
}
function JTAGI2CINIT_DIRECT
{
	HDR 1 TDI(#0);
	HIR 8 TDI(#11111111);
	TDR 0;
	TIR 0;
	ENDDR IDLE;
	ENDIR IDLE;
	STATE IDLE;
	IF (Address_Length == 5624)
	{
		Temp_Row_Count = 24573;
		Temp_UFM_Count = 8191;
    }
    ! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY 10;
	! I2C LSC_I2CI_CRBR_WT to set XO2 SCL frequency; 
	SIR 8 TDI (0x9C);
	! I2C Prescale Control Register Setting;
	SDR 16 TDI(0x0000);                  
	RUN_TEST	IDLE TCK 2 DELAY 1;
	SDR 16 TDI(0x8000);                  
	RUN_TEST	IDLE TCK 2 DELAY 1;	
	
	//print (0,"Activation Keys...");
	setpin TRST HIGH;
	RUN_TEST DELAY 10;
	TRY 1{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Key activation;
		SDR	16	TDI (0x10A4);
		RUN_TEST IDLE TCK 1000 ;				
	    SDR	16	TDI (0x10C6);
		RUN_TEST IDLE TCK 1000 ;	
		SDR	16	TDI (0x10F4);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI (0x108A);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
			
	    setpin TRST LOW;
		RUN_TEST DELAY 10;
	}
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;		
		print (1,"Failed to activate JTAGI2C port. Please check the I2C Slave Address.");
	}
}
function JTAGI2CINIT 
{
	HDR 1 TDI(#0);
	HIR 8 TDI(#11111111);
	TDR 0;
	TIR 0;
	ENDDR IDLE;
	ENDIR IDLE;
	STATE IDLE;
	IF (Address_Length == 5624)
	{
		Temp_Row_Count = 24573;
		Temp_UFM_Count = 8191;
    }
    ! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY 10;
	! I2C LSC_I2CI_CRBR_WT to set XO2 SCL frequency; 
	SIR 8 TDI (0x9C);
	! I2C Prescale Control Register Setting;
	SDR 16 TDI(0x0000);                  
	RUN_TEST	IDLE TCK 2 DELAY 1;
	SDR 16 TDI(0x8000);                  
	RUN_TEST	IDLE TCK 2 DELAY 1;	
	
	//print (0,"Activation Keys...");
	setpin TRST HIGH;
	RUN_TEST DELAY 10;
	TRY 1{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Key activation;
		SDR	16	TDI (0x10A4);
		RUN_TEST IDLE TCK 1000 ;				
	    SDR	16	TDI (0x10C6);
		RUN_TEST IDLE TCK 1000 ;	
		SDR	16	TDI (0x10F4);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI (0x108A);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
			
	    setpin TRST LOW;
		RUN_TEST DELAY 10;
	}
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;		
		print (1,"Failed to activate JTAGI2C port. Please check the I2C Slave Address.");
	}
}
function SVF_JTAGI2CINIT
{
	HDR 1 TDI(#0);
	HIR 8 TDI(#11111111);
	TDR 0;
	TIR 0;
	ENDDR IDLE;
	ENDIR IDLE;
	STATE IDLE;
	IF (Address_Length == 5624)
	{
		Temp_Row_Count = 24573;
		Temp_UFM_Count = 8191;
    }
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY 10;
	! I2C LSC_I2CI_CRBR_WT to set XO2 SCL frequency; 
	SIR 8 TDI (0x9C);
	! I2C Prescale Control Register Setting;
	SDR 16 TDI(0x0000);                  
	RUN_TEST	IDLE TCK 2 DELAY 1;
	SDR 16 TDI(0x8000);                  
	RUN_TEST	IDLE TCK 2 DELAY 1;	
	
	setpin TRST LOW;
	setpin TRST HIGH;
	RUN_TEST DELAY 100;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Key activation;
	SDR	16	TDI (0x10A4);
	RUN_TEST IDLE TCK 1000 ;				
    SDR	16	TDI (0x10C6);
	RUN_TEST IDLE TCK 1000 ;	
	SDR	16	TDI (0x10F4);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI (0x108A);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
		
    setpin TRST HIGH;
    setpin TRST LOW;
    RUN_TEST DELAY 10;
}
///////////////////////////////////////////////////////////////////////////
function SPIREAD_ID {
	IDTDI[1] = $IDTDI[1];
	setpin ISPEN LOW;
	! Shift in IDCODE_PUB(0xE0) opcode;
	SDR	32	TDI (0x00000007);
	SDR_VERIFY	32	TDI (0x00000000)
					TDO	(IDTDI[1])
					MASK (0xFFFFFFFF);		
	setpin ISPEN HIGH;				        
}
function SPISAVE_ID	{
	datastream SavedID[1][ID_Length];
	file	NewFile = "FILE_SAVE";
	setpin ISPEN LOW; 
	! Shift in IDCODE_PUB(0xE0) opcode;
    	SDR 32 	TDI (0x00000007);
	SDR	ID_Length	TDI (#0^ID_Length)
				    TDO	(SavedID);
	setpin ISPEN HIGH;
	SavedID[1] = $SavedID[1];					
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}
function SVF_SPISAVE_ID	{
	setpin ISPEN LOW; 
	! Shift in IDCODE_PUB(0xE0) opcode;
    SDR 32 	TDI (0x00000007);
	SDR	ID_Length	TDI (#0^ID_Length)
					TDO	(#0^ID_Length)
					MASK(#0^ID_Length);
	setpin ISPEN HIGH;					
}
function I2CREAD_ID {
	IDTDI[1] = $IDTDI[1];
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in IDCODE_PUB(0xE0) opcode;
	SDR	32	TDI (0x00000007);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY	32	TDI (0x00000000)
					TDO	(IDTDI[1])
					MASK (0xFFFFFFFF);					
	I2C_STOP;				        
}
function I2CSAVE_ID	{
	datastream SavedID[1][ID_Length];
	file	NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in IDCODE_PUB(0xE0) opcode;
    SDR 32 	TDI (0x00000007);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	ID_Length	TDI (#0^ID_Length)
					TDO	(SavedID);
	I2C_STOP;				
	SavedID[1] = $SavedID[1];	
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}
function SVF_I2CSAVE_ID	{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in IDCODE_PUB(0xE0) opcode;
    SDR 32 	TDI (0x00000007);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	ID_Length	TDI (#0^ID_Length)
					TDO	(#0^ID_Length)
					MASK(#0^ID_Length);
	I2C_STOP;	
}
function JTAGI2CREAD_ID {
	datastream DataByte[1][8];
	datastream MaskByte[1][8];
	datastream DataIDMask[1][32];
	DataIDMask[1] = DEVICE_ID_MASK;
	TRY 1{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in IDCODE_PUB(0xE0) opcode;
		SDR	16	TDI (0x10E0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (IDTDI[1]);
		MaskByte[1] = (DataIDMask[1]);
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);
		DataByte[1] = (IDTDI[1] << 8);
		MaskByte[1] = (DataIDMask[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);
		DataByte[1] = (IDTDI[1] << 16);
		MaskByte[1] = (DataIDMask[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);
		DataByte[1] = (IDTDI[1] << 24);
		MaskByte[1] = (DataIDMask[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);								
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;		
		print (1,"Failed to read the Device's IDCODE. Please check the I2C Slave Address.");
	}			        
}
function JTAGI2CSAVE_ID	{
	datastream SavedID[1][ID_Length];
	datastream DataByte[1][8];
	file	NewFile = "FILE_SAVE";
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in IDCODE_PUB(0xE0) opcode;
	SDR	16	TDI (0x10E0);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedID[1] = ((SavedID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedID[1] = ((SavedID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedID[1] = ((SavedID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedID[1] = ((SavedID[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;			
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}
function SVF_JTAGI2CSAVE_ID	{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in IDCODE_PUB(0xE0) opcode;
	SDR	16	TDI (0x10E0);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (0x00)
			MASK (0x00);
	SDR	8	TDI  (0x00)
			TDO  (0x00)
			MASK (0x00);
	SDR	8	TDI  (0x00)
			TDO  (0x00)
			MASK (0x00);
	SDR	8	TDI  (0x00)
			TDO  (0x00)
			MASK (0x00);			
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;	
}
///////////////////////////////////////////////////////////////
function SPISRAM_ENABLE {	
	setpin ISPEN LOW;
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 32 TDI (0x00000063);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWV;
}
function I2CSRAM_ENABLE	{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 32 TDI (0x00000063);
    I2C_STOP;
    RUN_TEST DELAY PWV;
}
function JTAGI2CSRAM_ENABLE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ENABLE(0xC6) instruction;
	SDR	16	TDI (0x10C6);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
///////////////////////////////////////////////////////////////
function SPISRAM_TRANSPARENT_READ_ENABLE {
	setpin ISPEN LOW;
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 32 TDI (0x0000002E);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWV;
}
function I2CSRAM_TRANSPARENT_READ_ENABLE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 32 TDI (0x0000002E);
    I2C_STOP;
    RUN_TEST DELAY PWV;
}
function JTAGI2CSRAM_TRANSPARENT_READ_ENABLE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_ENABLE_X(0x74) instruction;
	SDR	16	TDI (0x1074);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
///////////////////////////////////////////////////////////
function SPISRAM_TRANSPARENT_READ_REFRESH_ENABLE {
	setpin ISPEN LOW;
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 32	TDI (0x0000009E);
    setpin ISPEN HIGH;
    setpin ISPEN LOW;
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 32 TDI (0x0000002E);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWV;
}
function I2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 32	TDI (0x0000009E);
    I2C_STOP;
    I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 32 TDI (0x0000002E);
    I2C_STOP;
    RUN_TEST DELAY PWV;
}
function JTAGI2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR	16	TDI (0x1079);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_ENABLE_X(0x74) instruction;
	SDR	16	TDI (0x1074);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
///////////////////////////////////////////////////////////////////////
function SPIDISABLE 
{
	setpin ISPEN LOW;
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	32 	TDI (0x00000064);
    setpin ISPEN HIGH;
    RUN_TEST DELAY 2000;
    
}
function I2CDISABLE	
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	32 	TDI (0x00000064);
    I2C_STOP;
    RUN_TEST DELAY 2000;    	    	
}
function I2CDISABLE_NEW_ADDR	
{
	datastream JTAGI2CN_WRITE[1][8];
	JTAGI2CN_WRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (JTAGI2CN_WRITE[1]);
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	32 	TDI (0x00000064);
    I2C_STOP;
    RUN_TEST DELAY 2000;    	    	
}
function I2CDISABLE_DEFAULT	
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (0x01);
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	32 	TDI (0x00000064);
    I2C_STOP;
    RUN_TEST DELAY 2000;    	    	
}
function I2CDISABLE_REFRESH	
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	32 	TDI (0x00000064);
    I2C_STOP;
    RUN_TEST DELAY 2000;
    I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 32	TDI (0x0000009E);
    I2C_STOP;
    RUN_TEST DELAY 5000;
}
/////////////////
function JTAGI2CDISABLE	{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC DISABLE(0x26) instruction;
	SDR	16	TDI (0x1026);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 2 DELAY 200; 
	
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1000;     
	     
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 2 DELAY 100; 	        	    	
}	
function JTAGI2CDISABLE_DEFAULT	
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ (0x80));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC DISABLE(0x26) instruction;
	SDR	16	TDI (0x1026);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 2 DELAY 200; 
	
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1000;     
	     
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 2 DELAY 100; 	    	    	
}	
function JTAGI2CDISABLE_NEW_ADDR	{
	datastream JTAGI2CN_WRITE[1][8];
	JTAGI2CN_WRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	JTAGI2CN_WRITE[1] = $JTAGI2CN_WRITE[1];

	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ (JTAGI2CN_WRITE[1]));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC DISABLE(0x26) instruction;
	SDR	16	TDI (0x1026);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 2 DELAY 200; 
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1000;     
	     
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 2 DELAY 100; 	      	    	
}	
function JTAGI2CDISABLE_REFRESH	
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC DISABLE(0x26) instruction;
	SDR	16	TDI (0x1026);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 200;  
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR	16	TDI (0x1079);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 200;		
}
///////////////////////////////////////////////////////////////////////////
function SPISRAM_ERASE {
	setpin ISPEN LOW;	
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00000070);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWP;		   
}
function I2CSRAM_ERASE {	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00000070);
    I2C_STOP;    
    RUN_TEST DELAY PWP;    
}
function JTAGI2CSRAM_ERASE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ERASE(0x0E) instruction;
	SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1001);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY PWP;
}
//////////////////////////////////////////////////////////////////////////////
function SPIBURST_PROGRAM {
	FuseArray_TDI.row = 1;
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00000062);
    setpin ISPEN HIGH;
	setpin ISPEN LOW;
	! Shift in LSC_BITSTREAM_BURST(0x7A) instruction;
    SDR 32	TDI (0x0000005E);
	! Shift in TOTAL_FUSE_MAP bits;
    SDR	TotalFuse		TDI	(FuseArray_TDI);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWP;
}
function I2CBURST_PROGRAM {
	FuseArray_TDI.row = 1;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00000062);
    I2C_STOP;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_BITSTREAM_BURST(0x7A) instruction;
    SDR 32	TDI (0x0000005E);
	! Shift in TOTAL_FUSE_MAP bits;
    SDR	TotalFuse		TDI	(FuseArray_TDI);
    I2C_STOP;
	RUN_TEST DELAY PWP;
}
function JTAGI2CBURST_PROGRAM {
	datastream DataByte[1][8];
	int32	ByteCount = 1;
	int32	i = 0;
	FuseArray_TDI.row = 1;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_BITSTREAM_BURST(0x7A) instruction;
	SDR	16	TDI (0x107A);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	ByteCount = TotalFuse/8;
	FuseArray_TDI[1] = $FuseArray_TDI[1];
	repeat ByteCount {
		DataByte[1] = (FuseArray_TDI[1] << i);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;	
		i = i + 8;
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 1;
}
///////////////////////////////////////////////////////////////////////
function SPISRAM_PROGRAM_USERCODE {
	IF (Usercode_TDI.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	    SDR 32	TDI (0x00000062);
	    setpin ISPEN HIGH;
		setpin ISPEN LOW;
	 	! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
	    SDR Usercode_Length	TDI	(Usercode_TDI[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY 100;				
	}
}
function I2CSRAM_PROGRAM_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		SavedUsercode[1] = Usercode_TDI[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	 	! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
	    SDR Usercode_Length	TDI	(SavedUsercode[1]);
		I2C_STOP;	
		RUN_TEST DELAY PWP;
	}
}
function JTAGI2CSRAM_PROGRAM_USERCODE {
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
		SDR	16	TDI (0x10C2);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
	    SavedUsercode[1] = Usercode_TDI[1];
	    DataByte[1] = SavedUsercode[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1; 	
	}
}
/////////////////////////////////////////////////////////////////////
function SPISRAM_VERIFY_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		setpin ISPEN LOW; 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SavedUsercode[1] = $Usercode_TDI[1];
		SDR_VERIFY 	32 	TDI (#0^Usercode_Length)
					   	TDO	(SavedUsercode[1])
						MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;									
	}
}
function I2CSRAM_VERIFY_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SavedUsercode[1] = $Usercode_TDI[1];
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
	    SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(SavedUsercode[1])
									MASK(0xFFFFFFFF);
		I2C_STOP;									
	}
}
function JTAGI2CSRAM_VERIFY_USERCODE {
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		Usercode_TDI[1] = $Usercode_TDI[1];
		SavedUsercode[1] = Usercode_TDI[1];
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR	16	TDI (0x10C0);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedUsercode[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedUsercode[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedUsercode[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedUsercode[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
}
///////////////////////////////////////////////////////////////
function SPIVERIFY_USERCODE {
	IF (Usercode_TDI.row = 1)
	{
		setpin ISPEN LOW; 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SDR_VERIFY 	32 	TDI (#0^Usercode_Length)
					   	TDO	(Usercode_TDI[1])
						MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;									
	}
}	
function I2CVERIFY_USERCODE {
	IF (Usercode_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	   	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
	    SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(Usercode_TDI[1])
									MASK(0xFFFFFFFF);
		I2C_STOP;									
	}
}
function JTAGI2CVERIFY_USERCODE {
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		SavedUsercode[1] = Usercode_TDI[1];
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR	16	TDI (0x10C0);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedUsercode[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedUsercode[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedUsercode[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedUsercode[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ; 									
	}
}
//////////////////////////////////////////////////////////////////////////////
function SPISAVE_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    SDR	32	TDI(#0^Usercode_Length)
			TDO(SavedUsercode);
	setpin ISPEN HIGH;
	SavedUsercode[1] = $SavedUsercode[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function I2CSAVE_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
    SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	I2C_STOP;
	SavedUsercode[1] = $SavedUsercode[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function JTAGI2CSAVE_USERCODE {
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in READ USERCODE(0xC0) instruction;
    SDR	16	TDI (0x10C0);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function SVF_SPISAVE_USERCODE {
	setpin ISPEN LOW;
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    SDR	32	TDI(#0^Usercode_Length)
			TDO(#0^Usercode_Length)
			MASK(#0^Usercode_Length);
	setpin ISPEN HIGH;
}
function SVF_I2CSAVE_USERCODE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
    SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode)
						MASK(#0^Usercode_Length);
	I2C_STOP;
}
function SVF_JTAGI2CSAVE_USERCODE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in READ USERCODE(0xC0) instruction;
    SDR	16	TDI (0x10C0);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (0x00)
			MASK (0x00);
	SDR	8	TDI  (0x00)
			TDO  (0x00)
			MASK (0x00);
	SDR	8	TDI  (0x00)
			TDO  (0x00)
			MASK (0x00);
	SDR	8	TDI  (0x00)
			TDO  (0x00)
			MASK (0x00);			
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 
}
function SPISRAM_DISPLAY_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	setpin ISPEN LOW;
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    SDR	32	TDI(#0^Usercode_Length)
			TDO(SavedUsercode);
	setpin ISPEN HIGH;
	SavedUsercode[1] = $SavedUsercode[1];
	print (0,"SRAM USERCODE is:");
	print (0,SavedUsercode);
}
function I2CSRAM_DISPLAY_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
    SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	I2C_STOP;
	SavedUsercode[1] = $SavedUsercode[1];
	print (0,"SRAM USERCODE is:");
	print (0,SavedUsercode);
}
/////////////////////////////////////////////////////////////////////////////////
function SPIPROGRAM_CONTROL0 {
	IF (Control_Register_0_TDI.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in LSC_PROG_CTRL0(0x22) instruction;
	    SDR 32 TDI (0x00000044);
		SDR 32 TDI(Control_Register_0_TDI[1]);
		RUN_TEST DELAY PWP; 
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SDR 32 TDI (0x00000004);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(Control_Register_0_TDI[1]);
		setpin ISPEN HIGH;					   
	}
}
function I2CPROGRAM_CONTROL0 {
	IF (Control_Register_0_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_CTRL0(0x22) instruction;
	    SDR 32 TDI (0x00000044);
		SDR 32 TDI(Control_Register_0_TDI[1]);
		RUN_TEST DELAY PWP; 
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SDR 32 TDI (0x00000004);
	    I2C_RESTART;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(Control_Register_0_TDI[1]);
		I2C_STOP;					   
	}
}
function JTAGI2CPROGRAM_CONTROL0 {
	datastream DataByte[1][8];
	datastream SavedControl[1][32];
	IF (Control_Register_0_TDI.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_PROG_CTRL0(0x22) instruction;
	    SDR	16	TDI (0x1022);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		SavedControl[1] = Control_Register_0_TDI[1];
		SavedControl[1] = $SavedControl[1];
	    DataByte[1] = SavedControl[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1; 
						
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SDR	16	TDI (0x1020);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
	    ! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		SavedControl[1] = Control_Register_0_TDI[1];
		SavedControl[1] = $SavedControl[1];
		
		DataByte[1] = SavedControl[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		TRY 1 {
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			DataByte[1] = (SavedControl[1] << 8);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);	
			DataByte[1] = (SavedControl[1] << 16);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			DataByte[1] = (SavedControl[1] << 24);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ; 
		}
		ELSE {
	    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100;
    		print (1,"Failed to Verify Control Register 0. Cannot continue.");
    	}
	}
}
////////////////////////////////////////////////////////////////////////////////////
function SPIVERIFY_CONTROL0 {
	datastream SavedControl0[1][32];
	IF (Control_Register_0_TDI.row = 1)
	{
		SavedControl0[1] = Control_Register_0_TDI[1];
	    setpin ISPEN LOW;
		! Shift in LSCC READ CONTROL 0(0x20) instruction;
	    SDR 32 TDI (0x00000004);
		SDR_VERIFY  32 TDI(0x00000000)
				   	   TDO(SavedControl0[1])
				       MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;				       
	}	
}
function I2CVERIFY_CONTROL0 {
	IF (Control_Register_0_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SDR 32 TDI (0x00000004);
	    I2C_RESTART;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(Control_Register_0_TDI[1]);
		I2C_STOP;					   
	}
}
function JTAGI2CVERIFY_CONTROL0 {
	datastream DataByte[1][8];
	datastream SavedControl0[1][32];
	IF (Control_Register_0_TDI.row = 1)
	{
		SavedControl0[1] = Control_Register_0_TDI[1];
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SDR	16	TDI (0x1020);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedControl0[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl0[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedControl0[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl0[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ; 								   
	}
}
/////////////////////////////////////////////////////////////////////////
function SPISAVE_CONTROL0 {
	datastream SavedControl0[1][32];
	file	NewFile = "FILE_SAVE"; 
	setpin ISPEN LOW;
	! Shift in LSC READ CONTROL_0(0x20) instruction;
	SDR 32 TDI (0x00000004);
	SDR  32 TDI(0x00000000)
			TDO(SavedControl0[1]);
	setpin ISPEN HIGH;	  
	SavedControl0[1] = $SavedControl0[1];
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_0_TDI, SavedControl0);
	fclose 	NewFile;
}
function I2CSAVE_CONTROL0 {
	datastream SavedControl0[1][32];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC READ CONTROL_0(0x20) instruction;
	SDR 32 TDI (0x00000004);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI(#0^32)
			TDO(SavedControl0);
	I2C_STOP;			
	SavedControl0[1] = $SavedControl0[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_0_TDI, SavedControl0);
	fclose 	NewFile;
}
function JTAGI2CSAVE_CONTROL0 {
	datastream SavedControl0[1][32];
	datastream DataByte[1][8];
	file NewFile = "FILE_SAVE";
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_CTRL0(0x20) instruction;
    SDR	16	TDI (0x1020);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedControl0[1] = ((SavedControl0[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);	
	SavedControl0[1] = ((SavedControl0[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedControl0[1] = ((SavedControl0[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);	
	SavedControl0[1] = ((SavedControl0[1]) @ (DataByte[1])) << 8;									
    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 				
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_0_TDI, SavedControl0);
	fclose 	NewFile;
}
///////////////////////////////////////////////////////////////////////////
function SPIPROGRAM_CONTROL1 
{
	IF (Control_Register_1_TDI.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
	    SDR 32 TDI (0x000000C4);
		SDR 32 TDI(Control_Register_1_TDI[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP; 
		
		setpin ISPEN LOW;
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR 32 TDI (0x00000084);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(Control_Register_1_TDI[1]);
		setpin ISPEN HIGH;					   
	}
}
function SPISRAM_PROGRAM_CONTROL1 
{
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
		SavedControl1[1] = $SavedControl1[1]; 
		setpin ISPEN LOW;
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
	    SDR 32 TDI (0x000000C4);
		SDR 32 TDI(SavedControl1[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP; 
		
		setpin ISPEN LOW;
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR 32 TDI (0x00000084);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl1[1])
					   MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;					   
	}
}
function I2CPROGRAM_CONTROL1 {
	datastream SavedControl1[1][32];	    
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
	    SDR 32 TDI (0x000000C4);
		SDR 32 TDI(SavedControl1[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP; 
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR 32 TDI (0x00000084);
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl1[1])
					   MASK(0xFFFFFFFF);
		I2C_STOP;						   
	}
}
function I2CSRAM_PROGRAM_CONTROL1 
{
	datastream SavedControl1[1][32];	    
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
		SavedControl1[1] = $SavedControl1[1];    
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
	    SDR 32 TDI (0x000000C4);
		SDR 32 TDI(SavedControl1[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP; 
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR 32 TDI (0x00000084);
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl1[1])
					   MASK(0xFFFFFFFF);
		I2C_STOP;						   
	}
}
function JTAGI2CPROGRAM_CONTROL1 {
	datastream DataByte[1][8];
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
		SDR	16	TDI (0x1023);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SavedControl1[1] = Control_Register_1_TDI[1];
	    DataByte[1] = SavedControl1[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl1[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl1[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl1[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1; 	
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR	16	TDI (0x1021);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedControl1[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl1[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedControl1[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl1[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ; 				   
	}
}
function JTAGI2CSRAM_PROGRAM_CONTROL1  
{
	datastream DataByte[1][8];
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
		//print (0,SavedControl1);
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
		SDR	16	TDI (0x1023);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = SavedControl1[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl1[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl1[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl1[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1; 	
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR	16	TDI (0x1021);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedControl1[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl1[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedControl1[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl1[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ; 				   
	}
}
///////////////////////////////////////////////////////////////////////////////
function SPIVERIFY_CONTROL1 {
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
	    setpin ISPEN LOW;
		! Shift in LSC READ CONTROL 1(0x21) instruction;
	    SDR 32 TDI (0x00000084);
		SDR_VERIFY  32 TDI(0x00000000)
				   	   TDO(SavedControl1[1])
				       MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;				       
	}	
}
function I2CVERIFY_CONTROL1{
	IF (Control_Register_1_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR 32 TDI (0x00000084);
	    I2C_RESTART;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(Control_Register_1_TDI[1]);
		I2C_STOP;					   
	}
}
function JTAGI2CVERIFY_CONTROL1 {
	datastream DataByte[1][8];
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR	16	TDI (0x1021);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedControl1[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl1[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedControl1[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl1[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ; 								   
	}
}
///////////////////////////////////////////////////////////////////////////
function SPISAVE_CONTROL1 {
	datastream SavedControl1[1][32];
	file	NewFile = "FILE_SAVE"; 
	setpin ISPEN LOW;
	! Shift in LSC READ CONTROL_1(0x21) instruction;
	SDR 32 TDI (0x00000084);
	SDR  32 TDI(0x00000000)
			TDO(SavedControl1[1]);
	setpin ISPEN HIGH;	  
	SavedControl1[1] = $SavedControl1[1];
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_1_TDI, SavedControl1);
	fclose 	NewFile;
}
function I2CSAVE_CONTROL1 {
	datastream SavedControl1[1][32];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC READ CONTROL_1(0x21) instruction;
	SDR 32 TDI (0x00000084);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI(#0^32)
			TDO(SavedControl1[1]);
	I2C_STOP;			
	SavedControl1[1] = $SavedControl1[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_1_TDI, SavedControl1);
	fclose 	NewFile;
}
function JTAGI2CSAVE_CONTROL1 {
	datastream SavedControl1[1][32];
	datastream DataByte[1][8];
	file NewFile = "FILE_SAVE";
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_CTRL1(0x21) instruction;
    SDR	16	TDI (0x1021);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedControl1[1] = ((SavedControl1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);	
	SavedControl1[1] = ((SavedControl1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedControl1[1] = ((SavedControl1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);	
	SavedControl1[1] = ((SavedControl1[1]) @ (DataByte[1])) << 8;									
    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 								   
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_1_TDI, SavedControl1);
	fclose 	NewFile;
}
////////////////////////////////////////////////////////////////////////////
function SPISRAMPROGRAM_DONE_BIT {
	TRY 1{
		setpin ISPEN LOW;
		! Shift in ISC PROGRAM DONE(0x5E) instruction;
		SDR	32 	TDI (0x0000007A);
		setpin ISPEN HIGH;
		RUN_TEST DELAY 200;
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
						TDO (0x00800000)
						MASK(0x008C0000);	
		setpin ISPEN HIGH;
	}
	ELSE
	{
		setpin ISPEN HIGH;		
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
	    setpin ISPEN HIGH;
	    RUN_TEST DELAY 200;   
		print (1, "Failed to Program DONE bit /see log file for more details/ ");
	}
}
function I2CSRAMPROGRAM_DONE_BIT 
{
	TRY 1{	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC PROGRAM DONE(0x5E) instruction;
		SDR 32 TDI (0x0000007A);
		I2C_STOP
		RUN_TEST DELAY PWP; 
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);	
		SDR_VERIFY  32 	TDI(#0^32)
						TDO (0x00800000)
						MASK(0x008C0000);		
		I2C_STOP;	
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
	    I2C_STOP;
	    RUN_TEST DELAY 200;   
		print (1, "Failed to Program DONE bit /see log file for more details/ ");
	}
}
function JTAGI2CSRAMPROGRAM_DONE_BIT {	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
	SDR	16	TDI (0x105E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 1;	

	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1 {
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x01)
						MASK (0x31);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;					
	}
	ELSE
	{		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;		
		print (1, "Failed to Program DONE bit /see log file for more details/ ");
	}
}	
/////////////////////////////////////////////////////////////////////////////////////
function SPISRAM_PROGRAM {
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00000062);
    setpin ISPEN HIGH;	
    RUN_TEST DELAY PWV;	
    
	repeat Address_Length
	{
		setpin ISPEN LOW;
		! Shift in LSC_PROG_INCR_RTI(0x82) instruction;
    	SDR 32	TDI (0x00008441); 
		! Shift in Data Row = RowCount; 			
		SDR	Row_Width	TDI	(FuseArray_TDI[RowCount]);
		setpin ISPEN HIGH;
		RowCount = RowCount +1;	
		RUN_TEST DELAY 1;	
	} 		
}
function I2CSRAM_PROGRAM {
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00000062);
	I2C_STOP;
	RUN_TEST DELAY PWV;
    
    repeat Address_Length
    {
		I2C_START;	
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_INCR(0x82) instruction;
	    SDR 32	TDI (0x00008441); 
		! Shift in Data Row = RowCount; 			
		SDR	Row_Width	TDI	(FuseArray_TDI[RowCount]);
		I2C_STOP;	
		RowCount = RowCount +1;			
	} 		
}
function JTAGI2CSRAM_PROGRAM {
	set_return_code (-1);
	print (1,"Operation is not supported. Cannot continue.");
}
///////////////////////////////////////////////////////////////////////////////////
function SPISRAM_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	FuseArray_MASK.row = 1;
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00000062);
		setpin ISPEN HIGH;				
		RUN_TEST DELAY PWV;
		
	    repeat Address_Length 
	    {
			setpin ISPEN LOW;
			! Shift in LSC_VERIFY_INCR_RTI(0x6A) instruction;
	    	SDR 32	TDI	(0x00008456);
			! Shift Out Data Row = RowCount;
		    SDR_VERIFY	Row_Width	TDI	(#0^Row_Width)
									TDO	(FuseArray_TDI[RowCount])
									MASK(FuseArray_MASK);
			setpin ISPEN HIGH;	
			setpin ISPEN LOW;					
			SDR 32	TDI	(#0^32);
			setpin ISPEN HIGH;
			RowCount = RowCount +1;
		}	
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1, "Failed in Function SPISRAM_VERIFY /see log file for more details/ ");
	}				
}
function I2CSRAM_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	FuseArray_MASK.row = 1;
	TRY 1 {
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00000062);
		I2C_STOP;
		RUN_TEST DELAY PWV;
		repeat Address_Length
		{
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    	! Shift in LSC_VERIFY_INCR_RTI(0x6A) instruction;
		    SDR 32	TDI	(0x00008456);
		    I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			! Shift out Data Row = RowCount; 			
			SDR_VERIFY	Row_Width	TDI	(#0^Row_Width)
									TDO	(FuseArray_TDI[RowCount])
									MASK(FuseArray_MASK);
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    	SDR 32	TDI	(#0^32);						
			I2C_STOP;						
			RowCount = RowCount +1;
		}		
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;
		print (1, "Failed in Function I2CSRAM_VERIFY /see log file for more details/ ");
	}				
}
function JTAGI2CSRAM_VERIFY {
	datastream DataByte[1][8];
	datastream TmpJTAGI2CVerifyDataArray[1][Row_Width];
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;	
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 DELAY 100;
	
    TRY 1 {	    	      	
		repeat Address_Length{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
	    	! Shift in LSC_VERIFY_INCR_RTI(0x6A) instruction;
		    SDR	16	TDI (0x106A);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1021);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			
			TmpJTAGI2CVerifyDataArray[1] = FuseArray_TDI[RowCount];
			TmpJTAGI2CVerifyDataArray[1] = $TmpJTAGI2CVerifyDataArray[1];
			! Shift out Data Row = RowCount; 	
	    	DataByte[1] = (TmpJTAGI2CVerifyDataArray[1]);
	    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);	
	    	SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 8);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 16);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 24);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;	
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 32);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 40);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 48);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 56);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 64);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 72);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 80);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 88);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 96);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 104);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 112);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 120);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);	
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 128);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);				
		    RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 136);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);												
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 144);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);	
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 152);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);	
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 160);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);	
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 168);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);	
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 176);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);	
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 184);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);	
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 192);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);	
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 200);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);																															
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);	
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
		    SDR	16	TDI (0x10FF);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI (0x10FF);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI (0x10FF);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI (0x10FF);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ; 
									
			RowCount = RowCount +1;
		}
	}				
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;			
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;	
		print (1, "Failed in Function VERIFY /see log file for more details/ ");
	}					
}
/////////////////////////////////////////////////////////////////////////////////////////////
function SPISRAM_SAVE_ARRAY {
	int32	RowCount = 1;
	datastream SavedFuseMap[Address_Length][Row_Width];
	file NewFile = "FILE_SAVE";
	
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00000062);
	setpin ISPEN HIGH;	
	RUN_TEST DELAY PWV;	
	
	
	repeat Address_Length 
	{
		setpin ISPEN LOW;
		! Shift in LSC_VERIFY_INCR_RTI(0x6A) instruction;
		SDR 32	TDI	(0x00008456);
		! Shift Out Data Row = RowCount;
		SDR	Row_Width	TDI	(#0^Row_Width)
						TDO	(SavedFuseMap[RowCount]);
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		SDR 32	TDI	(#0^32);
		setpin ISPEN HIGH;						
		RowCount = RowCount +1;
	}
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
function I2CSRAM_SAVE_ARRAY {
	int32	RowCount = 1;
	datastream SavedFuseMap[Address_Length][Row_Width];
	file NewFile = "FILE_SAVE";
	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00000062);
	I2C_STOP;
	RUN_TEST DELAY PWV;
	
	repeat Address_Length {
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_VERIFY_INCR_RTI(0x6A) instruction;
	    SDR 32	TDI	(0x00008456);
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		! Shift out Data Row = RowCount; 			
		SDR	Row_Width	TDI	(#1^Row_Width)
						TDO	(SavedFuseMap[RowCount]);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	SDR 32	TDI	(#0^32);						
		I2C_STOP;						
		RowCount = RowCount +1;
	}		
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
function JTAGI2CSRAM_SAVE_ARRAY {
	set_return_code (-1);
	print (1,"Operation is not supported. Cannot continue.");	
}
///////////////////////////////////////////////////////////////////////////////////////////
function SPIVERIFY_SRAM_DONE_BIT {
	datastream SavedRegister[1][32];
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00800000)
				  	MASK(0x00840000);
		setpin ISPEN HIGH; 		  		    
	}
	ELSE {		
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR  32 	TDI(#0^32)
				  	TDO(SavedRegister[1]);
		setpin ISPEN HIGH; 		
		SavedRegister[1] = $SavedRegister[1];
		SavedRegister[1] = SavedRegister[1] & 0x03C00000;
		IF (SavedRegister[1] == 0x00800000)
		{
			print (1,"Failed to program SRAM Done. Mismatch to the device ID code.");
		}
		ELSEIF (SavedRegister[1] == 0x01000000)
		{
			print (1,"Failed to program SRAM Done. Illegal command detected.");
		}
		ELSEIF (SavedRegister[1] == 0x01800000)
		{
			print (1,"Failed to program SRAM Done. CRC checksum error.");
		}
		ELSEIF (SavedRegister[1] == 0x02000000)
		{
			print (1,"Failed to program SRAM Done. Preamble detection error.");
		}
		ELSEIF (SavedRegister[1] == 0x02800000)
		{
			print (1,"Failed to program SRAM Done. Bitstream Engine execution was aborted by the user activity.");
		}
		ELSE
		{
			print (0,"Failed to program SRAM Done.");
			print (1,"Cannot Continue.");
		}
	}
}
function I2CVERIFY_SRAM_DONE_BIT {
	datastream SavedRegister[1][32];
	TRY 1 {
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00800000)
				  	MASK(0x00840000);
		I2C_STOP;		  		    
	}
	ELSE {		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR  32 	TDI(#0^32)
				  	TDO(SavedRegister[1]);
		I2C_STOP;	
		SavedRegister[1] = $SavedRegister[1];
		SavedRegister[1] = SavedRegister[1] & 0x03C00000;
		IF (SavedRegister[1] == 0x00800000)
		{
			print (1,"Failed to program SRAM Done. Mismatch to the device ID code.");
		}
		ELSEIF (SavedRegister[1] == 0x01000000)
		{
			print (1,"Failed to program SRAM Done. Illegal command detected.");
		}
		ELSEIF (SavedRegister[1] == 0x01800000)
		{
			print (1,"Failed to program SRAM Done. CRC checksum error.");
		}
		ELSEIF (SavedRegister[1] == 0x02000000)
		{
			print (1,"Failed to program SRAM Done. Preamble detection error.");
		}
		ELSEIF (SavedRegister[1] == 0x02800000)
		{
			print (1,"Failed to program SRAM Done. Bitstream Engine execution was aborted by the user activity.");
		}
		ELSE
		{
			print (0,"Failed to program SRAM Done.");
			print (1,"Cannot Continue.");
		}
	}
}
function JTAGI2CVERIFY_SRAM_DONE_BIT {
	datastream DataByte[1][8];
	datastream SavedRegister[1][32];
	RUN_TEST	IDLE  TCK 100 DELAY 1000;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	TRY 1 {		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x01)
						MASK (0x21);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;			  		  		    
	}
	ELSE {		  
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 	
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 	
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedRegister[1] = ((SavedRegister[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedRegister[1] = ((SavedRegister[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedRegister[1] = ((SavedRegister[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);			
		SavedRegister[1] = ((SavedRegister[1]) @ (DataByte[1])) << 8;				
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ; 
		SavedRegister[1] = SavedRegister[1] & 0x03C00000;
		IF (SavedRegister[1] == 0x00800000)
		{
			print (1,"Failed to program SRAM Done. Mismatch to the device ID code.");
		}
		ELSEIF (SavedRegister[1] == 0x01000000)
		{
			print (1,"Failed to program SRAM Done. Illegal command detected.");
		}
		ELSEIF (SavedRegister[1] == 0x01800000)
		{
			print (1,"Failed to program SRAM Done. CRC checksum error.");
		}
		ELSEIF (SavedRegister[1] == 0x02000000)
		{
			print (1,"Failed to program SRAM Done. Preamble detection error.");
		}
		ELSEIF (SavedRegister[1] == 0x02800000)
		{
			print (1,"Failed to program SRAM Done. Bitstream Engine execution was aborted by the user activity.");
		}
		ELSE
		{
			print (0,"Failed to program SRAM Done.");
			print (1,"Cannot Continue.");
		}
	}
}
function SVF_SPIVERIFY_SRAM_DONE_BIT {
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR_VERIFY  32 	TDI(#0^32)
				TDO(0x00800000)
				MASK(0x00840000);
	setpin ISPEN HIGH; 		  		    
}
function SVF_I2CVERIFY_SRAM_DONE_BIT {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY  32 	TDI(#0^32)
				TDO(0x00800000)
				MASK(0x00840000);
	I2C_STOP;		  		    
}
function SVF_JTAGI2CVERIFY_SRAM_DONE_BIT {
	RUN_TEST	IDLE  TCK 100 DELAY 1000;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);			
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x01)
					MASK (0x21);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;			  		  		    
}
//////////////////////////////////////////////////////////////////////////////
function SPISRAM_SECURE {
	datastream LockBitsArray[1][24];	
	
	//ISC_PROGRAM_SECURITY operand is as below
	//Bit[18:16] Flash Sector Address
	//Bit[15:14] 11 to Enable Password Protection
	//Bit[13:10] 1001 to Enable Erase Security
	//Bit[9] 1 to Enable Write Security
	//Bit[8] 1 to Enable Read Security	
	
	LockBitsArray[1] = 0x000000;
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = 0x000100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00800073);
    	setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;
    	
    	setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00000000)
				  		MASK(0x00100000);
		setpin ISPEN HIGH;		   		    
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = 0x000200;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00400073);
    	setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;
	
    	setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00000000)
				  		MASK(0x00200000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = 0x000300;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00C00073);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	
    	setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00000000)
				  		MASK(0x00300000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_ERASE_L
	ELSEIF (ISSECURED == 4)
	{
		LockBitsArray[1] = 0x002400;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00240073);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	
    	setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x02000000)
				  		MASK(0x02000000);
		setpin ISPEN HIGH;
	}	
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (ISSECURED == 5)
	{
		LockBitsArray[1] = 0x002500;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00A40073);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	
    	setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x02000000)
				  		MASK(0x02100000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (ISSECURED == 6)
	{
		LockBitsArray[1] = 0x002600;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00640073);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	
    	setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  			TDO(0x02000000)
				  			MASK(0x02200000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_PROG_L SEC_ERASE_L SEC_READ_L
	ELSEIF (ISSECURED == 7)
	{
		LockBitsArray[1] = 0x002700;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00E40073);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	
    	setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  			TDO(0x02000000)
				  			MASK(0x02300000);
		setpin ISPEN HIGH;
	}	
}
function I2CSRAM_SECURE {
	datastream LockBitsArray[1][24];
	//ISC_PROGRAM_SECURITY operand is as below
	//Bit[18:16] Flash Sector Address
	//Bit[15:14] 11 to Enable Password Protection
	//Bit[13:10] 1001 to Enable Erase Security
	//Bit[9] 1 to Enable Write Security
	//Bit[8] 1 to Enable Read Security
	LockBitsArray[1] = 0x000000;
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = 0x000100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00800073);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);		
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00000000)
				  		MASK(0x00100000);
		I2C_STOP;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{		
		LockBitsArray[1] = 0x000200;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00400073);
    	SDR 32 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00000000)
				  		MASK(0x00200000);
		I2C_STOP;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{		
		LockBitsArray[1] = 0x000300;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00C00073);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00000000)
				  		MASK(0x00300000);
		I2C_STOP;
	}
	// Lock SEC_ERASE_L
	ELSEIF (ISSECURED == 4)
	{
		LockBitsArray[1] = 0x002400;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00240073);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x02000000)
				  		MASK(0x02000000);
		I2C_STOP;
	}	
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (ISSECURED == 5)
	{
		LockBitsArray[1] = 0x002500;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00A40073);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x02000000)
				  		MASK(0x02100000);
		I2C_STOP;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (ISSECURED == 6)
	{
		LockBitsArray[1] = 0x002600;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00640073);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  			TDO(0x02000000)
				  			MASK(0x02200000);
		I2C_STOP;
	}	
	// Lock SEC_PROG_L SEC_ERASE_L SEC_READ_L
	ELSEIF (ISSECURED == 7)
	{
		LockBitsArray[1] = 0x002700;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00E40073);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  			TDO(0x02000000)
				  			MASK(0x02300000);
		I2C_STOP;
	}	
}
function JTAGI2CSRAM_SECURE {
	datastream LockBitsArray[1][24];
	//ISC_PROGRAM_SECURITY operand is as below
	//Bit[18:16] Flash Sector Address
	//Bit[15:14] 11 to Enable Password Protection
	//Bit[13:10] 1001 to Enable Erase Security
	//Bit[9] 1 to Enable Write Security
	//Bit[8] 1 to Enable Read Security	
	
	LockBitsArray[1] = 0x000000;
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = 0x000100;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1001);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x08);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;		
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = 0x000200;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1040);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x04);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = 0x000300;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x0C);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	// Lock SEC_ERASE_L
	ELSEIF (ISSECURED == 4)
	{
		LockBitsArray[1] = 0x002400;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1024);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x40)
						MASK (0x40);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (ISSECURED == 5)
	{				
		LockBitsArray[1] = 0x002500;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10A4);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x08);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x40)
						MASK (0x40);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (ISSECURED == 6)
	{				
		LockBitsArray[1] = 0x002600;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1064);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x04);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x40)
						MASK (0x40);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	// Lock SEC_PROG_L SEC_ERASE_L SEC_READ_L
	ELSEIF (ISSECURED == 7)
	{				
		LockBitsArray[1] = 0x002700;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10E4);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x0C);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x40)
						MASK (0x40);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
}
//////////////////////////////////////////////////////////////////////////
function SPICHECK_PASSWORD 
{
	datastream SaveProtectKey[1][128];
	PasswordEn = 0;	
	IF (ProtectKey.row = 1)
	{	
		setpin ISPEN LOW;		  
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  128  TDI(SaveProtectKey[1]);
		setpin ISPEN HIGH;
		
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00008000)
					  		MASK(0x04008000);
			setpin ISPEN HIGH;		
			PasswordEn = 1;									  
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW;
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			set_return_code (-93);				  
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		TRY 1 
		{
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  			TDO(0x00000000)
					  			MASK(0x04000000);
			setpin ISPEN HIGH;											  
		}
		ELSE
		{
			setpin ISPEN HIGH;
			TRY 1 
			{
				setpin ISPEN LOW;
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00308000)
						  		MASK(0x00308000);
				setpin ISPEN HIGH;											  
			}
			ELSE
			{
				setpin ISPEN HIGH;
				setpin ISPEN LOW;
				! Shift in ISC DISABLE(0x26) instruction;
		    	SDR	32 	TDI (0x00000064);
				setpin ISPEN HIGH;
				print (1,"A Password Key is required. Please provide the Password Key.");
			}
		}
			
	}		
}
function I2CCHECK_PASSWORD 
{
	datastream SaveProtectKey[1][128];
	PasswordEn = 0;	
	IF (ProtectKey.row = 1)
	{	
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);		  
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  128  TDI(SaveProtectKey[1]);
		I2C_STOP;
		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00008000)
					  		MASK(0x04008000);
			I2C_STOP;	
			PasswordEn = 1;											  
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		TRY 1 
		{
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  			TDO(0x00000000)
					  			MASK(0x04000000);
			I2C_STOP;					  				  			  
		}
		ELSE
		{
			I2C_STOP;
			TRY 1 
			{
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00308000)
						  		MASK(0x00308000);
				I2C_STOP;											  
			}
			ELSE
			{
				I2C_STOP;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
				I2C_STOP;
				print (1,"A Password Key is required. Please provide the Password Key.");
			}
		}
	}	
}
function JTAGI2CCHECK_PASSWORD 
{
	datastream SaveProtectKey[1][128];
	datastream DataByte[1][8];
	PasswordEn = 0;	
	IF (ProtectKey.row = 1)
	{	
		SaveProtectKey[1] = ProtectKey[1];
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR	16	TDI (0x10BC);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Password Key; 	
    	DataByte[1] = SaveProtectKey[1];
    	SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SaveProtectKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SaveProtectKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (SaveProtectKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SaveProtectKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SaveProtectKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SaveProtectKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SaveProtectKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 64);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 72);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 80);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 88);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 96);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 104);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 112);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 120);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		TRY 1 {
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x01)
							MASK (0x01);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x20);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;				
			PasswordEn = 1;			  														  
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 200; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100; 	 	
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		TRY 1 {
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x20);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;	 				  			  
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);				
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR	16	TDI (0x103C);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			TRY 1 
			{
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x01)
								MASK (0x01);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x0C)
								MASK (0x0C);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;	 				  			  
			}
			ELSE
			{	
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in ISC DISABLE(0x26) instruction;
				SDR	16	TDI (0x1026);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 2 DELAY 200; 
				! Shift in ISC DISABLE(0x26) instruction;
			    SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY 1000;     
				     
				! Shift in BYPASS(0xFF) instruction;
			    SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY 100; 	 	
				print (1,"A Password Key is required. Please provide the Password Key.");
			}
		}
	}
}
////////////////////////////////////////////////////////////////////////////////////////////
function SPICHECK_SRAM_ERASE_LOCK {	
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x02000000);
		setpin ISPEN HIGH;					  				  			  
	}
	ELSE
	{	
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1,"The SRAM Erase Lock is set. Cannot continue.");
	}	
}										
function I2CCHECK_SRAM_ERASE_LOCK {
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x02000000);
		I2C_STOP;				  	
	}
	ELSE{	
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1,"The SRAM Erase Lock is set. Cannot continue.");
	}
}
function JTAGI2CCHECK_SRAM_ERASE_LOCK {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1{
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x40);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;							  				  	
	}
	ELSE{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 200; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100; 	 			
		print (1,"The SRAM Erase Lock is set. Cannot continue.");
	}
}
///////////////////////////////////////////////////////////////////////////////////
function SPICHECK_SRAM_PROG_LOCK {	
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00200000)
				  		MASK(0x00200000);
		setpin ISPEN HIGH;					  				  			  
	}
	ELSE
	{	
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1,"The SRAM Write Lock is set. Cannot continue.");
	}		
}
function I2CCHECK_SRAM_PROG_LOCK {
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00200000)
				  		MASK(0x00200000);
		I2C_STOP;				  	
	}
	ELSE{	
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1,"The SRAM Program Lock is set. Cannot continue.");
	}
}
function JTAGI2CCHECK_SRAM_PROG_LOCK {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1{
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x04);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;							  				  	
	}
	ELSE{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 200; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100; 	 			
		print (1,"The SRAM Program Lock is set. Cannot continue.");
	}
}
/////////////////////////////////////////////////////////////////////////////////
function SPICHECK_SRAM_READ_LOCK {
	TRY 1{
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00100000)
				  			MASK(0x00100000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;				  
		print (1,"The SRAM Read Lock is set. Cannot continue.");
	}
}
function I2CCHECK_SRAM_READ_LOCK {
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00100000)
				  			MASK(0x00100000);
		I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;				  
		print (1,"The SRAM Read Lock is set. Cannot continue.");
	}
}
function JTAGI2CCHECK_SRAM_READ_LOCK {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1{
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x08)
						MASK (0x08);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 200; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100; 	 				  
		print (1,"The SRAM Read Lock is set. Cannot continue.");
	}
}
//////////////////////////////////////////////////////////////////////
function SPICHECK_ERASE_SECURITY 
{

	TRY 1{
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x02000000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;				  
		print (1,"Current Sector Erase Lock is set. Cannot continue.");
	}
}
function I2CCHECK_ERASE_SECURITY {
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x02000000);
		I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;				  
		print (1,"Current Sector Erase Lock is set. Cannot continue.");
	}
}
function JTAGI2CCHECK_ERASE_SECURITY 
{
	TRY 1{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x40);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;					  
		print (1,"Current Sector Erase Lock is set. Cannot continue.");
	}
}
/////////////////////////////////////////////////////////////////////////////////
function SPICHECK_PROGRAM_SECURITY {
	TRY 1{
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00200000)
				  			MASK(0x00200000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;				  
		print (1,"Current Sector been program locked or passwrod protected. Cannot continue.");
	}
}
function I2CCHECK_PROGRAM_SECURITY {
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00200000)
				  			MASK(0x00200000);
		I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;				  
		print (1,"Current Sector been program locked or passwrod protected. Cannot continue.");
	}
}
function JTAGI2CCHECK_PROGRAM_SECURITY {
	TRY 1{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x04);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;					  
		print (1,"Current Sector been program locked or passwrod protected. Cannot continue.");
	}
}
///////////////////////////////////////////////////////////////////////////////////
function SPICHECK_READ_SECURITY {
	TRY 1{
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00100000)
				  			MASK(0x00100000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;				  
		print (1,"Current Sector Read Lock is set. Cannot continue.");
	}
}
function I2CCHECK_READ_SECURITY {
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00100000)
				  			MASK(0x00100000);
		I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;				  
		print (1,"Current Sector Read Lock is set. Cannot continue.");
	}
}
function JTAGI2CCHECK_READ_SECURITY {
	TRY 1{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x08)
						MASK (0x08);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;					  
		print (1,"Current Sector Read Lock is set. Cannot continue.");
	}
}
//////////////////////////////////////////////////////////////////////////////////////
function SPISAVE_STATUS 
{
	datastream SavedSTATUS[1][64];
	datastream SavedSTATUS0[1][32];
	datastream SavedSTATUS1[1][32];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR 32 TDI(#0^32)
	       TDO(SavedSTATUS0[1]);
	setpin ISPEN HIGH;	
	SavedSTATUS0[1] = $SavedSTATUS0[1];
	
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR 32 TDI (0x000000BC);
	SDR 32 TDI(#0^32)
	       TDO(SavedSTATUS1[1]);
	setpin ISPEN HIGH;	
	SavedSTATUS1[1] = $SavedSTATUS1[1];
	SavedSTATUS[1] = SavedSTATUS0[1] @ SavedSTATUS1[1];	
	// Write To file 
	fopen NewFile att "wa"
	format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile; 				  	
}
function I2CSAVE_STATUS {
	datastream SavedSTATUS[1][64];
	datastream SavedSTATUS0[1][32];
	datastream SavedSTATUS1[1][32];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS0);
	I2C_STOP;	
	SavedSTATUS0[1] = $SavedSTATUS0[1];
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR 32 TDI (0x000000BC);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR 32 TDI(#0^32)
	       TDO(SavedSTATUS1[1]);
	I2C_STOP;	
	SavedSTATUS1[1] = $SavedSTATUS1[1];
	SavedSTATUS[1] = SavedSTATUS0[1] @ SavedSTATUS1[1];	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;			  	
}
function JTAGI2CSAVE_STATUS 
{
	datastream DataByte[1][8];
	datastream SavedSTATUS[1][64];
	datastream SavedSTATUS0[1][32];
	datastream SavedSTATUS1[1][32];
	file NewFile = "FILE_SAVE";
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS0[1] = ((SavedSTATUS0[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS0[1] = ((SavedSTATUS0[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS0[1] = ((SavedSTATUS0[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedSTATUS0[1] = ((SavedSTATUS0[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 
	
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR	16	TDI (0x103D);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 
	
	print (0,SavedSTATUS1);
	SavedSTATUS[1] = SavedSTATUS0[1] @ SavedSTATUS1[1];	
	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;				  	
}
function SVF_SPISAVE_STATUS {
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR 32 TDI(#0^32)
	       TDO(#0^32)
		   MASK(#0^32);
	setpin ISPEN HIGH;			  	
}
function SVF_I2CSAVE_STATUS {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI(#0^32)
	       TDO(#0^32)
		   MASK(#0^32);
	I2C_STOP;	  	
}
function SVF_JTAGI2CSAVE_STATUS 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (0x00)
			MASK (0x00);
	SDR	8	TDI  (0x00)
			TDO  (0x00)
			MASK (0x00);
	SDR	8	TDI  (0x00)
			TDO  (0x00)
			MASK (0x00);
	SDR	8	TDI  (0x00)
			TDO  (0x00)
			MASK (0x00);		
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 	
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR	16	TDI (0x103D);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (0x00)
			MASK (0x00);
	SDR	8	TDI  (0x00)
			TDO  (0x00)
			MASK (0x00);
	SDR	8	TDI  (0x00)
			TDO  (0x00)
			MASK (0x00);
	SDR	8	TDI  (0x00)
			TDO  (0x00)
			MASK (0x00);		
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 			  	
}
//////////////////////////////////////////////////////////////////////
function SPIREFRESH_FUNCTION {
	setpin ISPEN LOW;
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 32	TDI (0x0000009E);
    setpin ISPEN HIGH;
    RUN_TEST DELAY 5000;
}
function I2CREFRESH_FUNCTION {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 32	TDI (0x0000009E);
    I2C_STOP;
    RUN_TEST DELAY 5000;	
}
function JTAGI2CREFRESH_FUNCTION 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR	16	TDI (0x1079);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 5000;		
}	
//////////////////////////////////////////////////////////////////////////////
function SPIFLASH_ENABLE {
	setpin ISPEN LOW;
	! Shift in ISC ENABLE(0xC6) instruction;
	SDR 32 TDI (0x00001063);
	setpin ISPEN HIGH;
	RUN_TEST DELAY 200;
}
function I2CFLASH_ENABLE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 32 TDI (0x00001063);
    I2C_STOP;
    RUN_TEST DELAY PWV;
}
function JTAGI2CFLASH_ENABLE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);					
	! Shift in ISC ENABLE(0xC6) instruction;
	SDR	16	TDI (0x10C6);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1008);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
}
////////////////////////////////////////////////////////////////
function SPIFLASH_SUDO_ENABLE {
	setpin ISPEN LOW;
	! Shift in ISC ENABLE(0xC6) instruction;
	SDR 32 TDI (0x00005063);
	setpin ISPEN HIGH;
	RUN_TEST DELAY 200;
}
function I2CFLASH_SUDO_ENABLE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 32 TDI (0x00005063);
    I2C_STOP;
    RUN_TEST DELAY PWV;
}
function JTAGI2CFLASH_SUDO_ENABLE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);					
	! Shift in ISC ENABLE(0xC6) instruction;
	SDR	16	TDI (0x10C6);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x100A);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
}
////////////////////////////////////////////////////////////////////////////
function SPIFLASH_TRANSPARENT_ENABLE {
	setpin ISPEN LOW;
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 32 TDI (0x0000102E);
    setpin ISPEN HIGH;
	RUN_TEST DELAY 200;
}
function I2CFLASH_TRANSPARENT_ENABLE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 24 TDI (0x00102E);
    I2C_STOP;
    RUN_TEST DELAY PWV;
}
function JTAGI2CFLASH_TRANSPARENT_ENABLE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_ENABLE_X(0x74) instruction;
	SDR	16	TDI (0x1074);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1008);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
//////////////////////////////////////////////////////////////
function SPISELECT_CFG {
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00000062);
	setpin ISPEN HIGH;	
}
function I2CSELECT_CFG {
	loop PWP {
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00000062);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
						TDO(0x00000000)
						MASK(0x00070000);			
	}
	I2C_STOP;
}
function JTAGI2CSELECT_CFG 
{
	loop PWP 
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR	16	TDI (0x1046);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 	
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 	
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR	8	TDI  (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0xE0);
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 
}
/////////////////////////////////////////////////////////////////
function SPISELECT_UFM {
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x0000C062);
	setpin ISPEN HIGH;	
}
function I2CSELECT_UFM {
	loop PWP {
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x0000C062);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
						TDO(0x00060000)
						MASK(0x00070000);				
	}
	I2C_STOP;
}
function JTAGI2CSELECT_UFM 
{
	loop PWP 
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR	16	TDI (0x1046);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1003);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 	
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 	
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR	8	TDI  (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x60)
						MASK (0xE0);
		RUN_TEST IDLE TCK 1000 ;
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 
}
///////////////////////////////////////////////////////////////////////
function SPISELECT_FEA {
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00002062);
	setpin ISPEN HIGH;	
}
function I2CSELECT_FEA {
	loop PWP
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00002062);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
						TDO(0x00010000)
						MASK(0x00070000);				
	}
	I2C_STOP;	
}
function JTAGI2CSELECT_FEA {
	loop PWP 
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR	16	TDI (0x1046);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1004);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 	
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 	
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR	8	TDI  (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x80)
						MASK (0xE0);
		RUN_TEST IDLE TCK 1000 ;
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 
}
////////////////////////////////////////////////////////////////////////////////
function SPICHECK_CFG_PASSWORD {
	datastream SaveProtectKey[1][128];
	datastream TempStatus[1][32];
	PasswordEn = 0;	
	IF (ProtectKey.row = 1)
	{
		setpin ISPEN LOW;		  
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  128  TDI(SaveProtectKey[1]);
		setpin ISPEN HIGH;
		
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00008000)
					  		MASK(0x04008000);
			setpin ISPEN HIGH;	
			PasswordEn = 1;				
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW;
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			set_return_code (-93);				  
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		! Select CFG Sector;
		@SPISELECT_CFG();
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  			TDO(0x00000000)
					  			MASK(0x04000000);
			setpin ISPEN HIGH;					  				  			  
		}
		ELSE
		{
			setpin ISPEN HIGH;
			TRY 1 {
				setpin ISPEN LOW;
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				SDR_VERIFY  32 	TDI(#0^32)
								TDO(0x00308000)
								MASK(0x00308000);
				setpin ISPEN HIGH;	
			}
			ELSE
			{
				setpin ISPEN HIGH;	
				setpin ISPEN LOW;
				! Shift in ISC DISABLE(0x26) instruction;
		    	SDR	32 	TDI (0x00000064);
				setpin ISPEN HIGH;
				print (1,"A Password Key is required. Please provide the Password Key.");
			}
		}
	}	
}
function I2CCHECK_CFG_PASSWORD {
	datastream SaveProtectKey[1][128];
	datastream TempStatus[1][32];
	PasswordEn = 0;	
	IF (ProtectKey.row = 1)
	{	
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);		  
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  128  TDI(SaveProtectKey[1]);
		I2C_STOP;
		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00008000)
					  		MASK(0x04008000);
			I2C_STOP;	
			PasswordEn = 1;				
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		! Select CFG Sector;
		@I2CSELECT_CFG();
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  			TDO(0x00000000)
					  			MASK(0x04000000);
			I2C_STOP;					  				  			  
		}
		ELSE
		{	
			I2C_STOP;
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  32 	TDI(#0^32)
								TDO(0x00308000)
								MASK(0x00308000);
				I2C_STOP;			
			}			
			ELSE
			{
				I2C_STOP;	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
				I2C_STOP;
				print (1,"A Password Key is required. Please provide the Password Key.");
			}
		}
	}	
}
function JTAGI2CCHECK_CFG_PASSWORD {
	datastream SaveProtectKey[1][128];
	datastream DataByte[1][8];
	PasswordEn = 0;	
	IF (ProtectKey.row = 1)
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR	16	TDI (0x10BC);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Password Key; 	
    	DataByte[1] = ProtectKey[1];
    	SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (ProtectKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 64);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 72);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 80);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 88);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 96);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 104);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 112);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 120);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		TRY 1 {
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x01)
							MASK (0x01);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x20);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;			
			PasswordEn = 1;			  														  
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 200; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100; 	 	
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		! Select CFG Sector;
		@JTAGI2CSELECT_CFG();
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		TRY 1 {
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x20);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;	 				  			  
		}
		ELSE
		{	
			! Select Feature Sector;
			@JTAGI2CSELECT_CFG();
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);				
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR	16	TDI (0x103C);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			TRY 1 {
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x01)
								MASK (0x01);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x0C)
								MASK (0x0C);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;	 				  			  
			}
			ELSE			
			{
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in ISC DISABLE(0x26) instruction;
				SDR	16	TDI (0x1026);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 2 DELAY 200; 
				! Shift in ISC DISABLE(0x26) instruction;
				SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY 1000;     
					 
				! Shift in BYPASS(0xFF) instruction;
				SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY 100; 	 	
				print (1,"A Password Key is required. Please provide the Password Key.");
			}
		}
	}
}
/////////////////////////////////////////////////////////////////////////////////
function SPICHECK_UFM_PASSWORD {
	datastream SaveProtectKey[1][128];
	datastream TempStatus[1][32];
	PasswordEn = 0;	
	IF (ProtectKey.row = 1)
	{	
		setpin ISPEN LOW;		  
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  128  TDI(SaveProtectKey[1]);
		setpin ISPEN HIGH;
		
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00008000)
					  		MASK(0x04008000);
			setpin ISPEN HIGH;			
			PasswordEn = 1;									  
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW;
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			set_return_code (-93);				  
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		! Select UFM Sector;
		@SPISELECT_UFM();
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  			TDO(0x00000000)
					  			MASK(0x04000000);
			setpin ISPEN HIGH;					  				  			  
		}
		ELSE
		{	
			setpin ISPEN HIGH;
			TRY 1 {
				setpin ISPEN LOW;
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				SDR_VERIFY  32 	TDI(#0^32)
								TDO(0x00308000)
								MASK(0x00308000);
				setpin ISPEN HIGH;	
			}	
			ELSE
			{
				setpin ISPEN HIGH;	
				setpin ISPEN LOW;
				! Shift in ISC DISABLE(0x26) instruction;
		    	SDR	32 	TDI (0x00000064);
				setpin ISPEN HIGH;
				print (1,"A Password Key is required. Please provide the Password Key.");
			}
		}
	}	
}
function I2CCHECK_UFM_PASSWORD {
	datastream SaveProtectKey[1][128];
	datastream TempStatus[1][32];
	PasswordEn = 0;	
	
	IF (ProtectKey.row = 1)
	{	
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);		  
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  128  TDI(SaveProtectKey[1]);
		I2C_STOP;
		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00008000)
					  		MASK(0x04008000);
			I2C_STOP;		
			PasswordEn = 1;										  
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		! Select UFM Sector;
		@I2CSELECT_UFM();
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  			TDO(0x00000000)
					  			MASK(0x04000000);
			I2C_STOP;					  				  			  
		}
		ELSE
		{	
			I2C_STOP;
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  32 	TDI(#0^32)
                                TDO(0x00308000)
                                MASK(0x00308000);
				I2C_STOP;				
			}			
			ELSE
			{
				I2C_STOP;	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
				I2C_STOP;
				print (1,"A Password Key is required. Please provide the Password Key.");
			}
		}
	}	
}
function JTAGI2CCHECK_UFM_PASSWORD {
	datastream SaveProtectKey[1][128];
	datastream DataByte[1][8];
	PasswordEn = 0;	
	IF (ProtectKey.row = 1)
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR	16	TDI (0x10BC);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Password Key; 	
    	DataByte[1] = ProtectKey[1];
    	SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (ProtectKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 64);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 72);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 80);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 88);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 96);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 104);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 112);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 120);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		TRY 1 {
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x01)
							MASK (0x01);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x20);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;	
			PasswordEn = 1;			 														  
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 200; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100; 	 	
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		! Select UFM Sector;
		@JTAGI2CSELECT_UFM();
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		TRY 1 {
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x20);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;	 				  			  
		}
		ELSE
		{	
			! Select Feature Sector;
			@JTAGI2CSELECT_UFM();
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);				
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR	16	TDI (0x103C);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			TRY 1 {
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x01)
								MASK (0x01);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x0C)
								MASK (0x0C);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;	 				  			  
			}
			ELSE		
			{
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in ISC DISABLE(0x26) instruction;
				SDR	16	TDI (0x1026);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 2 DELAY 200; 
				! Shift in ISC DISABLE(0x26) instruction;
				SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY 1000;     
					 
				! Shift in BYPASS(0xFF) instruction;
				SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY 100; 	 	
				print (1,"A Password Key is required. Please provide the Password Key.");
			}
		}
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////
function SPICHECK_FEATURE_PASSWORD {
	datastream SaveProtectKey[1][128];
	IF (ProtectKey.row = 1)
	{	
		setpin ISPEN LOW;		  
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  128  TDI(SaveProtectKey[1]);
		setpin ISPEN HIGH;
		
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00008000)
					  		MASK(0x04008000);
			setpin ISPEN HIGH;											  
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW;
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			set_return_code (-93);				  
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		! Select Feature Sector;
		@SPISELECT_FEA();
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  			TDO(0x00000000)
					  			MASK(0x04000000);
			setpin ISPEN HIGH;					  				  			  
		}
		ELSE
		{	
			setpin ISPEN HIGH;		
			TRY 1 {
				setpin ISPEN LOW;
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00308000)
						  		MASK(0x00308000);
				setpin ISPEN HIGH;											  
			}
			ELSE
			{
				setpin ISPEN HIGH;
				setpin ISPEN LOW;
				! Shift in ISC DISABLE(0x26) instruction;
		    	SDR	32 	TDI (0x00000064);
				setpin ISPEN HIGH;
				print (1,"A Password Key is required. Please provide the Password Key.");
			}
		}
	}	
}
function I2CCHECK_FEATURE_PASSWORD {
	datastream SaveProtectKey[1][128];
	IF (ProtectKey.row = 1)
	{	
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);		  
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  128  TDI(SaveProtectKey[1]);
		I2C_STOP;
		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00008000)
					  		MASK(0x04008000);
			I2C_STOP;											  
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		! Select FEA Sector;
		@I2CSELECT_FEA();
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  			TDO(0x00000000)
					  			MASK(0x04000000);
			I2C_STOP;					  				  			  
		}
		ELSE
		{	
			I2C_STOP;
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00308000)
						  		MASK(0x00308000);
				I2C_STOP;											  
			}
			ELSE
			{
				I2C_STOP;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
				I2C_STOP;
				print (1,"A Password Key is required. Please provide the Password Key.");
			}
		}
	}	
}
function JTAGI2CCHECK_FEATURE_PASSWORD {
	datastream DataByte[1][8];
	IF (ProtectKey.row = 1)
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR	16	TDI (0x10BC);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Password Key; 	
    	DataByte[1] = ProtectKey[1];
    	SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (ProtectKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 64);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 72);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 80);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 88);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 96);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 104);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 112);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 120);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		TRY 1 {
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x01)
							MASK (0x01);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x20);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;				
					  														  
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 200; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100; 	 	
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		! Select Feature Sector;
		@JTAGI2CSELECT_FEA();
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		TRY 1 {
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x20);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;	 				  			  
		}
		ELSE
		{	
			! Select Feature Sector;
			@JTAGI2CSELECT_FEA();
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);				
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR	16	TDI (0x103C);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			TRY 1 {
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x01)
								MASK (0x01);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x0C)
								MASK (0x0C);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;	 				  			  
			}
			ELSE
			{		
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in ISC DISABLE(0x26) instruction;
				SDR	16	TDI (0x1026);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 2 DELAY 200; 
				! Shift in ISC DISABLE(0x26) instruction;
			    SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY 1000;     
				     
				! Shift in BYPASS(0xFF) instruction;
			    SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY 100; 	 	
				print (1,"A Password Key is required. Please provide the Password Key.");
			}
		}
	}
}
//////////////////////////////////////////////////////////////////////////////////////////////
function SPICHECK_STATUS {
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR_VERIFY  32 	TDI(#0^32)
			  		TDO(0x00000000)
			  		MASK(0x000C0000);
	setpin ISPEN HIGH;
}
function I2CCHECK_STATUS {
	loop PWP
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
					TDO(0x00000000)
					MASK(0x000C0000);	
	}
	I2C_STOP;
}
function I2CCHECK_STATUS_NEW_ADDR {
	datastream JTAGI2CN_WRITE[1][8];
	datastream JTAGI2CN_READ[1][8];
	JTAGI2CN_WRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	JTAGI2CN_READ[1] = (NEW_I2C_ADDR_READ);
	loop PWP
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (JTAGI2CN_WRITE[1]);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (JTAGI2CN_READ[1]);
		SDR_VERIFY  32 	TDI(#0^32)
					TDO(0x00000000)
					MASK(0x000C0000);
	}
	I2C_STOP;
}
function I2CCHECK_STATUS_DEFAULT {
	loop PWP
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (0x01);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (0x81);
		SDR_VERIFY  32 	TDI(#0^32)
					TDO(0x00000000)
					MASK(0x000C0000);
	}
	I2C_STOP;
}
function JTAGI2CCHECK_STATUS {
	TRY 1
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x30);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;	
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
		SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			 
		! Shift in BYPASS(0xFF) instruction;
		SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;		
		print (1,"Failed in Function JTAGI2CCHECK_STATUS. Cannot continue.");	
	}
}
function JTAGI2CCHECK_STATUS_DEFAULT {
	datastream JTAGI2CN_WRITE[1][8];
	datastream JTAGI2CN_READ[1][8];
	JTAGI2CN_WRITE[1] = (DEFAULT_ADDR_WRITE ) ;
	JTAGI2CN_WRITE[1] = $JTAGI2CN_WRITE[1];
	JTAGI2CN_READ[1] = (DEFAULT_ADDR_READ) ;
	JTAGI2CN_READ[1] = $JTAGI2CN_READ[1];
	TRY 1
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ (JTAGI2CN_WRITE[1]));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ (JTAGI2CN_READ[1]));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x30);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;	
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
		SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			 
		! Shift in BYPASS(0xFF) instruction;
		SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;		
		print (1,"Failed in Function JTAGI2CCHECK_STATUS_DEFAULT. Cannot continue.");	
	}
}
function JTAGI2CCHECK_STATUS_NEW_ADDR {
	datastream JTAGI2CN_WRITE[1][8];
	datastream JTAGI2CN_READ[1][8];
	JTAGI2CN_WRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	JTAGI2CN_WRITE[1] = $JTAGI2CN_WRITE[1];
	JTAGI2CN_READ[1] = (NEW_I2C_ADDR_READ) ;
	JTAGI2CN_READ[1] = $JTAGI2CN_READ[1];
	TRY 1
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ (JTAGI2CN_WRITE[1]));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ (JTAGI2CN_READ[1]));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x30);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;	
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
		SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			 
		! Shift in BYPASS(0xFF) instruction;
		SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;		
		print (1,"Failed in Function JTAGI2CCHECK_STATUS_NEW_ADDR. Cannot continue.");	
	}
}
/////////////////////////////////////////////////////////////////////////////////////////
function SPIFEATURE_PROGRAM {
	datastream FeatureArray[1][64];
	datastream ControlNV[1][32];
	datastream ControlNV2[1][32];
	IF (ArchArray_TDI.row = 1)
	{
		TRY 1 {
			ArchArray_TDI[1] = $ArchArray_TDI[1];
			FeatureArray[1] = ArchArray_TDI[1] << 32;
			FeatureArray[1] = $FeatureArray[1];
			ControlNV[1] = ArchArray_TDI[1];
			ControlNV[1] = $ControlNV[1];
			
			setpin ISPEN LOW;
			! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
			SDR 32	TDI (0x00000027);
			SDR 64 TDI(FeatureArray[1]);
			setpin ISPEN HIGH;	
			loop PWP {
				setpin ISPEN HIGH;	
				RUN_TEST DELAY PWV;
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
				setpin ISPEN HIGH;
			}
			setpin ISPEN HIGH;	 
			setpin ISPEN LOW; 
			! Shift in LSC_READ_FEATURE (0xE7) instruction;
			SDR 32	TDI (0x000000E7);
			SDR_VERIFY 64   TDI(#0^64)
							TDO(FeatureArray[1])
							MASK(#1^64);
			setpin ISPEN HIGH;	
								
			setpin ISPEN LOW; 
			! Shift in in LSC_PROG_NV_CR1(0xEA) instruction;
			SDR 32	TDI (0x00000057);	    
			SDR 32 TDI(ControlNV[1]);
			setpin ISPEN HIGH;	
			loop PWP {
				setpin ISPEN HIGH;				
				RUN_TEST DELAY PWV;
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
				setpin ISPEN HIGH;
			}
			setpin ISPEN HIGH;	 
			ControlNV2[1] = ControlNV[1] & 0x00000020;
			IF (ControlNV2[1] != 0x00000020)
			{	
				setpin ISPEN LOW; 
				! Shift in LSC READ CONTROL_1(0x21) instruction;
				SDR 32 TDI (0x00000084);
				SDR_VERIFY 32 TDI (0x00000000)
							  TDO(ControlNV[1])
							  MASK(0xFFFFFFFF);
				setpin ISPEN HIGH;
			}	
		}
		ELSE
		{		
			setpin ISPEN HIGH;
			setpin ISPEN LOW;
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1,"Failed at Feature Row Program. Cannot continue.");
		}
	}
}
function I2CFEATURE_PROGRAM 
{
	datastream FeatureArray[1][64];
	datastream ControlNV[1][32];
	datastream JTAGI2CN_WRITE[1][8];
	datastream JTAGI2CN_READ[1][8];
	
	JTAGI2CN_WRITE[1] = ( NEW_I2C_ADDR_WRITE );
	JTAGI2CN_READ[1] = ( NEW_I2C_ADDR_READ );
	IF (ArchArray_TDI.row = 1)
	{	
		TRY 1 
		{
			//print (0,JTAGI2CN_WRITE);
			//print (0,JTAGI2CN_READ);
			ArchArray_TDI[1] = $ArchArray_TDI[1];
			ControlNV[1] = ArchArray_TDI[1];
			ControlNV[1] = $ControlNV[1];
			//print (0,ControlNV);
			
			FeatureArray[1] = ArchArray_TDI[1] << 32;
			FeatureArray[1] = $FeatureArray[1];
			//print (0,FeatureArray);

			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (0x01);
			! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
			SDR 32	TDI (0x00000027);
			SDR 64 TDI(FeatureArray[1]);
			I2C_STOP;
			RUN_TEST DELAY 1000;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (0x01);
			! Shift in LSC_READ_FEATURE (0xE7) instruction;
			SDR 32	TDI (0x000000E7);
			RUN_TEST DELAY PWV;
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (0x81);
			SDR_VERIFY 64   TDI(#0^64)
							TDO(FeatureArray[1])
							MASK(#1^64);
			I2C_STOP;
			
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (0x01);
			! Shift in LSC_PROG_NV_CR1(0xEA) instruction;
			SDR 32	TDI (0x00000057);	    
			SDR 32 TDI(ControlNV[1]);
			I2C_STOP;	
			RUN_TEST DELAY 1000;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (JTAGI2CN_WRITE[1]);
			! Shift in LSC READ CONTROL_1(0x21) instruction;
			SDR 32 TDI (0x00000084);
			RUN_TEST DELAY PWV;
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (JTAGI2CN_READ[1]);
			SDR_VERIFY 32 TDI (0x00000000)
						  TDO(ControlNV[1])
						  MASK(0xFFFFFFFF);
			I2C_STOP;	
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (0x01); 
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	32 	TDI (0x00000064);
			I2C_STOP;

			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (0x01); 
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	32 	TDI (0x00000064);
			I2C_STOP;			
			print (1,"Failed at Feature Row Program. Cannot continue.");
		}
	}
}
function JTAGI2CFEATURE_PROGRAM 
{
	datastream DataByte[1][8];
	datastream FeatureArray[1][64];
	datastream ControlNV[1][32];
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	datastream JTAGI2CN_WRITE[1][8];
	datastream JTAGI2CN_READ[1][8];
	
	JTAGI2CSLAVEADDRWRITE[1] = (DEFAULT_ADDR_WRITE) ;
	JTAGI2CSLAVEADDRWRITE[1] = $JTAGI2CSLAVEADDRWRITE[1];
	JTAGI2CSLAVEADDRREAD[1] = (DEFAULT_ADDR_READ) ;
	JTAGI2CSLAVEADDRREAD[1] = $JTAGI2CSLAVEADDRREAD[1];
	JTAGI2CN_WRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	JTAGI2CN_WRITE[1] = $JTAGI2CN_WRITE[1];
	JTAGI2CN_READ[1] = (NEW_I2C_ADDR_READ) ;
	JTAGI2CN_READ[1] = $JTAGI2CN_READ[1];
	IF (ArchArray_TDI.row = 1)
	{
		TRY 1
		{
			//print (0,SLAVE_ADDRESS_WRITE);
			//print (0,JTAGI2CN_WRITE);
			//print (0,JTAGI2CN_READ);
			ArchArray_TDI[1] = $ArchArray_TDI[1];
			ControlNV[1] = ArchArray_TDI[1];
			//print (0,ControlNV);

			FeatureArray[1] = ArchArray_TDI[1] << 32;
			//print (0,FeatureArray);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;

			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in LSC_PROG_FEATURE(0xE4) instruction;		
			SDR	16	TDI (0x10E4);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = FeatureArray[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureArray[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureArray[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureArray[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureArray[1] << 32);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureArray[1] << 40);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST	IDLE TCK 2 DELAY 1;
			DataByte[1] = (FeatureArray[1] << 48);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureArray[1] << 56);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;										
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 1000;																
					
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ (JTAGI2CSLAVEADDRWRITE[1])); 
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in LSC_READ_FEATURE (0xE7) instruction;
			SDR	16	TDI (0x10E7);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI ((0x90) @ (JTAGI2CSLAVEADDRREAD[1])); 
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = FeatureArray[1];
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (FeatureArray[1] << 8);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (FeatureArray[1] << 16);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);				
			DataByte[1] = (FeatureArray[1] << 24);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (FeatureArray[1] << 32);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);				
			DataByte[1] = (FeatureArray[1] << 40);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);				
			DataByte[1] = (FeatureArray[1] << 48);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (FeatureArray[1] << 56);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;	
		
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ (JTAGI2CSLAVEADDRWRITE[1])); 
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in LSC_PROG_NV_CR1(0xEA) instruction;
			SDR	16	TDI (0x10EA);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = ControlNV[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ControlNV[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ControlNV[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ControlNV[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 1000;
		
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ (JTAGI2CN_WRITE[1]));
			RUN_TEST IDLE TCK 1000 ; 
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in LSC READ CONTROL_1(0x21) instruction;
			SDR	16	TDI (0x1021);
			RUN_TEST IDLE TCK 1000 ; 
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ; 
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ; 
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ; 
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ (JTAGI2CN_READ[1]));
			RUN_TEST IDLE TCK 1000 ; 
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ; 
			DataByte[1] = ControlNV[1];
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI (0x00)
							TDO (DataByte[1])
							MASK(0xFF);	
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ControlNV[1] << 8);
			SDR_VERIFY	8	TDI (0x00)
							TDO (DataByte[1])
							MASK(0xFF);	
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ControlNV[1] << 16);
			SDR_VERIFY	8	TDI (0x00)
							TDO (DataByte[1])
							MASK(0xFF);	
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ControlNV[1] << 24);
			SDR_VERIFY	8	TDI (0x00)
							TDO (DataByte[1])
							MASK(0xFF);	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ; 
													
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in ISC DISABLE(0x26) instruction;
			SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
				 
			! Shift in BYPASS(0xFF) instruction;
			SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100;		
			print (1,"Programming Feature Row Failed. Cannot continue.");			
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////
function SPIFEATURE_ERASE {
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00002470);
    setpin ISPEN HIGH;	
    loop PWE {
    	setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;	
}
function I2CFEATURE_ERASE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00002470);
	loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
	}
	I2C_STOP; 
}
function JTAGI2CFEATURE_ERASE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ISC ERASE(0x0E) instruction;
    SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1024);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 1000 ;
}
/////////////////////////////////////////////////////////////////////////////////////////
function SPIPROGRAM_SECURITY_FLASH {
	//ISC_PROGRAM_SECURITY operand is as below
	//Bit[18:16] Flash Sector Address
	//Bit[15:14] 11 to Enable Password Protection
	//Bit[13:10] 1001 to Enable Erase Security
	//Bit[9] 1 to Enable Write Security
	//Bit[8] 1 to Enable Read Security
	
	//Need create a val to record security policy like CFG1_ISSECURED in sentry
	//suggest ISSECURED is security policy contain 32 bits
	
	datastream SecurityPolicy[1][32];	
	datastream TempSecurityPolicy[1][32];	
	datastream SavedSTATUS1[1][32];
	SecurityPolicy[1] = ISSECURED;
	TempSecurityPolicy[1] = SecurityPolicy[1];
	
	//read status register to get sector address
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR 32 TDI (0x000000BC);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS1);
	setpin ISPEN HIGH;		
	
	SavedSTATUS1[1] = SavedSTATUS1[1] & 0x0000E000;
	SavedSTATUS1[1] = SavedSTATUS1[1] << 3;
	
	//add command and sector address
	SecurityPolicy[1] = SecurityPolicy[1] | 0xCE000000; 
	SecurityPolicy[1] = SecurityPolicy[1] | SavedSTATUS1[1];
	SecurityPolicy[1] = $SecurityPolicy[1];
	
	setpin ISPEN LOW;
	! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	SDR 32	TDI (SecurityPolicy[1]);
	setpin ISPEN HIGH;
	RUN_TEST DELAY PWP;
	
	//check read write erase password
	
}
function I2CPROGRAM_SECURITY_FLASH {
	//ISC_PROGRAM_SECURITY operand is as below
	//Bit[18:16] Flash Sector Address
	//Bit[15:14] 11 to Enable Password Protection
	//Bit[13:10] 1001 to Enable Erase Security
	//Bit[9] 1 to Enable Write Security
	//Bit[8] 1 to Enable Read Security
	
	datastream SecurityPolicy[1][32];	
	datastream TempSecurityPolicy[1][32];	
	datastream SavedSTATUS1[1][32];
	SecurityPolicy[1] = ISSECURED;
	TempSecurityPolicy[1] = SecurityPolicy[1];
	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR 32 TDI (0x000000BC);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR 32  TDI(#0^32)
			TDO(SavedSTATUS1);
	I2C_STOP;
	
	SavedSTATUS1[1] = SavedSTATUS1[1] & 0x0000E000;
	SavedSTATUS1[1] = SavedSTATUS1[1] << 3;
	
	//add command and sector address
	SecurityPolicy[1] = SecurityPolicy[1] | 0xCE000000; 
	SecurityPolicy[1] = SecurityPolicy[1] | SavedSTATUS1[1];
	SecurityPolicy[1] = $SecurityPolicy[1];
	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	SDR 32	TDI (SecurityPolicy[1]);
	I2C_STOP;
	RUN_TEST DELAY PWP;	
	
	//check read write erase password

}
function JTAGI2CPROGRAM_SECURITY_FLASH {
	//ISC_PROGRAM_SECURITY operand is as below
	//Bit[18:16] Flash Sector Address
	//Bit[15:14] 11 to Enable Password Protection
	//Bit[13:10] 1001 to Enable Erase Security
	//Bit[9] 1 to Enable Write Security
	//Bit[8] 1 to Enable Read Security
	
	datastream SecurityPolicy[1][32];	
	datastream TempSecurityPolicy[1][32];	
	datastream SavedSTATUS1[1][32];
	SecurityPolicy[1] = ISSECURED;
	TempSecurityPolicy[1] = SecurityPolicy[1];
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR	16	TDI (0x103D);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 
	
	SavedSTATUS1[1] = SavedSTATUS1[1] & 0x0000E000;
	SavedSTATUS1[1] = SavedSTATUS1[1] << 3;
	
	//add command and sector address
	SecurityPolicy[1] = SecurityPolicy[1] | 0xCE000000; 
	SecurityPolicy[1] = SecurityPolicy[1] | SavedSTATUS1[1];

	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE)); 
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in in ISC_PROGRAM_SECURITY(0xCE) instruction;
	SDR	16	TDI (0x10CE);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = SecurityPolicy[1];
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (SecurityPolicy[1] << 8);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (SecurityPolicy[1] << 16);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (SecurityPolicy[1] << 24);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 1;
	//check read write erase password
}
////////////////////////////////////////////////////////////////////////////
function SPIFEATURE_ROW_READ {
	// suggest there is a command name LSC_READ_CNTRL_NV1
	datastream FeatureRow[1][96];
	datastream FeatureArray[1][64];
	datastream ControlNV1[1][32];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR 32	TDI (0x000000E7);
	SDR	64	TDI (#0^64)
			TDO	(FeatureArray[1]);
	setpin ISPEN HIGH;
	FeatureArray[1] = $FeatureArray[1];
	setpin ISPEN LOW;
	! Shift in LSC READ CONTROL_1(0x21) instruction;
	SDR 32 TDI (0x00000084);
	SDR  32 TDI(0x00000000)
			TDO(ControlNV1[1]);
	setpin ISPEN HIGH;	
	ControlNV1[1] = $ControlNV1[1];
    FeatureRow[1] = (ControlNV1[1] @ FeatureArray[1]); 
    FeatureRow[1] = $FeatureRow[1];
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, FeatureRow);
	fclose 	NewFile;   	
}
function I2CFEATURE_ROW_READ 
{
	datastream FeatureRow[1][96];
	datastream FeatureArray[1][64];
	datastream ControlNV1[1][32];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR 32	TDI (0x000000E7);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	64	TDI (#0^64)
			TDO	(FeatureArray[1]);
	I2C_STOP;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC READ CONTROL_1(0x21) instruction;
	SDR 32 TDI (0x00000084);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI(#0^32)
			TDO(ControlNV1[1]);
	I2C_STOP;	
	FeatureArray[1] = $FeatureArray[1];
	ControlNV1[1] = $ControlNV1[1];
    FeatureRow[1] = (ControlNV1[1] @ FeatureArray[1]); 
    FeatureRow[1] = $FeatureRow[1];
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, FeatureRow);
	fclose 	NewFile;   	
}
function JTAGI2CFEATURE_ROW_READ
{
	datastream FeatureRow[1][96];
	datastream FeatureArray[1][64];
	datastream ControlNV1[1][32];
	datastream DataByte[1][8];
	file	NewFile = "FILE_SAVE"; 	
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
    SDR	16	TDI (0x10E7);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;	
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in in LSC READ CONTROL_1(0x21) instruction;
    SDR	16	TDI (0x1021);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	ControlNV1[1] = ((ControlNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	ControlNV1[1] = ((ControlNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	ControlNV1[1] = ((ControlNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	ControlNV1[1] = ((ControlNV1[1]) @ (DataByte[1])) << 8;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	
    FeatureRow[1] = (ControlNV1[1] @ FeatureArray[1]); 
    FeatureRow[1] = $FeatureRow[1];
    
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (STATUS_BIT,FeatureRow);
	fclose 	NewFile;
}
///////////////////////////////////////////////////////////////////////////////
function SPIPROGRAM_CONTROL_NV1 
{
	datastream ControlNV[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{    					
	    ControlNV[1] = Control_Register_1_TDI[1];
	    ControlNV[1] = $ControlNV[1];
	    //print (0,ControlNV);
	    
	    setpin ISPEN LOW; 
	    ! Shift in in LSC_PROG_NV_CR1(0xEA) instruction;
	    SDR 32	TDI (0x00000057);	    
	    SDR 32 TDI(ControlNV[1]);
	    setpin ISPEN HIGH;	
	    loop PWP {
	    	setpin ISPEN HIGH;	
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;		    
		
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC READ CONTROL 1(0x21) instruction;
			SDR 32 TDI (0x00000084);
			SDR_VERIFY  32 TDI(0x00000000)
						   TDO(ControlNV[1])
						   MASK(0xFFFFFFFF);
			setpin ISPEN HIGH;
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW;
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1,"Failed at program Control NV1. Please Erase the Feature Row first.");
		}		
	}
}
function I2CPROGRAM_CONTROL_NV1 {
	datastream ControlNV[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{	
	    ControlNV[1] = Control_Register_1_TDI[1];
	    ControlNV[1] = $ControlNV[1];
	    //print (0,ControlNV);
	    
	    I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    ! Shift in in LSC_PROG_NV_CR1(0xEA) instruction;
	    SDR 32	TDI (0x00000057);	    
	    SDR 32 TDI(ControlNV[1]);
	    I2C_STOP;	
		RUN_TEST DELAY PWP;
		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			! Shift in LSC_READ_CTRL1(0x21) instruction;
			SDR 32 TDI (0x00000084);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 TDI(0x00000000)
						   TDO(ControlNV[1])
						   MASK(0xFFFFFFFF);
			I2C_STOP;			
		}
		ELSE
		{		
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	32 	TDI (0x00000064);
			I2C_STOP;	

			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	32 	TDI (0x00000064);
			I2C_STOP;			
			print (1,"Failed at program Control NV1. Please Erase the Feature Row first.");
		}
	}
}
function JTAGI2CPROGRAM_CONTROL_NV1 {
	datastream DataByte[1][8];
	datastream ControlNV[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		TRY 1
		{
			ControlNV[1] = Control_Register_1_TDI[1];
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE)); 
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in in LSC_PROG_NV_CR1(0xEA) instruction;
			SDR	16	TDI (0x10EA);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = ControlNV[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ControlNV[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ControlNV[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ControlNV[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 1;
			
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ; 
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in LSC_READ_CTRL1(0x21) instruction;
			SDR	16	TDI (0x1021);
			RUN_TEST IDLE TCK 1000 ; 
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ; 
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ; 
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ; 
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ; 
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ; 
			DataByte[1] = ControlNV[1];
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ControlNV[1] << 8);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);	
			DataByte[1] = (ControlNV[1] << 16);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ControlNV[1] << 24);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);										
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ; 	
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in ISC DISABLE(0x26) instruction;
			SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
				 
			! Shift in BYPASS(0xFF) instruction;
			SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100;		
			print (1,"Failed at program Control NV1. Please Erase the Feature Row first.");		
		}
	}
}
////////////////////////////////////////////////////////////////////////////////////////
function SPISAVE_CONTROL_NV1 {
	// use LSC_READ_CNTRL1 to read shadow register
	datastream ControlNV1[1][32];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in LSCC READ CONTROL 0(0x21) instruction;
	SDR 32 TDI (0x00000084);
	SDR  32 TDI(0x00000000)
				   TDO(ControlNV1[1]);
	setpin ISPEN HIGH;		
	ControlNV1[1] = $ControlNV1[1];
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_1_TDI, ControlNV1);
	fclose 	NewFile;   	
}
function I2CSAVE_CONTROL_NV1 {
	// use LSC_READ_CNTRL1 to read shadow register
	datastream ControlNV1[1][32];
	file NewFile = "FILE_SAVE";

	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC READ CONTROL_1(0x21) instruction;
	SDR 32 TDI (0x00000084);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI(#0^32)
			TDO(ControlNV1[1]);
	I2C_STOP;	
	ControlNV1[1] = $ControlNV1[1];
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_1_TDI, ControlNV1);
	fclose 	NewFile;   	
}
function JTAGI2CSAVE_CONTROL_NV1 {
	// use LSC_READ_CNTRL1 to read shadow register
	datastream ControlNV1[1][32];
	file	NewFile = "FILE_SAVE"; 	
		
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_CTRL1(0x21) instruction;
    SDR	16	TDI (0x1021);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	ControlNV1[1] = ((ControlNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);	
	ControlNV1[1] = ((ControlNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	ControlNV1[1] = ((ControlNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);	
	ControlNV1[1] = ((ControlNV1[1]) @ (DataByte[1])) << 8;									
    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_1_TDI,ControlNV1);
	fclose 	NewFile;
}
/////////////////////////////////////////////////////////////////////////////////////
function SPIPROG_PASSWORD {
	datastream SaveProtectKey[1][128];
	IF (ProtectKey.row = 1)
	{
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00000000)
					  	MASK(0x00008000);
			setpin ISPEN HIGH;					  					  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;		
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    setpin ISPEN HIGH;
	    	print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}	
		
		print (0,"Programming the Password Key...");
		setpin ISPEN LOW;
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR 32	TDI (0x0000008F);
    	SaveProtectKey[1] = ProtectKey[1];
    	SaveProtectKey[1] = $SaveProtectKey[1];
    	! Shift in Data; 
		SDR 128 TDI(SaveProtectKey[1]);
		setpin ISPEN HIGH;	
		loop PWP {
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
			setpin ISPEN HIGH;		
		}
		setpin ISPEN HIGH;	 
		print (0,"Verify the Password Key...");
		// Verify the Password Key;
		TRY 1 {
			setpin ISPEN LOW; 
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SDR 32 TDI (0x0000004F);
			SDR_VERIFY  128 TDI(#0^128)
					  	   TDO(SaveProtectKey[1]);
			setpin ISPEN HIGH;						  	   					  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;		
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    setpin ISPEN HIGH;
	    	print (1,"Failed to program the Password Key.");
		}
	}
	
	// Always Program FEA Password Protect
	setpin ISPEN LOW;
	! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	SDR 32	TDI (0x00032073);
	setpin ISPEN HIGH;
	RUN_TEST DELAY 100;
	
	@SPIVERIFY_PASSWORD_ENABLE();
	

	IF (PWD_UFM == 1)
	{
		! Program UFM Password Protect; 
		! Select UFM Sector;
		@SPISELECT_UFM();
		! Check Program Security;
		@SPICHECK_PROGRAM_SECURITY();
		
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x0003C073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY 100;
		
		! Verify Password Enable;
		@SPIVERIFY_PASSWORD_ENABLE();
		
	}
	IF (PWD_ALL == 1)
	{
		! Program Sector0,1,2 and SRAM Password Protect; 
		! Select Sector0 Sector;
		@SPISELECT_SECTOR0();
		! Check Program Security;
		@SPICHECK_PROGRAM_SECURITY();
		
		// Program Sector0 Password Protect
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00030073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY 100;
		
		! Verify Password Enable;
		@SPIVERIFY_PASSWORD_ENABLE();

		
		! Select Sector1 Sector;
		@SPISELECT_SECTOR1();
		! Check Program Security;
		@SPICHECK_PROGRAM_SECURITY();	
		
		// Program Sector1 Password Protect
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00038073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY 100;
		
		! Verify Password Enable;
		@SPIVERIFY_PASSWORD_ENABLE();
		
		! Select Sector2 Sector;
		@SPISELECT_SECTOR2();
		! Check Program Security;
		@SPICHECK_PROGRAM_SECURITY();
		
		// Program Sector2 Password Protect
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00034073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY 100;
		
		! Verify Password Enable;
		@SPIVERIFY_PASSWORD_ENABLE();
		
		// Program SRAM Password Protect
		@SPISRAM_ENABLE();
		@SPICHECK_SRAM_PROG_LOCK();
		
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00030073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY 100;
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
							TDO(0x04008000)
							MASK(0x04008000);
			setpin ISPEN HIGH;	
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW;
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1, "Failed in Verify Password Enable bits /see log file for more details/ ");	
		}		
	}	
}
function I2CPROG_PASSWORD {
	datastream SaveProtectKey[1][128];
	IF (ProtectKey.row = 1)
	{
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x00008000);
			I2C_STOP;						  		  		    
		}
		ELSE {	
			I2C_STOP;		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    I2C_STOP;
		    RUN_TEST DELAY 200;	  
			print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}
		print (0,"Programming the Password Key...");
		SaveProtectKey[1] = ProtectKey[1];
    	SaveProtectKey[1] = $SaveProtectKey[1];	
	    I2C_START;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR 32	TDI (0x0000008F);
    	! Shift in Data; 
		SDR 128 TDI(SaveProtectKey[1]);
		loop PWP {
	    	I2C_STOP;
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
	    	I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
		}
		I2C_STOP;	
		print (0,"Verify the Password Key...");
		// Verify the Password Key;
		TRY 1 {
			I2C_START;
	    	! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SDR 32 TDI (0x0000004F);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  128 TDI(#0^128)
					  	   TDO(SaveProtectKey[1]);	
			I2C_STOP;					  	   				  		  		    
		}
		ELSE {		  
			I2C_STOP;		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    I2C_STOP;
		    RUN_TEST DELAY 200;	 
			print (1,"Failed to program the Password Key.");
		}
	}
	
	//Always Program FEA Password Protect
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	SDR 32	TDI (0x00032073);
	I2C_STOP;
	RUN_TEST DELAY 100;
	
	@I2CVERIFY_PASSWORD_ENABLE();
	

	IF (PWD_UFM == 1)
	{
		! Program UFM Password Protect; 
		! Select UFM Sector;
		@I2CSELECT_UFM();
		! Check Program Security;
		@I2CCHECK_PROGRAM_SECURITY();
		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x0003C073);
		I2C_STOP;
		RUN_TEST DELAY 100;	
	
		! Verify Password Enable;
		@I2CVERIFY_PASSWORD_ENABLE();
		
	}
	IF (PWD_ALL == 1)
	{
		! Program Sector0,1,2 and SRAM Password Protect; 
		! Select Sector0 Sector;
		@I2CSELECT_SECTOR0();
		! Check Program Security;
		@I2CCHECK_PROGRAM_SECURITY();
		
		// Program Sector0 Password Protect
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00030073);
		I2C_STOP;
		RUN_TEST DELAY 100;	
		
		! Verify Password Enable;
		@I2CVERIFY_PASSWORD_ENABLE();

		
		! Select Sector1 Sector;
		@I2CSELECT_SECTOR1();
		! Check Program Security;
		@I2CCHECK_PROGRAM_SECURITY();	
		
		// Program Sector1 Password Protect
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00038073);
		I2C_STOP;
		RUN_TEST DELAY 100;	
		
		! Verify Password Enable;
		@I2CVERIFY_PASSWORD_ENABLE();
		
		! Select Sector2 Sector;
		@I2CSELECT_SECTOR2();
		! Check Program Security;
		@I2CCHECK_PROGRAM_SECURITY();
		
		// Program Sector2 Password Protect
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00034073);
		I2C_STOP;
		RUN_TEST DELAY 100;	
		
		! Verify Password Enable;
		@I2CVERIFY_PASSWORD_ENABLE();
		
		// Program SRAM Password Protect
		@I2CSRAM_ENABLE();
		@I2CCHECK_SRAM_PROG_LOCK();
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00030073);
		I2C_STOP;
		RUN_TEST DELAY 100;	
		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
								TDO(0x04008000)
								MASK(0x04008000);
			I2C_STOP;	
		}
		ELSE
		{
			I2C_STOP;		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    I2C_STOP;
			print (1, "Failed in Verify Password Enable bits /see log file for more details/ ");	
		}		
	}	
}
function JTAGI2CPROG_PASSWORD {
	datastream DataByte[1][8];
	IF (ProtectKey.row = 1)
	{
		TRY 1 {
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);			
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR	16	TDI (0x103C);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x01);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;				  		  		    
		}
		ELSE {		  
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100;
			print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}
		
		print (0,"Programming the Password Key...");
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);						
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR	16	TDI (0x10F1);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Data; 
		DataByte[1] = ProtectKey[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 64);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 72);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 80);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 88);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 96);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 104);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 112);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 120);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;
		
		print (0,"Verify the Password Key...");
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_PASSWORD(0xF2) instruction;
		SDR	16	TDI (0x10F2);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		TRY 1 {
			DataByte[1] = ProtectKey[1];
			SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 8);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 16);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);				
		    DataByte[1] = (ProtectKey[1] << 24);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 32);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);				
			DataByte[1] = (ProtectKey[1] << 40);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);				
			DataByte[1] = (ProtectKey[1] << 48);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 56);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 64);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 72);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 80);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);	
			DataByte[1] = (ProtectKey[1] << 88);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 96);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 104);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 112);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);		
			DataByte[1] = (ProtectKey[1] << 120);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);																																							
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100;
			print (1,"Failed to program the Password Key.");
		}	
	}
	
	//Always Program FEA Password Protect
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
	SDR	16	TDI (0x10CE);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1004);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x10C0);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;				
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 1;
		
	@JTAGI2CVERIFY_PASSWORD_ENABLE();
	

	IF (PWD_UFM == 1)
	{
		! Program UFM Password Protect; 
		! Select UFM Sector;
		@JTAGI2CSELECT_UFM();
		! Check Program Security;
		@JTAGI2CCHECK_PROGRAM_SECURITY();
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1003);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
	
		! Verify Password Enable;
		@JTAGI2CVERIFY_PASSWORD_ENABLE();
		
	}
	IF (PWD_ALL == 1)
	{
		// Program Sector0,1,2 and SRAM Password Protect 
		! Select Sector0 Sector;
		@JTAGI2CSELECT_SECTOR0();
		! Check Program Security;
		@JTAGI2CCHECK_PROGRAM_SECURITY();
	
		// Program Sector0 Password Protect	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
		! Verify Password Enable;
		@JTAGI2CVERIFY_PASSWORD_ENABLE();
	
		! Select Sector1 Sector;
		@JTAGI2CSELECT_SECTOR1();
		! Check Program Security;
		@JTAGI2CCHECK_PROGRAM_SECURITY();	
		
		// Program Sector1 Password Protect
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1001);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
		! Verify Password Enable;
		@JTAGI2CVERIFY_PASSWORD_ENABLE();
		
		! Select Sector2 Sector;
		@JTAGI2CSELECT_SECTOR2();
		! Check Program Security;
		@JTAGI2CCHECK_PROGRAM_SECURITY();
	
		// Program Sector2 Password Protect
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1002);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
		! Verify Password Enable;
		@JTAGI2CVERIFY_PASSWORD_ENABLE();
	
		// Program SRAM Password Protect
		@JTAGI2CSRAM_ENABLE();
		@JTAGI2CCHECK_SRAM_PROG_LOCK();
			
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
		TRY 1 {
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);			
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR	16	TDI (0x103C);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x20)
							MASK (0x20);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in ISC DISABLE(0x26) instruction;
			SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
				 
			! Shift in BYPASS(0xFF) instruction;
			SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100;		
			print (1, "Failed in Verify Password Enable bits /see log file for more details/ ");	
		}		
	}	
}
function SPIVERIFY_PASSWORD_ENABLE {
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
							TDO(0x00008000)
							MASK(0x00308000);
		setpin ISPEN HIGH;	
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1, "Failed in Verify Password Enable bits /see log file for more details/ ");	
	}
}
function I2CVERIFY_PASSWORD_ENABLE {
	TRY 1 {
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);		
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00008000)
				  		MASK(0x00008000);
		I2C_STOP;	
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;
		print (1, "Failed in Verify Password Enable bits /see log file for more details/ ");	
	}
}
function JTAGI2CVERIFY_PASSWORD_ENABLE {
	TRY 1 {
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x01)
						MASK (0x01);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;			
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;			
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;	
		print (1, "Failed in Verify Password Enable bits /see log file for more details/ ");	
	}
}
////////////////////////////////////////////////////////////////////////////////////////////
function SPIREAD_PASSWORD {
	datastream PasswordArray[1][128];
	setpin ISPEN LOW; 
	! Shift in LSC_READ_PASSWORD(0xF2) instruction;
	SDR 32 TDI (0x0000004F);
	SDR  128 TDI(#0^128)
			 TDO(PasswordArray[1]);
	setpin ISPEN HIGH;	
	PasswordArray[1] = $PasswordArray[1];				
	print (0,"The password is");
	print (0,PasswordArray);	
}
function I2CREAD_PASSWORD {
	datastream PasswordArray[1][128];
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_PASSWORD(0xF2) instruction;
	SDR 32 TDI (0x0000004F);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR  128 TDI(#0^128)
			 TDO(PasswordArray[1]);	
	I2C_STOP;
	PasswordArray[1] = $PasswordArray[1];
	print (0,"The password is");
	print (0,PasswordArray);	
}
function JTAGI2CREAD_PASSWORD {
	datastream DataByte[1][8];
	datastream PasswordArray[1][128];
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_PASSWORD(0xF2) instruction;
	SDR	16	TDI (0x10F2);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);	
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	print (0,"The password is");
	print (0,PasswordArray);	
}
//////////////////////////////////////////////////////////////////////////////////////////////////////
function SPICFG_ERASE {
	! Select CFG Sector;
	@SPISELECT_CFG();
	! Check CFG Erase security;
	@SPICHECK_ERASE_SECURITY(); 
	! Erase CFG;
	@SPIERASE_CFG(); 
}
function I2CCFG_ERASE {
	! Select CFG Sector;
	@I2CSELECT_CFG();
	! Check CFG Erase security;
	@I2CCHECK_ERASE_SECURITY(); 
	! Erase CFG;
	@I2CERASE_CFG(); 
}
function JTAGI2CCFG_ERASE {
	! Select CFG Sector;
	@JTAGI2CSELECT_CFG();
	! Check CFG Erase security;
	@JTAGI2CCHECK_ERASE_SECURITY(); 
	! Erase CFG;
	@JTAGI2CERASE_CFG(); 
}
//////////////////////////////////////////////////////////////////////////////
function SPIUFM_ERASE 
{
	! Select UFM Sector;
	@SPISELECT_UFM();	
	! Check UFM Erase security;
	@SPICHECK_ERASE_SECURITY(); 
	! Erase UFM;
	@SPIERASE_UFM(); 
}
function I2CUFM_ERASE {
	! Select UFM Sector;
	@I2CSELECT_UFM();	
	! Check UFM Erase security;
	@I2CCHECK_ERASE_SECURITY(); 
	! Erase UFM;
	@I2CERASE_UFM();
}
function JTAGI2CUFM_ERASE 
{
	! Select UFM Sector;	
	@JTAGI2CSELECT_UFM();	
	! Check UFM Erase security;
	@JTAGI2CCHECK_ERASE_SECURITY(); 
	! Erase UFM;
	@JTAGI2CERASE_UFM(); 
}
//////////////////////////////////////////////////////////////////////////////////////
function SPIERASE_CFG{
	//Erase Sector 0
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00000470);
    setpin ISPEN HIGH;
    loop PWE {
    	setpin ISPEN HIGH;
		RUN_TEST DELAY 100;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
	//Erase Sector 1
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00008470);
    setpin ISPEN HIGH;
    loop PWE {
    	setpin ISPEN HIGH;
		RUN_TEST DELAY 100;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
	//Erase Sector 2
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00004470);
    setpin ISPEN HIGH;
    loop PWE {
    	setpin ISPEN HIGH;
		RUN_TEST DELAY 100;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
}
function I2CERASE_CFG {
	//Erase Sector 0
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00000470);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY 100;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
	}
	I2C_STOP;
	
	//Erase Sector 1
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00008470);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY 100;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
	}
	I2C_STOP;
	
	//Erase Sector 2
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00004470);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY 100;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
	}
	I2C_STOP;
}
function JTAGI2CERASE_CFG {
	//Erase Sector 0
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ISC ERASE(0x0E) instruction;
    SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1020);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	loop PWE {
		RUN_TEST IDLE TCK 2 DELAY 100;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR	16	TDI (0x10F0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x80);
		
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;
	
	//Erase Sector 1
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ISC ERASE(0x0E) instruction;
    SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1021);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	loop PWE {
		RUN_TEST IDLE TCK 2 DELAY 100;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR	16	TDI (0x10F0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x80);
		
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;
	
	//Erase Sector 2
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ISC ERASE(0x0E) instruction;
    SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1022);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	loop PWE {
		RUN_TEST IDLE TCK 2 DELAY 100;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR	16	TDI (0x10F0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x80);
		
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;
}
///////////////////////////////////////////////////////////////////////////
function SPIERASE_UFM {
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x0000C470);
    setpin ISPEN HIGH;
    loop PWE {
    	setpin ISPEN HIGH;
		RUN_TEST DELAY 100;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
		setpin ISPEN HIGH;		
	}
	setpin ISPEN HIGH;
}
function I2CERASE_UFM {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x0000C470);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY 100;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
	}
	I2C_STOP;
}
function JTAGI2CERASE_UFM 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ISC ERASE(0x0E) instruction;
    SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1023);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	loop PWE {
		RUN_TEST IDLE TCK 2 DELAY 100;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR	16	TDI (0x10F0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x80);
		
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;
}
///////////////////////////////////////////////////////////////////////////////
function SPICFG_PROGRAM_FULL 
{
	! Select CFG Sector;
	@SPISELECT_CFG();
	! Check CFG Program security;
	@SPICHECK_PROGRAM_SECURITY(); 
	! Program CFG;
	@SPIPROGRAM_CFG_FULL(); 
	! Select CFG Sector;
	@SPISELECT_CFG();
	! Program USERCODE;
	@SPIPROGRAM_CFG_USERCODE(); 
}
function SPICFG_PROGRAM {
	! Select CFG Sector;
	@SPISELECT_CFG();
	! Check CFG Program security;
	@SPICHECK_PROGRAM_SECURITY(); 
	! Program CFG;
	@SPIPROGRAM_CFG(); 
	! Select CFG Sector;
	@SPISELECT_CFG();
	! Program USERCODE;
	@SPIPROGRAM_CFG_USERCODE(); 
}
function I2CCFG_PROGRAM_FULL 
{
	! Select CFG Sector;
	@I2CSELECT_CFG();
	! Check CFG Program security;
	@I2CCHECK_PROGRAM_SECURITY(); 
	! Program CFG;
	@I2CPROGRAM_CFG_FULL(); 
	! Select CFG Sector;
	@I2CSELECT_CFG();
	! Program USERCODE;
	@I2CPROGRAM_CFG_USERCODE(); 
}
function I2CCFG_PROGRAM {
	! Select CFG Sector;
	@I2CSELECT_CFG();
	! Check CFG Program security;
	@I2CCHECK_PROGRAM_SECURITY(); 
	! Program CFG;
	@I2CPROGRAM_CFG(); 
	! Select CFG Sector;
	@I2CSELECT_CFG();
	! Program USERCODE;
	@I2CPROGRAM_CFG_USERCODE(); 
}
function JTAGI2CCFG_PROGRAM_FULL 
{
	! Select CFG Sector;
	@JTAGI2CSELECT_CFG();
	! Check CFG Program security;
	@JTAGI2CCHECK_PROGRAM_SECURITY();
	! Program CFG;
	@JTAGI2CPROGRAM_CFG_FULL(); 
	! Select CFG Sector;
	@JTAGI2CSELECT_CFG();
	! Program USERCODE;
	@JTAGI2CPROGRAM_CFG_USERCODE(); 
}
function JTAGI2CCFG_PROGRAM {
	! Select CFG Sector;
	@JTAGI2CSELECT_CFG();
	! Check CFG Program security;
	@JTAGI2CCHECK_PROGRAM_SECURITY(); 
	! Program CFG;
	@JTAGI2CPROGRAM_CFG(); 
	! Select CFG Sector;
	@JTAGI2CSELECT_CFG();
	! Program USERCODE;
	@JTAGI2CPROGRAM_CFG_USERCODE(); 
}
///////////////////////////////////////////////////////////////////////
function SPIUFM_PROGRAM_FULL {
	! Select UFM Sector;
	@SPISELECT_UFM();
	! Check UFM Program security;
	@SPICHECK_PROGRAM_SECURITY(); 
	! Program UFM;
	@SPIPROGRAM_UFM_FULL(); 
}
function SPIUFM_PROGRAM {
	! Select UFM Sector;
	@SPISELECT_UFM();
	! Check UFM Program security;
	@SPICHECK_PROGRAM_SECURITY(); 
	! Program UFM;
	@SPIPROGRAM_UFM(); 
}
function I2CUFM_PROGRAM_FULL 
{
	! Select UFM Sector;
	@I2CSELECT_UFM();
	! Check UFM Program security;
	@I2CCHECK_PROGRAM_SECURITY(); 
	! Program UFM;
	@I2CPROGRAM_UFM_FULL(); 
}
function I2CUFM_PROGRAM {
	! Select UFM Sector;
	@I2CSELECT_UFM();
	! Check UFM Program security;
	@I2CCHECK_PROGRAM_SECURITY(); 
	! Program UFM;
	@I2CPROGRAM_UFM(); 
}
function JTAGI2CUFM_PROGRAM_FULL {
	! Select UFM Sector;
	@JTAGI2CSELECT_UFM();
	! Check UFM Program security;
	@JTAGI2CCHECK_PROGRAM_SECURITY(); 
	! Program UFM;
	@JTAGI2CPROGRAM_UFM_FULL(); 
}
function JTAGI2CUFM_PROGRAM {
	! Select UFM Sector;
	@JTAGI2CSELECT_UFM();
	! Check UFM Program security;
	@JTAGI2CCHECK_PROGRAM_SECURITY(); 
	! Program UFM;
	@JTAGI2CPROGRAM_UFM(); 
}
///////////////////////////////////////////////////////////////////////
function SPICFG_VERIFY_FULL {
	! Select CFG Sector;
	@SPISELECT_CFG();
	! Check CFG Read security;
	@SPICHECK_READ_SECURITY(); 
	//! Verify USERCODE;
	//@SPIVERIFY_CFG_USERCODE();
	! Verify CFG;
	@SPIVERIFY_CFG_FULL(); 
}
function SPICFG_VERIFY {
	! Select CFG Sector;
	@SPISELECT_CFG();
	! Check CFG Read security;
	@SPICHECK_READ_SECURITY();
	! Verify USERCODE;
	@SPIVERIFY_CFG_USERCODE(); 
	! Verify CFG;
	@SPIVERIFY_CFG(); 
}
function I2CCFG_VERIFY_FULL 
{
	! Select CFG Sector;
	@I2CSELECT_CFG();
	! Check CFG Read security;
	@I2CCHECK_READ_SECURITY(); 
	//! Verify USERCODE;
	//@I2CVERIFY_CFG_USERCODE();
	! Verify CFG;
	@I2CVERIFY_CFG_FULL(); 
}
function I2CCFG_VERIFY {
	! Select CFG Sector;
	@I2CSELECT_CFG();
	! Check CFG Read security;
	@I2CCHECK_READ_SECURITY(); 
	! Verify USERCODE;
	@I2CVERIFY_CFG_USERCODE();
	! Verify CFG;
	@I2CVERIFY_CFG(); 
}
function JTAGI2CCFG_VERIFY_FULL {
	! Select CFG Sector;
	@JTAGI2CSELECT_CFG();
	! Check CFG Read security;
	@JTAGI2CCHECK_READ_SECURITY(); 
	//! Verify USERCODE;
	//@JTAGI2CVERIFY_CFG_USERCODE();
	! Verify CFG;
	@JTAGI2CVERIFY_CFG_FULL(); 
}
function JTAGI2CCFG_VERIFY {
	! Select CFG Sector;
	@JTAGI2CSELECT_CFG();
	! Check CFG Read security;
	@JTAGI2CCHECK_READ_SECURITY(); 
	! Verify USERCODE;
	@JTAGI2CVERIFY_CFG_USERCODE();
	! Verify CFG;
	@JTAGI2CVERIFY_CFG(); 
}
///////////////////////////////////////////////////////////////////////////
function SPIUFM_VERIFY_FULL
{
	! Select UFM Sector;
	@SPISELECT_UFM();
	! Check UFM Read security;
	@SPICHECK_READ_SECURITY();  
	! Verify UFM;
	@SPIVERIFY_UFM_FULL();  
}
function SPIUFM_VERIFY 
{
	! Select UFM Sector;
	@SPISELECT_UFM();
	! Check UFM Read security;
	@SPICHECK_READ_SECURITY();  
	! Verify UFM;
	@SPIVERIFY_UFM();  
}
function I2CUFM_VERIFY_FULL {
	! Select UFM Sector;
	@I2CSELECT_UFM();
	! Check UFM Read security;
	@I2CCHECK_READ_SECURITY();  
	! Verify UFM;
	@I2CVERIFY_UFM_FULL();  
}
function I2CUFM_VERIFY {
	! Select UFM Sector;
	@I2CSELECT_UFM();
	! Check UFM Read security;
	@I2CCHECK_READ_SECURITY();  
	! Verify UFM;
	@I2CVERIFY_UFM();  
}
function JTAGI2CUFM_VERIFY_FULL {
	! Select UFM Sector;
	@JTAGI2CSELECT_UFM();
	! Check UFM Read security;
	@JTAGI2CCHECK_READ_SECURITY();  
	! Verify UFM;
	@JTAGI2CVERIFY_UFM_FULL();  
}
function JTAGI2CUFM_VERIFY {
	! Select UFM Sector;
	@JTAGI2CSELECT_UFM();
	! Check UFM Read security;
	@JTAGI2CCHECK_READ_SECURITY();  
	! Verify UFM;
	@JTAGI2CVERIFY_UFM();  
}
////////////////////////////////////////////////////////////////////////////
function SPIPROGRAM_CFG_FULL 
{
	int32	RowCount = 1;
	datastream FuseArray_TDI_CFG0[1][64];
	IF (FuseArray_TDI.row = 1)
	{
		@SPISELECT_SECTOR0();					
		repeat Temp_UFM_Count
		{
			FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];
			setpin ISPEN LOW;
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000200E);    
			! Shift in Data Row = RowCount; 			
			SDR	64	TDI	(FuseArray_TDI_CFG0[1]);
			setpin ISPEN HIGH;	
			loop PWP {
				setpin ISPEN HIGH;	
				RUN_TEST DELAY PWV;	
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
				setpin ISPEN HIGH;														
			}
			setpin ISPEN HIGH;	 
			RowCount = RowCount +1;		
		}
		@SPISELECT_SECTOR1();					
		repeat Temp_UFM_Count
		{
			FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];
			setpin ISPEN LOW;
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000200E);    
			! Shift in Data Row = RowCount; 			
			SDR	64	TDI	(FuseArray_TDI_CFG0[1]);
			setpin ISPEN HIGH;	
			loop PWP {
				setpin ISPEN HIGH;	
				RUN_TEST DELAY PWV;	
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
				setpin ISPEN HIGH;															
			}
			setpin ISPEN HIGH;	 
			RowCount = RowCount +1;		
		} 
		@SPISELECT_SECTOR2();					
		repeat Temp_UFM_Count
		{
			FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];
			setpin ISPEN LOW;
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000200E);    
			! Shift in Data Row = RowCount; 			
			SDR	64	TDI	(FuseArray_TDI_CFG0[1]);
			setpin ISPEN HIGH;	
			loop PWP {
				setpin ISPEN HIGH;	
				RUN_TEST DELAY PWV;	
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
				setpin ISPEN HIGH;															
			}
			setpin ISPEN HIGH;	 
			RowCount = RowCount +1;		
		} 		
	}
}
function I2CPROGRAM_CFG_FULL 
{
	int32	RowCount = 1;
	datastream FuseArray_TDI_CFG0[1][64];
	IF (FuseArray_TDI.row = 1)
	{	
		@I2CSELECT_SECTOR0();		
		repeat Temp_UFM_Count
		{	
			FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000200E);    
			! Shift in Data Row = RowCount; 			
			SDR	64	TDI	(FuseArray_TDI_CFG0[1]);
			loop PWP {
				I2C_STOP;							
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);											
			}
			I2C_STOP;
			RowCount = RowCount +1;		
		} 
		@I2CSELECT_SECTOR1();		
		repeat Temp_UFM_Count
		{
			FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];			
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000200E);    
			! Shift in Data Row = RowCount; 			
			SDR	64	TDI	(FuseArray_TDI_CFG0[1]);
			loop PWP {
				I2C_STOP;							
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);											
			}
			I2C_STOP;
			RowCount = RowCount +1;		
		}		
		@I2CSELECT_SECTOR2();		
		repeat Temp_UFM_Count
		{
			FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];			
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000200E);    
			! Shift in Data Row = RowCount; 			
			SDR	64	TDI	(FuseArray_TDI_CFG0[1]);
			loop PWP {
				I2C_STOP;							
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);										
			}
			I2C_STOP;
			RowCount = RowCount +1;		
		} 		
	}
}
function JTAGI2CPROGRAM_CFG_FULL 
{
	datastream DataByte[1][8];
	datastream TmpJTAGI2CProgramDataArray[1][64];
	int32	RowCount = 1;
	IF (FuseArray_TDI.row = 1)
	{
		@JTAGI2CSELECT_SECTOR0();
		RUN_TEST DELAY PWP;
		repeat Temp_UFM_Count
		{
			TmpJTAGI2CProgramDataArray[1] = FuseArray_TDI[RowCount]; 
			TmpJTAGI2CProgramDataArray[1] = $TmpJTAGI2CProgramDataArray[1];
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR	16	TDI (0x1070);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1004);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Data Row = RowCount; 	
			DataByte[1] = TmpJTAGI2CProgramDataArray[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;		
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 32);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 40);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 48);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 56);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			RowCount = RowCount +1;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY PWP;				
		}
		@JTAGI2CSELECT_SECTOR1();
		RUN_TEST DELAY PWP;
		repeat Temp_UFM_Count
		{
			TmpJTAGI2CProgramDataArray[1] = FuseArray_TDI[RowCount]; 
			TmpJTAGI2CProgramDataArray[1] = $TmpJTAGI2CProgramDataArray[1];
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR	16	TDI (0x1070);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1004);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Data Row = RowCount; 	
			DataByte[1] = TmpJTAGI2CProgramDataArray[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;		
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 32);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 40);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 48);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 56);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			RowCount = RowCount +1;	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY PWP;			
		} 
		@JTAGI2CSELECT_SECTOR2();
		repeat Temp_UFM_Count
		{
			TmpJTAGI2CProgramDataArray[1] = FuseArray_TDI[RowCount]; 
			TmpJTAGI2CProgramDataArray[1] = $TmpJTAGI2CProgramDataArray[1];
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR	16	TDI (0x1070);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1004);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Data Row = RowCount; 	
			DataByte[1] = TmpJTAGI2CProgramDataArray[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;		
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 32);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 40);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 48);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 56);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			RowCount = RowCount +1;	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY PWP;				
		} 
	}
}
///////////////////////////////////////////////////////////////////////////////////////
function SPIPROGRAM_CFG {
	int32	RowCount = 1;
	int32 	Adrr = 0;
	datastream FuseMapAddr[1][32];
	datastream Temp[1][32];
	datastream FuseArray_TDI_CFG0[1][64];
		
	IF (FuseArray_TDI.row = 1)
	{
		@SPISELECT_SECTOR0();
		repeat Temp_UFM_Count
		{
			FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (FuseArray_TDI_CFG0[1] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;
				FuseMapAddr[1] = $FuseMapAddr[1];			
				setpin ISPEN LOW;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction; 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN LOW;
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000200E);    
				! Shift in Data Row = RowCount; 			
				SDR	64	TDI	(FuseArray_TDI_CFG0[1]);
				loop PWP {
					setpin ISPEN HIGH;									
					RUN_TEST DELAY PWV;
					setpin ISPEN LOW;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);														
				}	 		   						
			} 
			setpin ISPEN HIGH; 
			RowCount = RowCount +1;		
		} 	
		
		Adrr = 16384;
		@SPISELECT_SECTOR1();					
		repeat Temp_UFM_Count
		{
			FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (FuseArray_TDI_CFG0[1] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;
				FuseMapAddr[1] = $FuseMapAddr[1];			
				setpin ISPEN LOW;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction; 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN LOW;
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000200E);    
				! Shift in Data Row = RowCount; 			
				SDR	64	TDI	(FuseArray_TDI_CFG0[1]);
				loop PWP {
					setpin ISPEN HIGH;									
					RUN_TEST DELAY PWV;
					setpin ISPEN LOW;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);														
				}	    						
			}  
			setpin ISPEN HIGH;
			RowCount = RowCount +1;		
		} 	
		
		Adrr = 32768;
		@SPISELECT_SECTOR2();					
		repeat Temp_UFM_Count
		{
			FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (FuseArray_TDI_CFG0[1] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;
				FuseMapAddr[1] = $FuseMapAddr[1];			
				setpin ISPEN LOW;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction; 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN LOW;
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000200E);    
				! Shift in Data Row = RowCount; 			
				SDR	64	TDI	(FuseArray_TDI_CFG0[1]);
				loop PWP {
					setpin ISPEN HIGH;									
					RUN_TEST DELAY PWV;
					setpin ISPEN LOW;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);														
				}	    						
			}  
			setpin ISPEN HIGH;
			RowCount = RowCount +1;		
		} 		
	}
}
function I2CPROGRAM_CFG {
	int32	RowCount = 1;
	int32 	Adrr = 0;
	datastream FuseMapAddr[1][32];
	datastream Temp[1][32];
	datastream FuseArray_TDI_CFG0[1][64];
	
	IF (FuseArray_TDI.row = 1)
	{
		@I2CSELECT_SECTOR0();

		repeat Temp_UFM_Count
		{
			FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (FuseArray_TDI_CFG0[1] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;
				FuseMapAddr[1] = $FuseMapAddr[1];		
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32 TDI(FuseMapAddr[1]); 
				I2C_STOP;	
			}
			ELSE
			{
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000200E);    
				! Shift in Data Row = RowCount; 			
				SDR	64	TDI	(FuseArray_TDI_CFG0[1]);
				loop PWP {
					I2C_STOP;							
					RUN_TEST DELAY PWV;
					I2C_START;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_WRITE);
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					I2C_RESTART;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_READ);
					SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);				
				}   						
			}  
			I2C_STOP;
			RowCount = RowCount +1;		
		} 	
		
		Adrr = 16384;
		@I2CSELECT_SECTOR1();					
		repeat Temp_UFM_Count
		{
			FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (FuseArray_TDI_CFG0[1] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;
				FuseMapAddr[1] = $FuseMapAddr[1];		
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32 TDI(FuseMapAddr[1]); 
				I2C_STOP;	
			}
			ELSE
			{
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000200E);    
				! Shift in Data Row = RowCount; 			
				SDR	64	TDI	(FuseArray_TDI_CFG0[1]);
				loop PWP {
					I2C_STOP;							
					RUN_TEST DELAY PWV;
					I2C_START;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_WRITE);
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					I2C_RESTART;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_READ);
					SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);				
				}   						
			}  
			I2C_STOP;
			RowCount = RowCount +1;		
		} 	
		
		Adrr = 32768;
		@I2CSELECT_SECTOR2();					
		repeat Temp_UFM_Count
		{
			FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (FuseArray_TDI_CFG0[1] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;
				FuseMapAddr[1] = $FuseMapAddr[1];		
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32 TDI(FuseMapAddr[1]); 
				I2C_STOP;	
			}
			ELSE
			{
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000200E);    
				! Shift in Data Row = RowCount; 			
				SDR	64	TDI	(FuseArray_TDI_CFG0[1]);
				loop PWP {
					I2C_STOP;							
					RUN_TEST DELAY PWV;
					I2C_START;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_WRITE);
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					I2C_RESTART;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_READ);
					SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);				
				}   						
			}  
			I2C_STOP;
			RowCount = RowCount +1;		
		} 		
	}
}
function JTAGI2CPROGRAM_CFG {
	int32	RowCount = 1;
	int32 	Adrr = 0;
	datastream FuseMapAddr[1][32];
	datastream Temp[1][32];
	datastream DataByte[1][8];
	datastream TmpJTAGI2CProgramDataArray[1][64];
	
	IF (FuseArray_TDI.row = 1)
	{
		@JTAGI2CSELECT_SECTOR0();
		repeat Temp_UFM_Count
		{
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (FuseArray_TDI[RowCount] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;	

				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				DataByte[1] = FuseMapAddr[1] ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 8;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 16;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 24;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;				
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 2 DELAY 1;
			}
			ELSE
			{
				TmpJTAGI2CProgramDataArray[1] = FuseArray_TDI[RowCount]; 
				TmpJTAGI2CProgramDataArray[1] = $TmpJTAGI2CProgramDataArray[1];
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR	16	TDI (0x1070);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1004);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Data Row = RowCount; 	
				DataByte[1] = TmpJTAGI2CProgramDataArray[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 32);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 40);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 48);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 56);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				
				loop PWP {
					RUN_TEST IDLE TCK 2 DELAY 1;
					! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
					SIR	8	TDI  (0x9D);
					SDR	16	TDI  (0x5000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + WR;
					SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
					RUN_TEST IDLE TCK 1000 ;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR	16	TDI (0x10F0);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + RD;
					SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x2000);
					RUN_TEST IDLE TCK 1000 ;
					SIR	8	TDI  (0x9E);
					SDR_VERIFY	8	TDI  (0x00)
									TDO  (0x00)
									MASK (0x80);
				}					
			}  
			RowCount = RowCount +1;		
		} 	
		Adrr = 16384;
		@JTAGI2CSELECT_SECTOR1();
		repeat Temp_UFM_Count
		{
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (FuseArray_TDI[RowCount] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;	

				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				DataByte[1] = FuseMapAddr[1] ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 8;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 16;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 24;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;				
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 2 DELAY 1;
			}
			ELSE
			{
				TmpJTAGI2CProgramDataArray[1] = FuseArray_TDI[RowCount]; 
				TmpJTAGI2CProgramDataArray[1] = $TmpJTAGI2CProgramDataArray[1];
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR	16	TDI (0x1070);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1004);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Data Row = RowCount; 	
				DataByte[1] = TmpJTAGI2CProgramDataArray[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 32);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 40);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 48);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 56);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				
				loop PWP {
					RUN_TEST IDLE TCK 2 DELAY 1;
					! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
					SIR	8	TDI  (0x9D);
					SDR	16	TDI  (0x5000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + WR;
					SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
					RUN_TEST IDLE TCK 1000 ;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR	16	TDI (0x10F0);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + RD;
					SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x2000);
					RUN_TEST IDLE TCK 1000 ;
					SIR	8	TDI  (0x9E);
					SDR_VERIFY	8	TDI  (0x00)
									TDO  (0x00)
									MASK (0x80);
				}					
			}  
			RowCount = RowCount +1;		
		} 	
		Adrr = 32768;
		@JTAGI2CSELECT_SECTOR2();
		repeat Temp_UFM_Count
		{
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (FuseArray_TDI[RowCount] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;	

				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				DataByte[1] = FuseMapAddr[1] ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 8;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 16;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 24;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;				
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 2 DELAY 1;
			}
			ELSE
			{
				TmpJTAGI2CProgramDataArray[1] = FuseArray_TDI[RowCount]; 
				TmpJTAGI2CProgramDataArray[1] = $TmpJTAGI2CProgramDataArray[1];
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR	16	TDI (0x1070);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1004);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Data Row = RowCount; 	
				DataByte[1] = TmpJTAGI2CProgramDataArray[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 32);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 40);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 48);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 56);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				
				loop PWP {
					RUN_TEST IDLE TCK 2 DELAY 1;
					! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
					SIR	8	TDI  (0x9D);
					SDR	16	TDI  (0x5000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + WR;
					SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
					RUN_TEST IDLE TCK 1000 ;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR	16	TDI (0x10F0);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + RD;
					SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x2000);
					RUN_TEST IDLE TCK 1000 ;
					SIR	8	TDI  (0x9E);
					SDR_VERIFY	8	TDI  (0x00)
									TDO  (0x00)
									MASK (0x80);
				}					
			}  
			RowCount = RowCount +1;		
		} 	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 2 DELAY 1;
	}
}
///////////////////////////////////////////////////////////////////////////////////////
function SPIVERIFY_CFG_FULL {
	int32	RowCount = 1;
	datastream FuseArray_TDI_CFG0[1][64];
	FuseArray_TDI.row = 1;
	TRY 1 {
		@SPISELECT_SECTOR0();
		setpin ISPEN LOW;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000000CE);
		SDR 32	TDI	(0xFFFFFFFF);	    
		repeat Temp_UFM_Count
    	{	
    		FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];
			! Shift out Data Row = RowCount; 			
			SDR_VERIFY	64	TDI	(#0^64)
							TDO	(FuseArray_TDI_CFG0[1]);
			RowCount = RowCount +1;
		}
		setpin ISPEN HIGH;					
			
		@SPISELECT_SECTOR1();
		setpin ISPEN LOW;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000000CE);
		SDR 32	TDI	(0xFFFFFFFF);	    	
		repeat Temp_UFM_Count
    	{
    		FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];	
			! Shift out Data Row = RowCount; 			
			SDR_VERIFY	64	TDI	(#0^64)
							TDO	(FuseArray_TDI_CFG0[1]);
			RowCount = RowCount +1;
		}
		setpin ISPEN HIGH;					
		
		@SPISELECT_SECTOR2();
		setpin ISPEN LOW;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000000CE);	    
		SDR 32	TDI	(0xFFFFFFFF);	
		repeat Temp_UFM_Count
    	{	
    		FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];
			! Shift out Data Row = RowCount; 			
			SDR_VERIFY	64	TDI	(#0^64)
							TDO	(FuseArray_TDI_CFG0[1]);
			RowCount = RowCount +1;
		}
		setpin ISPEN HIGH;							
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1, "Failed in Function SPIVERIFY_CFG /see log file for more details/ ");
	}	
}
function I2CVERIFY_CFG_FULL 
{
	int32	RowCount = 1;
	datastream FuseArray_TDI_CFG0[1][64];
	FuseArray_TDI.row = 1;
	TRY 1 {	
		@I2CSELECT_SECTOR0();
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    	SDR 32	TDI	(0x000000CE);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 32	TDI	(#0^32)
						TDO (#0^32)
						MASK (#0^32);
		repeat Temp_UFM_Count
		{	
			RUN_TEST DELAY PWV;
			FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];
			! Shift out Data Row = RowCount; 			
			SDR_VERIFY	64	TDI	(#0^64)
							TDO	(FuseArray_TDI_CFG0[1]);
			RowCount = RowCount +1;
		}
		I2C_STOP;
		
		@I2CSELECT_SECTOR1();
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    	SDR 32	TDI	(0x000000CE);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 32	TDI	(#0^32)
						TDO (#0^32)
						MASK (#0^32);
		repeat Temp_UFM_Count
		{	
			FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];
			! Shift out Data Row = RowCount; 			
			SDR_VERIFY	64	TDI	(#0^64)
							TDO	(FuseArray_TDI_CFG0[1]);
			RowCount = RowCount +1;
		}
		I2C_STOP;
		@I2CSELECT_SECTOR0();
		@I2CSELECT_SECTOR2();
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    	SDR 32	TDI	(0x000000CE);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 32	TDI	(#0^32)
						TDO (#0^32)
						MASK (#0^32);
		repeat Temp_UFM_Count
		{	
			FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];
			! Shift out Data Row = RowCount; 			
			SDR_VERIFY	64	TDI	(#0^64)
							TDO	(FuseArray_TDI_CFG0[1]);
			RowCount = RowCount +1;
		}
		I2C_STOP;																							
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1, "Failed in Function I2CVERIFY_CFG /see log file for more details/ ");
	}	
}
function JTAGI2CVERIFY_CFG_FULL 
{
	datastream DataByte[1][8];
	datastream TmpJTAGI2CVerifyDataArray[1][64];
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	TRY 1 {
		@JTAGI2CSELECT_SECTOR0();
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR	16	TDI (0x1073);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);	
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;	
		repeat Temp_UFM_Count
		{
			TmpJTAGI2CVerifyDataArray[1] = FuseArray_TDI[RowCount];
			TmpJTAGI2CVerifyDataArray[1] = $TmpJTAGI2CVerifyDataArray[1];
			! Shift out Data Row = RowCount; 	
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1]);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 8);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 16);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 24);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;	
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 32);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 40);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 48);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 56);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			RowCount = RowCount +1;			
		}
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		
		@JTAGI2CSELECT_SECTOR1();
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR	16	TDI (0x1073);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);	
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;	
		repeat Temp_UFM_Count
		{
			TmpJTAGI2CVerifyDataArray[1] = FuseArray_TDI[RowCount];
			TmpJTAGI2CVerifyDataArray[1] = $TmpJTAGI2CVerifyDataArray[1];
			! Shift out Data Row = RowCount; 	
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1]);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 8);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 16);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 24);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;	
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 32);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 40);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 48);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 56);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			RowCount = RowCount +1;			
		}
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;

		
		@JTAGI2CSELECT_SECTOR2();
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR	16	TDI (0x1073);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);	
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;	
		repeat Temp_UFM_Count
		{
			TmpJTAGI2CVerifyDataArray[1] = FuseArray_TDI[RowCount];
			TmpJTAGI2CVerifyDataArray[1] = $TmpJTAGI2CVerifyDataArray[1];
			! Shift out Data Row = RowCount; 	
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1]);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 8);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 16);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 24);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;	
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 32);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 40);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 48);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 56);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			RowCount = RowCount +1;			
		}
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		STATE RESET;		
		STATE IDLE;	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;	
		print (1, "Failed in Function JTAGI2CVERIFY_CFG /see log file for more details/ ");
	}
}
//////////////////////////////////////////////////////////////////////////////////////////////////////
function SPIVERIFY_CFG 
{
	int32	RowCount = 1;
	int32 	Adrr = 0;
	datastream FuseMapAddr[1][32];
	datastream Temp[1][32];
	datastream FuseArray_TDI_CFG0[1][64];
	FuseArray_TDI.row = 1;
	
	TRY 1 {
		@SPISELECT_SECTOR0();
		repeat Temp_UFM_Count
    	{		
    		FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];		
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (FuseArray_TDI_CFG0[1] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;
				FuseMapAddr[1] = $FuseMapAddr[1];			
				setpin ISPEN LOW;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction; 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN LOW;
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
				SDR 32	TDI	(0x000000CE);	    
				! Shift out Data Row = RowCount; 			
				SDR_VERIFY	64	TDI	(#0^64)
								TDO	(FuseArray_TDI_CFG0[1]);		
				setpin ISPEN HIGH;					
			}  
			RowCount = RowCount +1;
		}	    
		Adrr = 16384;		
		@SPISELECT_SECTOR1();
		repeat Temp_UFM_Count
    	{	
    		FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];			
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (FuseArray_TDI_CFG0[1] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;
				FuseMapAddr[1] = $FuseMapAddr[1];			
				setpin ISPEN LOW;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction; 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN LOW;
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
				SDR 32	TDI	(0x000000CE);	    
				! Shift out Data Row = RowCount; 			
				SDR_VERIFY	64	TDI	(#0^64)
								TDO	(FuseArray_TDI_CFG0[1]);	
				setpin ISPEN HIGH;													
			}  
			RowCount = RowCount +1;
		}		
		Adrr = 32768;
		@SPISELECT_SECTOR2();
		repeat Temp_UFM_Count
    	{	
    		FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];			
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (FuseArray_TDI_CFG0[1] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;
				FuseMapAddr[1] = $FuseMapAddr[1];			
				setpin ISPEN LOW;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction; 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN LOW;
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
				SDR 32	TDI	(0x000000CE);	    
				! Shift out Data Row = RowCount; 			
				SDR_VERIFY	64	TDI	(#0^64)
								TDO	(FuseArray_TDI_CFG0[1]);	
				setpin ISPEN HIGH;					
			}  
			RowCount = RowCount +1;
		}
	}
	ELSE
	{
		setpin ISPEN HIGH;
		@SPIDISABLE();
		print (1, "Failed in Function SPIVERIFY_CFG /see log file for more details/ ");
	}	
}
function I2CVERIFY_CFG 
{
	int32	RowCount = 1;
	int32 	Adrr = 0;
	datastream FuseMapAddr[1][32];
	datastream Temp[1][32];
	datastream FuseArray_TDI_CFG0[1][64];
	FuseArray_TDI.row = 1;
	
	TRY 1 {	
		@I2CSELECT_SECTOR0();
		repeat Temp_UFM_Count
		{	
			FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (FuseArray_TDI_CFG0[1] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;
				FuseMapAddr[1] = $FuseMapAddr[1];		
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32 TDI(FuseMapAddr[1]); 
				I2C_STOP;	
			}
			ELSE
			{
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
				SDR 32	TDI	(0x000000CE);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				! Shift out Data Row = RowCount; 			
				SDR_VERIFY	64	TDI	(#0^64)
								TDO	(FuseArray_TDI_CFG0[1]);	
				I2C_STOP;															
			}  
			RowCount = RowCount +1;			
		}	
		Adrr = 49152;				
		@I2CSELECT_SECTOR1();
		repeat Temp_UFM_Count
		{	
			FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (FuseArray_TDI_CFG0[1] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;
				FuseMapAddr[1] = $FuseMapAddr[1];		
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32 TDI(FuseMapAddr[1]); 
				I2C_STOP;	
			}
			ELSE
			{
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
				SDR 32	TDI	(0x000000CE);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				! Shift out Data Row = RowCount; 			
				SDR_VERIFY	64	TDI	(#0^64)
								TDO	(FuseArray_TDI_CFG0[1]);		
				I2C_STOP;											
			}  
			RowCount = RowCount +1;			
		}	
		Adrr = 32768;
		@I2CSELECT_SECTOR2();
		repeat Temp_UFM_Count
		{	
			FuseArray_TDI_CFG0[1] = FuseArray_TDI[RowCount];
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (FuseArray_TDI_CFG0[1] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;
				FuseMapAddr[1] = $FuseMapAddr[1];		
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32 TDI(FuseMapAddr[1]); 
				I2C_STOP;	
			}
			ELSE
			{
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
				SDR 32	TDI	(0x000000CE);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				! Shift out Data Row = RowCount; 			
				SDR_VERIFY	64	TDI	(#0^64)
								TDO	(FuseArray_TDI_CFG0[1]);
				I2C_STOP;													
			}  
			RowCount = RowCount +1;			
		}				
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1, "Failed in Function I2CVERIFY_CFG /see log file for more details/ ");
	}	
}
function JTAGI2CVERIFY_CFG 
{
	int32	RowCount = 1;
	int32 	Adrr = 0;
	datastream FuseMapAddr[1][32];
	datastream Temp[1][32];
	datastream DataByte[1][8];
	datastream TmpJTAGI2CProgramDataArray[1][64];

	FuseArray_TDI.row = 1;
	TRY 1 {
		@JTAGI2CSELECT_SECTOR0();
		repeat Temp_UFM_Count
		{
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (FuseArray_TDI[RowCount] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;	

				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				DataByte[1] = FuseMapAddr[1] ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 8;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 16;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 24;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;				
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 2 DELAY 1;
			}
			ELSE
			{
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
				SDR	16	TDI (0x1073);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				TmpJTAGI2CVerifyDataArray[1] = FuseArray_TDI[RowCount];
				TmpJTAGI2CVerifyDataArray[1] = $TmpJTAGI2CVerifyDataArray[1];
				! Shift out Data Row = RowCount; 	
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1]);
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);	
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 8);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 16);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 24);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;	
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 32);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 40);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 48);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 56);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);	
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;					
			}  
			RowCount = RowCount +1;				
		}
		
		@JTAGI2CSELECT_SECTOR1();
		repeat Temp_UFM_Count
		{
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (FuseArray_TDI[RowCount] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;	

				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				DataByte[1] = FuseMapAddr[1] ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 8;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 16;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 24;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;				
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 2 DELAY 1;
			}
			ELSE
			{
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
				SDR	16	TDI (0x1073);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				TmpJTAGI2CVerifyDataArray[1] = FuseArray_TDI[RowCount];
				TmpJTAGI2CVerifyDataArray[1] = $TmpJTAGI2CVerifyDataArray[1];
				! Shift out Data Row = RowCount; 	
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1]);
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);	
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 8);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 16);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 24);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;	
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 32);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 40);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 48);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 56);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);	
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;					
			}  
			RowCount = RowCount +1;				
		}
		
		@JTAGI2CSELECT_SECTOR2();
		repeat Temp_UFM_Count
		{
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (FuseArray_TDI[RowCount] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;	

				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				DataByte[1] = FuseMapAddr[1] ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 8;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 16;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 24;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;				
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 2 DELAY 1;
			}
			ELSE
			{
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
				SDR	16	TDI (0x1073);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				TmpJTAGI2CVerifyDataArray[1] = FuseArray_TDI[RowCount];
				TmpJTAGI2CVerifyDataArray[1] = $TmpJTAGI2CVerifyDataArray[1];
				! Shift out Data Row = RowCount; 	
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1]);
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);	
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 8);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 16);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 24);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;	
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 32);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 40);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 48);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 56);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);	
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;					
			}  
			RowCount = RowCount +1;				
		}
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		STATE RESET;		
		STATE IDLE;	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;	
		print (1, "Failed in Function JTAGI2CVERIFY_CFG /see log file for more details/ ");
	}
}
//////////////////////////////////////////////////////////////////////////////////////////////////////
function SPIVERIFY_UFM {
	int32	RowCount = 1;
	int32 	Adrr = 0;
	datastream FuseMapAddr[1][32];
	datastream Temp[1][32];
	
	EFuseArray_TDI.row = 1;
	TRY 1 {
		repeat Temp_UFM_Count
    	{				
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (EFuseArray_TDI[RowCount] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;
				FuseMapAddr[1] = $FuseMapAddr[1];			
				setpin ISPEN LOW;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction; 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN LOW;
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
				SDR 32	TDI	(0x000000CE);	    
				! Shift out Data Row = RowCount; 			
				SDR_VERIFY	64	TDI	(#0^64)
								TDO	(EFuseArray_TDI[RowCount]);	
				setpin ISPEN HIGH;																	
			}  	
			RowCount = RowCount +1;
		}
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1, "Failed in Function SPIVERIFY_UFM /see log file for more details/ ");
	}	
}
function I2CVERIFY_UFM {
	int32	RowCount = 1;
	int32 	Adrr = 0;
	datastream FuseMapAddr[1][32];
	datastream Temp[1][32];
	EFuseArray_TDI.row = 1;
	TRY 1 {		     	
		repeat Temp_UFM_Count 
		{
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (EFuseArray_TDI[RowCount] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;
				FuseMapAddr[1] = $FuseMapAddr[1];		
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32 TDI(FuseMapAddr[1]); 
				I2C_STOP;	
			}
			ELSE
			{
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
				SDR 32	TDI	(0x000000CE);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				! Shift out Data Row = RowCount; 			
				SDR_VERIFY	64	TDI	(#0^64)
								TDO	(EFuseArray_TDI[RowCount]);	
				I2C_STOP;															
			}  
			RowCount = RowCount +1;	
		}			
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1, "Failed in Function I2CVERIFY_UFM /see log file for more details/ ");
	}	
}
function JTAGI2CVERIFY_UFM {
	int32	RowCount = 1;
	int32 	Adrr = 0;
	datastream FuseMapAddr[1][32];
	datastream Temp[1][32];
	datastream DataByte[1][8];
	datastream TmpJTAGI2CVerifyDataArray[1][64];
	EFuseArray_TDI.row = 1;
	TRY 1 {
		repeat Temp_UFM_Count
		{
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (EFuseArray_TDI[RowCount] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;	

				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				DataByte[1] = FuseMapAddr[1] ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 8;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 16;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 24;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;				
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 2 DELAY 1;
			}
			ELSE
			{
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
				SDR	16	TDI (0x1073);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				TmpJTAGI2CVerifyDataArray[1] = EFuseArray_TDI[RowCount];
				TmpJTAGI2CVerifyDataArray[1] = $TmpJTAGI2CVerifyDataArray[1];
				! Shift out Data Row = RowCount; 	
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1]);
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);	
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 8);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 16);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 24);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;	
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 32);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 40);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 48);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 56);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);	
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;					
			}  
			RowCount = RowCount +1;				
		}
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		STATE RESET;		
		STATE IDLE;	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;	
		print (1, "Failed in Function JTAGI2CVERIFY_UFM /see log file for more details/ ");
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////
function SPIPROGRAM_UFM_FULL
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x0000C062);
		setpin ISPEN HIGH;							
		repeat Temp_UFM_Count
		{
			setpin ISPEN LOW;
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000200E);    
			! Shift in Data Row = RowCount; 			
			SDR	64	TDI	(EFuseArray_TDI[RowCount]);
			setpin ISPEN HIGH;	
			loop PWP {
				setpin ISPEN HIGH;									
				RUN_TEST DELAY PWV;
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
				setpin ISPEN HIGH;																	
			}
			setpin ISPEN HIGH;	 
			RowCount = RowCount +1;		
		} 	
	}
}
function I2CPROGRAM_UFM_FULL 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI.row = 1)
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR(0x46) instruction;
		SDR 32	TDI (0x0000C062);
		I2C_STOP;			
		repeat Temp_UFM_Count
		{			
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000200E);    
			! Shift in Data Row = RowCount; 			
			SDR	64	TDI	(EFuseArray_TDI[RowCount]);
			I2C_STOP;							
			RowCount = RowCount +1;		
		} 	   
	}
}
function JTAGI2CPROGRAM_UFM_FULL 
{
	datastream DataByte[1][8];
	datastream TmpJTAGI2CProgramUFMArray[1][64];
	int32	RowCount = 1;
	IF (EFuseArray_TDI.row = 1)
	{
		@JTAGI2CSELECT_UFM();
		RUN_TEST DELAY PWP;
		repeat Temp_UFM_Count
		{
			TmpJTAGI2CProgramUFMArray[1] = EFuseArray_TDI[RowCount]; 
			TmpJTAGI2CProgramUFMArray[1] = $TmpJTAGI2CProgramUFMArray[1];
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR	16	TDI (0x1070);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1004);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Data Row = RowCount; 	
			DataByte[1] = TmpJTAGI2CProgramUFMArray[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramUFMArray[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramUFMArray[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;		
			DataByte[1] = (TmpJTAGI2CProgramUFMArray[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramUFMArray[1] << 32);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramUFMArray[1] << 40);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramUFMArray[1] << 48);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CProgramUFMArray[1] << 56);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			RowCount = RowCount +1;	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY PWP;			
		} 	
	}
}
///////////////////////////////////////////////////////////////////////////
function SPIVERIFY_UFM_FULL 
{
	int32	RowCount = 1;
	EFuseArray_TDI.row = 1;
	TRY 1 
	{
		setpin ISPEN LOW;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000000CE);
		SDR 32	TDI	(0xFFFFFFFF);
		repeat Temp_UFM_Count
    	{					    
			! Shift out Data Row = RowCount; 			
			SDR_VERIFY	64	TDI	(#0^64)
							TDO	(EFuseArray_TDI[RowCount]);
			RowCount = RowCount +1;
		}
		setpin ISPEN HIGH;								
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1, "Failed in Function SPIVERIFY_UFM /see log file for more details/ ");
	}	
}
function I2CVERIFY_UFM_FULL 
{
	int32	RowCount = 1;
	EFuseArray_TDI.row = 1;
	TRY 1 {	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    	SDR 32	TDI	(0x000000CE);
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 32	TDI	(#0^32)
						TDO (#0^32)
						MASK (#0^32);	
		repeat Temp_UFM_Count 
		{			
			! Shift out Data Row = RowCount; 			
			SDR_VERIFY	64	TDI	(#0^64)
							TDO	(EFuseArray_TDI[RowCount]);
			RowCount = RowCount +1;
		}
		I2C_STOP;																
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1, "Failed in Function I2CVERIFY_UFM /see log file for more details/ ");
	}	
}
function JTAGI2CVERIFY_UFM_FULL 
{
	datastream DataByte[1][8];
	datastream TmpJTAGI2CVerifyUFMArray[1][64];
	int32	RowCount = 1;
	EFuseArray_TDI.row = 1;
	TRY 1 {
		@JTAGI2CSELECT_UFM();
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR	16	TDI (0x1073);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);	
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;		
		repeat Temp_UFM_Count
		{
			TmpJTAGI2CVerifyUFMArray[1] = EFuseArray_TDI[RowCount];
			TmpJTAGI2CVerifyUFMArray[1] = $TmpJTAGI2CVerifyUFMArray[1];
			! Shift out Data Row = RowCount; 	
			DataByte[1] = (TmpJTAGI2CVerifyUFMArray[1]);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyUFMArray[1] << 8);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyUFMArray[1] << 16);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyUFMArray[1] << 24);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;	
			DataByte[1] = (TmpJTAGI2CVerifyUFMArray[1] << 32);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyUFMArray[1] << 40);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyUFMArray[1] << 48);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyUFMArray[1] << 56);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			RowCount = RowCount +1;			
		}
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		@JTAGI2CSELECT_UFM();
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;	
		print (1, "Failed in Function JTAGI2CVERIFY_UFM /see log file for more details/ ");
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////
function SPIPROGRAM_UFM {
	int32	RowCount = 1;
	int32 	Adrr = 49152;
	datastream FuseMapAddr[1][32];
	datastream Temp[1][32];
	
	IF (EFuseArray_TDI.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x0000C062);
		setpin ISPEN HIGH;							
		repeat Temp_UFM_Count
		{
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (EFuseArray_TDI[RowCount] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;
				FuseMapAddr[1] = $FuseMapAddr[1];			
				setpin ISPEN LOW;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction; 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN LOW;
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000200E);    
				! Shift in Data Row = RowCount; 			
				SDR	64	TDI	(EFuseArray_TDI[RowCount]);
				loop PWP {
					setpin ISPEN HIGH;									
					RUN_TEST DELAY PWV;
					setpin ISPEN LOW;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);														
				}	    						
			}  
			setpin ISPEN HIGH;
			RowCount = RowCount +1;		
		} 		
	}
}
function I2CPROGRAM_UFM {
	int32	RowCount = 1;
	int32 	Adrr = 49152;
	datastream FuseMapAddr[1][32];
	datastream Temp[1][32];
	IF (EFuseArray_TDI.row = 1)
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR(0x46) instruction;
		SDR 32	TDI (0x0000C062);
		I2C_STOP;			
		repeat Temp_UFM_Count
		{
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (EFuseArray_TDI[RowCount] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;
				FuseMapAddr[1] = $FuseMapAddr[1];		
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32 TDI(FuseMapAddr[1]); 
				I2C_STOP;	
			}
			ELSE
			{
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000200E);    
				! Shift in Data Row = RowCount; 			
				SDR	64	TDI	(EFuseArray_TDI[RowCount]);
				loop PWP {
					I2C_STOP;							
					RUN_TEST DELAY PWV;
					I2C_START;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_WRITE);
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					I2C_RESTART;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_READ);
					SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);				
				}   						
			}  
			I2C_STOP;
			RowCount = RowCount +1;		
		} 		   
	}
}
function JTAGI2CPROGRAM_UFM {
	int32	RowCount = 1;
	int32 	Adrr = 49152;
	datastream FuseMapAddr[1][32];
	datastream Temp[1][32];
	datastream DataByte[1][8];
	datastream TmpJTAGI2CProgramDataArray[1][64];
	IF (EFuseArray_TDI.row = 1)
	{
		@JTAGI2CSELECT_UFM();
		repeat Temp_UFM_Count
		{
			Adrr = Adrr + 4;
			Temp[1] = Adrr & 0x00000040;	
			IF (Temp[1] == 0x00000040)
			{	
				Adrr = Adrr + 192;
			}
			IF (EFuseArray_TDI[RowCount] == 0x0000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = FuseMapAddr[1] | 0xB4000000;	

				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				DataByte[1] = FuseMapAddr[1] ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 8;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 16;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				DataByte[1] = FuseMapAddr[1] << 24;
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10 @ DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;				
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 2 DELAY 1;
			}
			ELSE
			{
				TmpJTAGI2CProgramDataArray[1] = EFuseArray_TDI[RowCount]; 
				TmpJTAGI2CProgramDataArray[1] = $TmpJTAGI2CProgramDataArray[1];
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR	16	TDI (0x1070);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1004);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Data Row = RowCount; 	
				DataByte[1] = TmpJTAGI2CProgramDataArray[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 32);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 40);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 48);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 56);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				
				loop PWP {
					RUN_TEST IDLE TCK 2 DELAY 1;
					! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
					SIR	8	TDI  (0x9D);
					SDR	16	TDI  (0x5000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + WR;
					SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
					RUN_TEST IDLE TCK 1000 ;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR	16	TDI (0x10F0);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + RD;
					SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x2000);
					RUN_TEST IDLE TCK 1000 ;
					SIR	8	TDI  (0x9E);
					SDR_VERIFY	8	TDI  (0x00)
									TDO  (0x00)
									MASK (0x80);
				}					
			}  
			RowCount = RowCount +1;		
		} 	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
	}
}
///////////////////////////////////////////////////////////////////////////
function SPIPROGRAM_CFG_USERCODE 
{
	! Select Sector 0;
	@SPISELECT_SECTOR0();
	! Program Sector 0 Usercode;
	@SPIPROGRAM_USERCODE_CFG();
}
function I2CPROGRAM_CFG_USERCODE {
	! Select Sector 0;
	@I2CSELECT_SECTOR0();
	! Program Sector 0 Usercode;
	@I2CPROGRAM_USERCODE_CFG();
}
function JTAGI2CPROGRAM_CFG_USERCODE {
	! Select Sector 0;
	@JTAGI2CSELECT_SECTOR0();
	! Program Sector 0 Usercode;
	@JTAGI2CPROGRAM_USERCODE_CFG();
}
/////////////////////////////////////////////////////////////////////////
function SPIVERIFY_CFG_USERCODE 
{
	@SPISELECT_SECTOR0();
	@SPIVERIFY_USERCODE_CFG();
}
function I2CVERIFY_CFG_USERCODE {
	@I2CSELECT_SECTOR0();
	@I2CVERIFY_USERCODE_CFG();
}
function JTAGI2CVERIFY_CFG_USERCODE 
{
	@JTAGI2CSELECT_SECTOR0();
	@JTAGI2CVERIFY_USERCODE_CFG();	
}
//////////////////////////////////////////////////////////////////////////////////
function SPIUFMPROGRAM_DONE_BIT 
{
	! Select UFM;
	@SPISELECT_UFM();
	! Program Sector3 Done bit;
	@SPIPROGRAM_DONE_BIT_SECTOR3();
}
function I2CUFMPROGRAM_DONE_BIT 
{
	! Select UFM;
	@I2CSELECT_UFM();
	! Program Sector3 Done bit;
	@I2CPROGRAM_DONE_BIT_SECTOR3();
}
function JTAGI2CUFMPROGRAM_DONE_BIT 
{
	! Select UFM;
	@JTAGI2CSELECT_UFM();
	! Program Sector3 Done bit;
	@JTAGI2CPROGRAM_DONE_BIT_SECTOR3();	
}
//////////////////////////////////////////////////////////////////////////////////
function SPIFLASHPROGRAM_DONE_BIT 
{
	! Select CFG Sector1;
	@SPISELECT_SECTOR1();
	! Program Sector1 Done bit;
	@SPIPROGRAM_DONE_BIT_SECTOR1();
	
	! Select CFG Sector2;
	@SPISELECT_SECTOR2();
	! Program Sector2 Done bit;
	@SPIPROGRAM_DONE_BIT_SECTOR2();
	
	! Select CFG Sector0;
	@SPISELECT_SECTOR0();
	! Program Sector0 Done bit;
	@SPIPROGRAM_DONE_BIT_SECTOR0();
	! Verify Sector0 Done bit;
	@SPIVERIFY_DONE_BIT();
}
function I2CFLASHPROGRAM_DONE_BIT 
{
	! Select CFG Sector1;
	@I2CSELECT_SECTOR1();
	! Program Sector1 Done bit;
	@I2CPROGRAM_DONE_BIT_SECTOR1();
	
	! Select CFG Sector2;
	@I2CSELECT_SECTOR2();
	! Program Sector2 Done bit;
	@I2CPROGRAM_DONE_BIT_SECTOR2();
	
	! Select CFG Sector0;
	@I2CSELECT_SECTOR0();
	! Program Sector0 Done bit;
	@I2CPROGRAM_DONE_BIT_SECTOR0();
	! Verify Sector0 Done bit;
	@I2CVERIFY_DONE_BIT();
}
function JTAGI2CFLASHPROGRAM_DONE_BIT 
{
	! Select CFG Sector1;
	@JTAGI2CSELECT_SECTOR1();
	! Program Sector1 Done bit;
	@JTAGI2CPROGRAM_DONE_BIT_SECTOR1();
	
	! Select CFG Sector2;
	@JTAGI2CSELECT_SECTOR2();
	! Program Sector2 Done bit;
	@JTAGI2CPROGRAM_DONE_BIT_SECTOR2();
	
	! Select CFG Sector0;
	@JTAGI2CSELECT_SECTOR0();
	! Program Sector0 Done bit;
	@JTAGI2CPROGRAM_DONE_BIT_SECTOR0();
	! Verify Sector0 Done bit;
	@JTAGI2CVERIFY_DONE_BIT();
}
/////////////////////////////////////////////////////////////////////////////
function SPISELECT_SECTOR0 {
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00000062);
	setpin ISPEN HIGH;
}
function I2CSELECT_SECTOR0 {
	loop PWP {
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00000062);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
						TDO(0x00000000)
						MASK(0x00070000);			
	}
	I2C_STOP;
}
function JTAGI2CSELECT_SECTOR0 
{
	loop PWP 
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR	16	TDI (0x1046);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 	
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 	
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR	8	TDI  (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0xE0);
		RUN_TEST IDLE TCK 1000 ;
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 
}
///////////////////////////////////////////////////////////////////////////////////////
function SPISELECT_SECTOR1 {
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00008062);
	setpin ISPEN HIGH;
}
function I2CSELECT_SECTOR1 {
	loop PWP {
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00008062);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
						TDO(0x00040000)
						MASK(0x00070000);			
	}
	I2C_STOP;
}
function JTAGI2CSELECT_SECTOR1 
{
	datastream DataByte[1][8];
	loop PWP 
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR	16	TDI (0x1046);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1001);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 	
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 	
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR	8	TDI  (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x20)
						MASK (0xE0);
		RUN_TEST IDLE TCK 1000 ;
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 
}
//////////////////////////////////////////////////////////////////////////////////////////////
function SPISELECT_SECTOR2 {
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00004062);
	setpin ISPEN HIGH;
}
function I2CSELECT_SECTOR2 
{
	loop PWP {
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00004062);
		I2C_STOP;	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
						TDO(0x00020000)
						MASK(0x00070000);				
	}
	I2C_STOP;
}
function JTAGI2CSELECT_SECTOR2 
{
	loop PWP 
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR	16	TDI (0x1046);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1002);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 	
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 	
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR	8	TDI  (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x40)
						MASK (0xE0);
		RUN_TEST IDLE TCK 1000 ;
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 
}
///////////////////////////////////////////////////////////////////////////////////////////
function SPIPROGRAM_USERCODE_CFG 
{
	IF (Usercode_TDI.row = 1)
	{
	    setpin ISPEN LOW;
	    ! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32 TDI (0x00000043);
	    SDR Usercode_Length	TDI (Usercode_TDI[1]);
	    setpin ISPEN HIGH;	
	    RUN_TEST DELAY PWP;		
	}		
}
function I2CPROGRAM_USERCODE_CFG {
	IF (Usercode_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	 	! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
	    SDR Usercode_Length	TDI	(Usercode_TDI[1]);
		I2C_STOP;	
		RUN_TEST DELAY PWP;
	}
}
function JTAGI2CPROGRAM_USERCODE_CFG {
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
		SDR	16	TDI (0x10C2);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
	 	SavedUsercode[1] = Usercode_TDI[1];
	 	SavedUsercode[1] = $SavedUsercode[1];
	    DataByte[1] = SavedUsercode[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1; 
	}
}
////////////////////////////////////////////////////////////////////////////////////
function SPIVERIFY_USERCODE_CFG {
	IF (Usercode_TDI.row = 1)
	{
		setpin ISPEN LOW; 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SDR_VERIFY 	32 	TDI (#0^Usercode_Length)
					   	TDO	(Usercode_TDI[1])
						MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;								
	}
}
function I2CVERIFY_USERCODE_CFG {
	IF (Usercode_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
	    SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(Usercode_TDI[1])
									MASK(0xFFFFFFFF);
		I2C_STOP;									
	}
}
function JTAGI2CVERIFY_USERCODE_CFG 
{
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{		
		SavedUsercode[1] = Usercode_TDI[1];
		SavedUsercode[1] = $SavedUsercode[1];
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR	16	TDI (0x10C0);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		TRY 1 {
			DataByte[1] = SavedUsercode[1];
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (SavedUsercode[1] << 8);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);	
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (SavedUsercode[1] << 16);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (SavedUsercode[1] << 24);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ; 
		}
		ELSE {
	    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100;
    		print (1,"Failed to Verify USERCODE. Cannot continue.");
        }									
	}
}
//////////////////////////////////////////////////////////////////////////////////////////
function SPIPROGRAM_DONE_BIT_SECTOR0 
{
	setpin ISPEN LOW;
	! Shift in ISC_PROGRAM_DONE(0x5E) instruction;
	SDR 32 TDI (0x0080007A);
	setpin ISPEN HIGH;
	RUN_TEST DELAY PWP;
}
function I2CPROGRAM_DONE_BIT_SECTOR0 {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SDR	32 	TDI (0x0080007A);
	I2C_STOP;	
	RUN_TEST DELAY PWP;
}
function JTAGI2CPROGRAM_DONE_BIT_SECTOR0 {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
	SDR	16	TDI (0x105E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1001);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
	RUN_TEST	IDLE TCK 2 DELAY PWP;	
}
///////////////////////////////////////////////////////////////////////////
function SPIPROGRAM_DONE_BIT_SECTOR1 
{
	setpin ISPEN LOW;
	! Shift in ISC_PROGRAM_DONE(0x5E) instruction;
	SDR 32 TDI (0x00C0807A);
	setpin ISPEN HIGH;
    RUN_TEST DELAY PWP;
}
function I2CPROGRAM_DONE_BIT_SECTOR1 {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SDR	32 	TDI (0x00C0807A);
	I2C_STOP;	
	RUN_TEST DELAY PWP;
}
function JTAGI2CPROGRAM_DONE_BIT_SECTOR1 {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
	SDR	16	TDI (0x105E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1001);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1003);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
	RUN_TEST	IDLE TCK 2 DELAY PWP;	
}
///////////////////////////////////////////////////////////////////////////////////
function SPIPROGRAM_DONE_BIT_SECTOR2 
{
	setpin ISPEN LOW;
	! Shift in ISC_PROGRAM_DONE(0x5E) instruction;
	SDR 32 TDI (0x00C0407A);
	setpin ISPEN HIGH;
    RUN_TEST DELAY PWP;
}
function I2CPROGRAM_DONE_BIT_SECTOR2 {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SDR	32 	TDI (0x00C0407A);
	I2C_STOP;	
	RUN_TEST DELAY PWP;
}
function JTAGI2CPROGRAM_DONE_BIT_SECTOR2 {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
	SDR	16	TDI (0x105E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1002);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1003);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
	RUN_TEST	IDLE TCK 2 DELAY PWP;	
}
/////////////////////////////////////////////////////////////////////////////
function SPIPROGRAM_DONE_BIT_SECTOR3 
{
	setpin ISPEN LOW;
	! Shift in ISC_PROGRAM_DONE(0x5E) instruction;
	SDR 32 TDI (0x00C0C07A);
	setpin ISPEN HIGH;
    RUN_TEST DELAY 200;
}
function I2CPROGRAM_DONE_BIT_SECTOR3 
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SDR 32 TDI (0x00C0C07A);
	I2C_STOP;	
	RUN_TEST DELAY PWP;
}
function JTAGI2CPROGRAM_DONE_BIT_SECTOR3 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
	SDR	16	TDI (0x105E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1003);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1003);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
	RUN_TEST	IDLE TCK 2 DELAY PWP;	
}
/////////////////////////////////////////////////////////////////////////////
function SPIVERIFY_DONE_BIT {
	TRY 1 {
        setpin ISPEN LOW;
	    ! Shift out LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY 32 TDI (#0^32)
		       	      TDO (0x00002000)
		              MASK (0x00002000);
		setpin ISPEN HIGH;
	}
	ELSE {
		setpin ISPEN HIGH;		
		setpin ISPEN LOW;	  
		! Shift in ISC DISABLE(0x26) instruction;
	   	SDR 32 TDI (0x00000064);
	    setpin ISPEN HIGH;   
	    print (1,"Failed to Verify DONE bit /see log file for more details/ "); 	
    }
}
function I2CVERIFY_DONE_BIT {
	TRY 1 {
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
						TDO (0x00002000)
						MASK (0x00002000);
		I2C_STOP;	
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1, "Failed to Verify DONE bit /see log file for more details/ ");
	}	
}
function JTAGI2CVERIFY_DONE_BIT {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1 {
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x04);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;					
	}
	ELSE
	{		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;		
		print (1, "Failed to Verify DONE bit /see log file for more details/ ");
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////
function SPIDISPLAY_FLASH_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	@SPISELECT_CFG();
	setpin ISPEN LOW;
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    SDR	32	TDI(#0^Usercode_Length)
			TDO(SavedUsercode);
	setpin ISPEN HIGH;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function SPIFLASH_SAVE_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	@SPISELECT_CFG();
	setpin ISPEN LOW;
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    SDR	32	TDI(#0^Usercode_Length)
			TDO(SavedUsercode);
	setpin ISPEN HIGH;
	SavedUsercode[1] = $SavedUsercode[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function I2CFLASH_SAVE_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	@I2CSELECT_CFG();
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
    SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	I2C_STOP;
	SavedUsercode[1] = $SavedUsercode[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function I2CDISPLAY_FLASH_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	@I2CSELECT_CFG();
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
    SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	I2C_STOP;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function JTAGI2CDISPLAY_FLASH_USERCODE {
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	@JTAGI2CSELECT_CFG();
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in READ USERCODE(0xC0) instruction;
    SDR	16	TDI (0x10C0);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	SavedUsercode[1] = $SavedUsercode[1] ;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function JTAGI2CFLASH_SAVE_USERCODE {
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	@JTAGI2CSELECT_CFG();
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in READ USERCODE(0xC0) instruction;
    SDR	16	TDI (0x10C0);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
//////////////////////////////////////////////////////////////////////////////////////
function SPICFG_SAVE {
	int32	RowCount = 1;
	datastream SavedFuseMap[Temp_Row_Count][64];
	file NewFile = "FILE_SAVE";
	
	@SPISELECT_SECTOR0();
	setpin ISPEN LOW;
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
	SDR 32	TDI	(0x000000CE);
	SDR 32	TDI	(0xFFFFFFFF);	
	repeat Temp_UFM_Count
	{	
    	! Shift out Data Row = RowCount; 			
		SDR 64 TDI(#0^64)
			   TDO	(SavedFuseMap[RowCount]);
		RowCount = RowCount +1;
	}
	setpin ISPEN HIGH;		
	@SPISELECT_SECTOR1();
	setpin ISPEN LOW;
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
  	SDR 32	TDI	(0x000000CE);	    
    SDR 32	TDI	(0xFFFFFFFF);	
	repeat Temp_UFM_Count
	{	
    	! Shift out Data Row = RowCount; 			
		SDR 64 TDI(#0^64)
				TDO	(SavedFuseMap[RowCount]);
		RowCount = RowCount +1;
	}
	setpin ISPEN HIGH;			
	@SPISELECT_SECTOR2();
	setpin ISPEN LOW;
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
  	SDR 32	TDI	(0x000000CE);	    
    SDR 32	TDI	(0xFFFFFFFF);	
	repeat Temp_UFM_Count
	{	
    	! Shift out Data Row = RowCount; 			
		SDR 64 TDI(#0^64)
				TDO	(SavedFuseMap[RowCount]);
		RowCount = RowCount +1;
	}
	setpin ISPEN HIGH;		
	// Write To file 
	fopen NewFile att "wa"
	format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
function I2CCFG_SAVE 
{
	int32	RowCount = 1;
	datastream SavedFuseMap[Temp_Row_Count][64];
	file NewFile = "FILE_SAVE";
	
	@I2CSELECT_SECTOR0();
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
	SDR 32	TDI	(0x000000CE);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 32	TDI	(0xFFFFFFFF)
					TDO (0xFFFFFFFF)
					MASK(0x00000000);	
	repeat Temp_UFM_Count 
	{			
		! Shift out Data Row = RowCount; 			
		SDR	64	TDI	(#0^64)
				TDO	(SavedFuseMap[RowCount]);
		RowCount = RowCount +1;
	}	
	I2C_STOP;														
	@I2CSELECT_SECTOR1();
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
	SDR 32	TDI	(0x000000CE);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 32	TDI	(0xFFFFFFFF)
					TDO (0xFFFFFFFF)
					MASK(0x00000000);	
	repeat Temp_UFM_Count 
	{			
		! Shift out Data Row = RowCount; 			
		SDR	64	TDI	(#0^64)
				TDO	(SavedFuseMap[RowCount]);
		RowCount = RowCount +1;
	}	
	I2C_STOP;														
	@I2CSELECT_SECTOR0();
	@I2CSELECT_SECTOR2();
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
	SDR 32	TDI	(0x000000CE);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 32	TDI	(0xFFFFFFFF)
					TDO (0xFFFFFFFF)
					MASK(0x00000000);	
	repeat Temp_UFM_Count 
	{			
		! Shift out Data Row = RowCount; 			
		SDR	64	TDI	(#0^64)
				TDO	(SavedFuseMap[RowCount]);
		RowCount = RowCount +1;
	}
	I2C_STOP;																
	// Write To file 
	fopen NewFile att "wa"
	format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
function JTAGI2CCFG_SAVE 
{
	int32	RowCount = 1;
	datastream DataByte[1][8];
	datastream SavedFuseMap[Temp_Row_Count][64];
	file NewFile = "FILE_SAVE";
	
	@JTAGI2CSELECT_SECTOR0();
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
	SDR	16	TDI (0x1073);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);	
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;	
	repeat Temp_UFM_Count
	{	
		! Shift out Data Row = RowCount; 	
    	SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;		
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;				
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;	
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		SavedFuseMap[RowCount] = $SavedFuseMap[RowCount];
		RowCount = RowCount +1;		
	}	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;
	
	@JTAGI2CSELECT_SECTOR1();
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
	SDR	16	TDI (0x1073);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);	
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;	
	repeat Temp_UFM_Count
	{	
		! Shift out Data Row = RowCount; 	
    	SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;		
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;				
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;	
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SavedFuseMap[RowCount] = $SavedFuseMap[RowCount];
		RowCount = RowCount +1;		
	}	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;
	
	@JTAGI2CSELECT_SECTOR2();
	@JTAGI2CSELECT_SECTOR2();
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
	SDR	16	TDI (0x1073);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);	
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;	
	repeat Temp_UFM_Count
	{	
		! Shift out Data Row = RowCount; 	
    	SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;		
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;				
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;	
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SavedFuseMap[RowCount] = $SavedFuseMap[RowCount];
		RowCount = RowCount +1;		
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;	
	// Write To file 
	fopen NewFile att "wa"
	format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
/////////////////////////////////////////////////////////////////////////////////////////////////
function SPIUFM_SAVE {
	int32	RowCount = 1;
	datastream SavedEFuseMap[Temp_UFM_Count][64];
	file NewFile = "FILE_SAVE";
	
	
	setpin ISPEN LOW;
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
   	SDR 32	TDI	(0x000000CE);	
   	SDR 32	TDI	(0xFFFFFFFF);
	repeat Temp_UFM_Count
    {	
    	! Shift out Data Row = RowCount; 			
		SDR 64 TDI(#0^64)
				TDO	(SavedEFuseMap[RowCount]);
		RowCount = RowCount +1;
	}	
	setpin ISPEN HIGH;		
	// Write To file 
	fopen NewFile att "wa"
	format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI, SavedEFuseMap);
	fclose 	NewFile;
}
function I2CUFM_SAVE 
{
	int32	RowCount = 1;
	datastream SavedEFuseMap[Temp_UFM_Count][64];
	file NewFile = "FILE_SAVE";
	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
	SDR 32	TDI	(0x000000CE);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 32	TDI	(#0^32)
					TDO (#0^32)
					MASK(#0^32);			
	repeat Temp_UFM_Count 
	{			
		! Shift out Data Row = RowCount; 			
		SDR	64	TDI	(#0^64)
				TDO	(SavedEFuseMap[RowCount]);
		RowCount = RowCount +1;
	}	
	I2C_STOP;														
		
	// Write To file 
	fopen NewFile att "wa"
	format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI, SavedEFuseMap);
	fclose 	NewFile;
}
function JTAGI2CUFM_SAVE {
	int32	RowCount = 1;
	datastream DataByte[1][8];
	datastream SavedFuseMap[Temp_UFM_Count][64];
	file NewFile = "FILE_SAVE";
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
	SDR	16	TDI (0x1073);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift out Data Row = RowCount; 	
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);	
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;		
	repeat Temp_UFM_Count
	{	
		
    	SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;		
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;				
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;	
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SavedFuseMap[RowCount] = $SavedFuseMap[RowCount];
		RowCount = RowCount +1;		
	}	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;		
		
	// Write To file 
	fopen NewFile att "wa"
	format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
//////////////////////////////////////////////////////////////////////////////////////////////
function SPIFLASH_PROGRAM_FULL
{
	print (0,"Programming CFG");
	! Programming CFG;
	! Select CFG;
	@SPISELECT_CFG();
	! Check Password Protect;
	@SPICHECK_CFG_PASSWORD();
	! Erase the CFG;
	@SPICFG_ERASE();
	! Program CFG;
	@SPICFG_PROGRAM_FULL();
	! Verify CFG;	
	@SPICFG_VERIFY_FULL();
	print (0,"Programming UFM");
	! Programming UFM;
	! Select UFM;
	@SPISELECT_UFM();
	! Check Password Protect;
	@SPICHECK_UFM_PASSWORD();
	! Erase UFM;
	@SPIUFM_ERASE(); 
	! Program UFM;
	@SPIUFM_PROGRAM_FULL(); 
	! Verify UFM;													
	@SPIUFM_VERIFY_FULL();  
	! Program DONE bit;
	@SPIFLASHPROGRAM_DONE_BIT();
	@SPIUFMPROGRAM_DONE_BIT();	   
	IF (PasswordEn == 1)
	{
		print (0,"Enable Password Protect...");
		! Enable Password Protect; 
		@SPISELECT_SECTOR1();
		// Program Sector1 Password Protect
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00038073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;		
		
		@SPISELECT_SECTOR2();
		// Program Sector2 Password Protect
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00034073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;	
		
		@SPISELECT_SECTOR0();
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00030073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;				
	}
			 	
}
function SPIFLASH_PROGRAM 
{
	print (0,"Programming CFG");
	! Programming CFG;
	! Select CFG;
	@SPISELECT_CFG();
	! Check Password Protect;
	@SPICHECK_CFG_PASSWORD();
	! Erase the CFG;
	@SPICFG_ERASE();
	! Program CFG;
	@SPICFG_PROGRAM();
	! Verify CFG;	
	@SPICFG_VERIFY();
	print (0,"Programming UFM");
	! Programming UFM;
	! Select UFM;
	@SPISELECT_UFM();
	! Check Password Protect;
	@SPICHECK_UFM_PASSWORD();
	! Erase UFM;
	@SPIUFM_ERASE(); 
	! Program UFM;
	@SPIUFM_PROGRAM(); 
	! Verify UFM;													
	@SPIUFM_VERIFY();  
	! Program DONE bit;
	@SPIFLASHPROGRAM_DONE_BIT();   
	@SPIUFMPROGRAM_DONE_BIT();
	IF (PasswordEn == 1)
	{
		print (0,"Enable Password Protect...");
		! Enable Password Protect; 
		@SPISELECT_SECTOR1();
		// Program Sector1 Password Protect
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00038073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;		
		@SPISELECT_SECTOR2();
		// Program Sector2 Password Protect
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00034073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;	
		@SPISELECT_SECTOR0();
		// Program Sector0 Password Protect
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00030073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;				
	}
				 	
}
function I2CFLASH_PROGRAM_FULL 
{
	print (0,"Programming CFG");
	! Programming CFG;
	! Select CFG;
	@I2CSELECT_CFG();
	! Check Password Protect;
	@I2CCHECK_CFG_PASSWORD();
	! Erase the CFG;
	@I2CCFG_ERASE();
	! Program CFG;
	@I2CCFG_PROGRAM_FULL();	 
	! Verify CFG;	
	@I2CCFG_VERIFY_FULL();	
	print (0,"Programming UFM");
	! Programming UFM;
	! Select UFM;
	@I2CSELECT_UFM();
	! Check Password Protect;
	@I2CCHECK_UFM_PASSWORD();
	! Erase UFM;
	@I2CUFM_ERASE(); 
	! Program UFM;
	@I2CUFM_PROGRAM_FULL(); 
	! Verify UFM;													
	@I2CUFM_VERIFY_FULL(); 
	! Program DONE bit;
	@I2CFLASHPROGRAM_DONE_BIT();  
	@I2CUFMPROGRAM_DONE_BIT();  
	IF (PasswordEn == 1)
	{
		print (0,"Enable Password Protect...");
		! Enable Password Protect; 
		@I2CSELECT_SECTOR1();
		// Program Sector1 Password Protect
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00038073);
		I2C_STOP;
		RUN_TEST DELAY PWP;	
		
		@I2CSELECT_SECTOR2();
		// Program Sector2 Password Protect
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00034073);
		I2C_STOP;
		RUN_TEST DELAY PWP;	
		
		@I2CSELECT_SECTOR0();
		// Program Sector0 Password Protect
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00030073);
		I2C_STOP;
		RUN_TEST DELAY PWP;	
				
	}
			
}
function I2CFLASH_PROGRAM {
	print (0,"Programming CFG");
	! Select CFG;
	@I2CSELECT_CFG();
	! Check Password Protect;
	@I2CCHECK_CFG_PASSWORD();
	! Erase the CFG;
	@I2CCFG_ERASE();
	! Program CFG;
	@I2CCFG_PROGRAM();	 
	! Verify CFG;	
	@I2CCFG_VERIFY();	
	print (0,"Programming UFM");
	! Select UFM;
	@I2CSELECT_UFM();
	! Check Password Protect;
	@I2CCHECK_UFM_PASSWORD();
	! Erase UFM;
	@I2CUFM_ERASE(); 
	! Program UFM;
	@I2CUFM_PROGRAM(); 
	! Verify UFM;													
	@I2CUFM_VERIFY();   
	! Program DONE bit;
	@I2CFLASHPROGRAM_DONE_BIT();
	@I2CUFMPROGRAM_DONE_BIT();	  
	IF (PasswordEn == 1)
	{
		print (0,"Enable Password Protect...");
		! Enable Password Protect; 
		@I2CSELECT_SECTOR1();
		// Program Sector1 Password Protect
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00038073);
		I2C_STOP;
		RUN_TEST DELAY PWP;	
		
		@I2CSELECT_SECTOR2();
		// Program Sector2 Password Protect
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00034073);
		I2C_STOP;
		RUN_TEST DELAY PWP;	
		
		@I2CSELECT_SECTOR0();
		// Program Sector0 Password Protect
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00030073);
		I2C_STOP;
		RUN_TEST DELAY PWP;				
	}
		
}
function JTAGI2CFLASH_PROGRAM_FULL
{
	print (0,"Programming CFG");
	! Select CFG;
	@JTAGI2CSELECT_CFG();
	! Check Password Protect;
	@JTAGI2CCHECK_CFG_PASSWORD();
	! Erase the CFG;
	@JTAGI2CCFG_ERASE();
	! Program CFG;
	@JTAGI2CCFG_PROGRAM_FULL();	 
	! Verify CFG;	
	@JTAGI2CCFG_VERIFY_FULL();
	print (0,"Programming UFM");
	! Select UFM;
	@JTAGI2CSELECT_UFM();
	! Check Password Protect;
	@JTAGI2CCHECK_UFM_PASSWORD();
	! Erase UFM;
	@JTAGI2CUFM_ERASE(); 
	! Program UFM;
	@JTAGI2CUFM_PROGRAM_FULL(); 
	! Verify UFM;	
	@JTAGI2CUFM_VERIFY();    
	! Program DONE bit;
	@JTAGI2CFLASHPROGRAM_DONE_BIT();
	@JTAGI2CUFMPROGRAM_DONE_BIT();		
	IF (PasswordEn == 1)
	{
		print (0,"Enable Password Protect...");
		! Program Sector0,1 and 2 Password Protect;
		
		@JTAGI2CSELECT_SECTOR1();
		// Program Sector1 Password Protect
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1001);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;
		
		@JTAGI2CSELECT_SECTOR2();
		// Program Sector2 Password Protect
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1002);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;
		
		@JTAGI2CSELECT_SECTOR0();
		// Program Sector0 Password Protect	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;
	}		
}
function JTAGI2CFLASH_PROGRAM 
{
	print (0,"Programming CFG");
	! Select CFG;
	@JTAGI2CSELECT_CFG();
	! Check Password Protect;
	@JTAGI2CCHECK_CFG_PASSWORD();
	! Erase the CFG;
	@JTAGI2CCFG_ERASE();
	! Program CFG;
	@JTAGI2CCFG_PROGRAM();	 
	! Verify CFG;	
	@JTAGI2CCFG_VERIFY();	
	print (0,"Programming UFM");
	! Select UFM;
	@JTAGI2CSELECT_UFM();
	! Check Password Protect;
	@JTAGI2CCHECK_UFM_PASSWORD();
	! Erase UFM;
	@JTAGI2CUFM_ERASE(); 
	! Program UFM;
	@JTAGI2CUFM_PROGRAM(); 
	! Verify UFM;													
	@JTAGI2CUFM_VERIFY();   
	! Program DONE bit;
	@JTAGI2CFLASHPROGRAM_DONE_BIT();  
	@JTAGI2CUFMPROGRAM_DONE_BIT();	
	IF (PasswordEn == 1)
	{
		print (0,"Enable Password Protect...");
		! Program Sector0,1 and 2 Password Protect;
			
		@JTAGI2CSELECT_SECTOR1();
		// Program Sector1 Password Protect
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1001);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;
		
		@JTAGI2CSELECT_SECTOR2();
		// Program Sector2 Password Protect
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1002);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;
		
		@JTAGI2CSELECT_SECTOR0();
		// Program Sector0 Password Protect	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;
	}			
}
//////////////////////////////////////////////////////////////////
function SPIFLASH_CFG_PROGRAM_FULL 
{
	print (0,"Programming CFG");
	! Programming CFG;
	! Select CFG;
	@SPISELECT_CFG();
	! Check Password Protect;
	@SPICHECK_CFG_PASSWORD();
	! Erase the CFG;
	@SPICFG_ERASE();
	! Program CFG;
	@SPICFG_PROGRAM_FULL();	 
	! Verify CFG;	
	@SPICFG_VERIFY_FULL();
	! Program DONE bit;
	@SPIFLASHPROGRAM_DONE_BIT();	  
	IF (PasswordEn == 1)
	{
		print (0,"Enable Password Protect...");
		! Enable Password Protect; 
		
		@SPISELECT_SECTOR1();
		// Program Sector1 Password Protect
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00038073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;		
		
		@SPISELECT_SECTOR2();
		// Program Sector2 Password Protect
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00034073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;	
		
		@SPISELECT_SECTOR0();
		// Program Sector0 Password Protect
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00030073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;		
			
	}
}
function SPIFLASH_CFG_PROGRAM 
{
	print (0,"Programming CFG");
	! Programming CFG;
	! Select CFG;
	@SPISELECT_CFG();
	! Check Password Protect;
	@SPICHECK_CFG_PASSWORD();
	! Erase the CFG;
	@SPICFG_ERASE();
	! Program CFG;
	@SPICFG_PROGRAM();	 
	! Verify CFG;	
	@SPICFG_VERIFY();	 
	! Program DONE bit;
	@SPIFLASHPROGRAM_DONE_BIT(); 
	IF (PasswordEn == 1)
	{
		print (0,"Enable Password Protect...");
		! Enable Password Protect; 
		@SPISELECT_SECTOR1();
		// Program Sector1 Password Protect
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00038073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;				
		
		@SPISELECT_SECTOR2();
		// Program Sector2 Password Protect
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00034073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;	
		
		@SPISELECT_SECTOR0();
		// Program Sector0 Password Protect
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00030073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;				
				
	}
}
function I2CFLASH_CFG_PROGRAM_FULL 
{
	print (0,"Programming CFG");
	! Programming CFG;
	! Select CFG;
	@I2CSELECT_CFG();
	! Check Password Protect;
	@I2CCHECK_CFG_PASSWORD();
	! Erase the CFG;
	@I2CCFG_ERASE();
	! Program CFG;
	@I2CCFG_PROGRAM_FULL();	 
	! Verify CFG;	
	@I2CCFG_VERIFY_FULL();	
	! Program DONE bit;
	@I2CFLASHPROGRAM_DONE_BIT();   
	IF (PasswordEn == 1)
	{
		print (0,"Enable Password Protect...");
		! Enable Password Protect; 
		
		@I2CSELECT_SECTOR1();
		// Program Sector1 Password Protect
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00038073);
		I2C_STOP;
		RUN_TEST DELAY PWP;			
		
		@I2CSELECT_SECTOR2();
		// Program Sector2 Password Protect
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00034073);
		I2C_STOP;
		RUN_TEST DELAY PWP;	
		
		@I2CSELECT_SECTOR0();
		// Program Sector0 Password Protect
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00030073);
		I2C_STOP;
		RUN_TEST DELAY PWP;				
	}	
}
function I2CFLASH_CFG_PROGRAM 
{
	print (0,"Programming CFG");
	! Programming CFG;
	! Select CFG;
	@I2CSELECT_CFG();
	! Check Password Protect;
	@I2CCHECK_CFG_PASSWORD();
	! Erase the CFG;
	@I2CCFG_ERASE();
	! Program CFG;
	@I2CCFG_PROGRAM();	 
	! Verify CFG;	
	@I2CCFG_VERIFY();
	! Program DONE bit;
	@I2CFLASHPROGRAM_DONE_BIT();	   
	IF (PasswordEn == 1)
	{
		print (0,"Enable Password Protect...");
		! Enable Password Protect; 		
		
		@I2CSELECT_SECTOR1();
		// Program Sector1 Password Protect
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00038073);
		I2C_STOP;
		RUN_TEST DELAY PWP;	
		
		@I2CSELECT_SECTOR2();
		// Program Sector2 Password Protect
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00034073);
		I2C_STOP;
		RUN_TEST DELAY PWP;	
		
		@I2CSELECT_SECTOR0();
		// Program Sector0 Password Protect
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x00030073);
		I2C_STOP;
		RUN_TEST DELAY PWP;				
	}	
}
function JTAGI2CFLASH_CFG_PROGRAM_FULL
{
	print (0,"Programming CFG");
	! Select CFG;
	@JTAGI2CSELECT_CFG();
	! Check Password Protect;
	@JTAGI2CCHECK_CFG_PASSWORD();
	! Erase the CFG;
	@JTAGI2CCFG_ERASE();
	! Program CFG;
	@JTAGI2CCFG_PROGRAM_FULL();	 
	! Verify CFG;	
	@JTAGI2CCFG_VERIFY_FULL();	   
	! Program DONE bit;
	@JTAGI2CFLASHPROGRAM_DONE_BIT();
	IF (PasswordEn == 1)
	{
		print (0,"Enable Password Protect...");
		! Enable Password Protect; 
		
		@JTAGI2CSELECT_SECTOR1();
		// Program Sector1 Password Protect
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1001);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;
		
		@JTAGI2CSELECT_SECTOR2();
		// Program Sector2 Password Protect
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1002);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;
		
		@JTAGI2CSELECT_SECTOR0();
		// Program Sector0 Password Protect	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;
	}	
}
function JTAGI2CFLASH_CFG_PROGRAM 
{
	print (0,"Programming CFG");
	! Select CFG;
	@JTAGI2CSELECT_CFG();
	! Check Password Protect;
	@JTAGI2CCHECK_CFG_PASSWORD();
	! Erase the CFG;
	@JTAGI2CCFG_ERASE();
	! Program CFG;
	@JTAGI2CCFG_PROGRAM();	 
	! Verify CFG;	
	@JTAGI2CCFG_VERIFY();
	! Program DONE bit;
	@JTAGI2CFLASHPROGRAM_DONE_BIT();	   
	IF (PasswordEn == 1)
	{
		print (0,"Enable Password Protect...");
		! Enable Password Protect; 	
		@JTAGI2CSELECT_SECTOR1();
		// Program Sector1 Password Protect
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1001);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;
		
		@JTAGI2CSELECT_SECTOR2();
		// Program Sector2 Password Protect
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1002);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;
		
		@JTAGI2CSELECT_SECTOR0();
		// Program Sector0 Password Protect	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;
	}	
}
//////////////////////////////////////////////////////////////////////
function SPIFLASH_UFM_PROGRAM_FULL
{
	print (0,"Programming UFM");
	! Programming UFM;
	! Select UFM;
	@SPISELECT_UFM();
	! Check Password Protect;
	@SPICHECK_UFM_PASSWORD();
	! Erase UFM;
	@SPIUFM_ERASE(); 
	! Program UFM;
	@SPIUFM_PROGRAM_FULL(); 
	! Verify UFM;													
	@SPIUFM_VERIFY_FULL();  
	@SPIUFMPROGRAM_DONE_BIT();	
	IF (PasswordEn == 1)
	{
		print (0,"Enable Password Protect...");
		! Enable Password Protect; 
		@SPISELECT_UFM();
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x0003C073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;				
	} 
}
function SPIFLASH_UFM_PROGRAM 
{
	print (0,"Programming UFM");
	! Programming UFM;
	! Select UFM;
	@SPISELECT_UFM();
	! Check Password Protect;
	@SPICHECK_UFM_PASSWORD();
	! Erase UFM;
	@SPIUFM_ERASE(); 
	! Program UFM;
	@SPIUFM_PROGRAM(); 
	! Verify UFM;													
	@SPIUFM_VERIFY();  
	@SPIUFMPROGRAM_DONE_BIT();	
	IF (PasswordEn == 1)
	{
		print (0,"Enable Password Protect...");
		! Enable Password Protect; 
		@SPISELECT_UFM();
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x0003C073);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;				
	} 
}
function I2CFLASH_UFM_PROGRAM_FULL 
{
	print (0,"Programming UFM");
	! Programming UFM;
	! Select UFM;
	@I2CSELECT_UFM();
	! Check Password Protect;
	@I2CCHECK_UFM_PASSWORD();
	! Erase UFM;
	@I2CUFM_ERASE(); 
	! Program UFM;
	@I2CUFM_PROGRAM_FULL(); 
	! Verify UFM;													
	@I2CUFM_VERIFY_FULL();  
	@I2CUFMPROGRAM_DONE_BIT();	
	IF (PasswordEn == 1)
	{
		print (0,"Enable Password Protect...");
		! Enable Password Protect; 
		@I2CSELECT_UFM();
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x0003C073);
		I2C_STOP;
		RUN_TEST DELAY PWP;				
	}  
}
function I2CFLASH_UFM_PROGRAM 
{
	print (0,"Programming UFM");
	! Programming UFM;
	! Select UFM;
	@I2CSELECT_UFM();
	! Check Password Protect;
	@I2CCHECK_UFM_PASSWORD();
	! Erase UFM;
	@I2CUFM_ERASE(); 
	! Program UFM;
	@I2CUFM_PROGRAM(); 
	! Verify UFM;													
	@I2CUFM_VERIFY();  
	@I2CUFMPROGRAM_DONE_BIT();	
	IF (PasswordEn == 1)
	{
		print (0,"Enable Password Protect...");
		! Enable Password Protect; 
		@I2CSELECT_UFM();
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (0x0003C073);
		I2C_STOP;
		RUN_TEST DELAY PWP;				
	}  
}
function JTAGI2CFLASH_UFM_PROGRAM_FULL 
{
	print (0,"Programming UFM");
	! Select UFM;
	@JTAGI2CSELECT_UFM();
	! Check Password Protect;
	@JTAGI2CCHECK_UFM_PASSWORD();
	! Erase UFM;
	@JTAGI2CUFM_ERASE(); 
	! Program UFM;
	@JTAGI2CUFM_PROGRAM_FULL(); 
	! Verify UFM;													
	@JTAGI2CUFM_VERIFY_FULL();  
	@JTAGI2CUFMPROGRAM_DONE_BIT();	   
	IF (PasswordEn == 1)
	{
		print (0,"Enable Password Protect...");
		! Enable Password Protect; 
		@JTAGI2CSELECT_UFM();
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1003);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;			
	} 
}
function JTAGI2CFLASH_UFM_PROGRAM 
{
	print (0,"Programming UFM");
	! Select UFM;
	@JTAGI2CSELECT_UFM();
	! Check Password Protect;
	@JTAGI2CCHECK_UFM_PASSWORD();
	! Erase UFM;
	@JTAGI2CUFM_ERASE(); 
	! Program UFM;
	@JTAGI2CUFM_PROGRAM(); 
	! Verify UFM;													
	@JTAGI2CUFM_VERIFY();  
	@JTAGI2CUFMPROGRAM_DONE_BIT();	   
	IF (PasswordEn == 1)
	{
		print (0,"Enable Password Protect...");
		! Enable Password Protect; 
		@JTAGI2CSELECT_UFM();
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1003);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10C0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;			
	} 
}
////////////////////////////////////////////////////////////////////////////////////////
function SPIPROGRAM_TRACEID {
	datastream FeatureArray[1][64];
	IF (Config_Register_TDI.row = 1)
	{
		FeatureArray[1] = Config_Register_TDI[1] @ (#0^56);
		FeatureArray[1]	= $FeatureArray[1];	
		setpin ISPEN LOW;
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SDR 32	TDI (0x00000027);
	    SDR 64 TDI(FeatureArray[1]);
	    setpin ISPEN HIGH;	
	    loop PWP {
	    	setpin ISPEN HIGH;	
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
			setpin ISPEN HIGH;			
		}
		setpin ISPEN HIGH;	 
		TRY 1 {
			setpin ISPEN LOW;
			setpin ISPEN LOW; 
			! Shift in LSC_READ_FEATURE (0xE7) instruction;
			SDR 32	TDI (0x000000E7);
			SDR_VERIFY 64   TDI(#0^64)
							TDO(FeatureArray[1])
							MASK(0x00000000000000FF);					  						  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1,"Failed to Program TraceID.");
		}
	    setpin ISPEN HIGH;	
	}
}
function I2CPROGRAM_TRACEID {
	datastream FeatureArray[1][64];
	IF (Config_Register_TDI.row = 1)
	{
		FeatureArray[1] = Config_Register_TDI[1] @ (#0^56);
		FeatureArray[1]	= $FeatureArray[1];
	    I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SDR 32	TDI (0x00000027);
	    SDR 64 TDI(FeatureArray[1]);
	    loop PWP {
	    	I2C_STOP;
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
		    I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 8 TDI(0x00) TDO(0x00) MASK(0x01);
		}	
		I2C_STOP; 	
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_FEATURE (0xE7) instruction;
			SDR 32	TDI (0x000000E7);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 64   TDI(#0^64)
							TDO(FeatureArray[1])
							MASK(0x00000000000000FF);	
			I2C_STOP;							
		}
		ELSE {		  
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	32 	TDI (0x00000064);
			I2C_STOP;
			print (1,"Failed to Program TraceID.");
		}
	}
}
function JTAGI2CPROGRAM_TRACEID {
	datastream DataByte[1][8];
	datastream FeatureArray[1][64];
	IF (Config_Register_TDI.row = 1)
	{
		FeatureArray[1] = Config_Register_TDI[1] @ (#0^56);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
    	SDR	16	TDI (0x10E4);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
    	DataByte[1] = FeatureArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (FeatureArray[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		
		loop PWP {
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR	16	TDI (0x10F0);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x80);
		}				
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;		
	} 	
}
function SPISAVE_TRACEID {
	datastream SavedUID[1][64];
	file	NewFile = "FILE_SAVE"; 
	setpin ISPEN LOW;
	! Shift in LSC_UIDCODE_PUB(0x19) instruction;
    SDR	32	TDI (0x00000098);
	SDR	64	TDI (#0^64)
			TDO	(SavedUID);
	setpin ISPEN HIGH;
	SavedUID[1] = $SavedUID[1];
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedUID);
	fclose 	NewFile;
}
function I2CSAVE_TRACEID {
	datastream SavedUID[1][64];
	file	NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_UIDCODE_PUB(0x19) instruction;
    SDR 32 	TDI (0x00000098);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	64	TDI (#0^64)
			TDO	(SavedUID);
	I2C_STOP;
	SavedUID[1] = $SavedUID[1];	
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedUID);
	fclose 	NewFile;
}
function JTAGI2CSAVE_TRACEID {
	datastream SavedUID[1][64];
	datastream DataByte[1][8];
	file	NewFile = "FILE_SAVE";
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in UIDCODE_PUB(0x19) opcode;
	SDR	16	TDI (0x1019);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUID[1] = ((SavedUID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUID[1] = ((SavedUID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUID[1] = ((SavedUID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUID[1] = ((SavedUID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUID[1] = ((SavedUID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUID[1] = ((SavedUID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUID[1] = ((SavedUID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedUID[1] = ((SavedUID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedUID);
	fclose 	NewFile;	
}
/////////////////////////////////////////////////////////////////////////////////////////
function SPICFG_PROGRAM_SECURITY {
	//ISC_PROGRAM_SECURITY operand is as below
	//Bit[18:16] Flash Sector Address
	//Bit[15:14] 11 to Enable Password Protection
	//Bit[13:10] 1001 to Enable Erase Security
	//Bit[9] 1 to Enable Write Security
	//Bit[8] 1 to Enable Read Security
	

	datastream LockBitsArray[1][24];
	datastream CommandAndOperand[1][32];
	datastream TempTDO[1][32];
	datastream TempMask[1][32];	
	
	LockBitsArray[1] = 0x000000;
	// Lock SEC_READ_L
	IF (CFG0_ISSECURED == 1)
	{
		LockBitsArray[1] = 0x000100;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000800;
    }
    // Lock SEC_PROG_L
	ELSEIF (CFG0_ISSECURED == 2)
	{
		LockBitsArray[1] = 0x000200;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000400;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CFG0_ISSECURED == 3)
	{
		LockBitsArray[1] = 0x000300;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000C00;
	}
	// Lock SEC_ERASE_L
	ELSEIF (CFG0_ISSECURED == 4)
	{
		LockBitsArray[1] = 0x002400;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000040;
	}	
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (CFG0_ISSECURED == 5)
	{
		LockBitsArray[1] = 0x002500;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000840;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (CFG0_ISSECURED == 6)
	{
		LockBitsArray[1] = 0x002600;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000440;
	}
	// Lock SEC_PROG_L SEC_ERASE_L SEC_READ_L
	ELSEIF (CFG0_ISSECURED == 7)
	{
		LockBitsArray[1] = 0x002700;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000C40;
	}	
	IF (LockBitsArray[1] != 0x000000)
	{
	    TempTDO[1] = $TempTDO[1];
		TempMask[1] = $TempMask[1];
		
		//Add Sector 0 Address
		LockBitsArray[1] = LockBitsArray[1] | 0x000000;
		
		//Add command 
		CommandAndOperand[1] = (0x00 @ LockBitsArray[1]) | 0xCE000000;
		CommandAndOperand[1] = $CommandAndOperand[1]; 	
	
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (CommandAndOperand[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;
		
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
							TDO(TempTDO[1])
							MASK(TempMask[1]);
		setpin ISPEN HIGH;
	
		//Add Sector 1 Address
		LockBitsArray[1] = LockBitsArray[1] | 0x010000;
		
		//Add command 
		CommandAndOperand[1] = (0x00 @ LockBitsArray[1]) | 0xCE000000;
		CommandAndOperand[1] = $CommandAndOperand[1]; 	
	
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (CommandAndOperand[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;
		
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
							TDO(TempTDO[1])
							MASK(TempMask[1]);
		setpin ISPEN HIGH;
	
		//Reset previous set sector 1 address
		LockBitsArray[1] = LockBitsArray[1] & 0xFEFFFF;
		//Add sector 2 address
		LockBitsArray[1] = LockBitsArray[1] | 0x020000;
		
		//Add command 
		CommandAndOperand[1] = (0x00 @ LockBitsArray[1]) | 0xCE000000;
		CommandAndOperand[1] = $CommandAndOperand[1]; 	
	
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (CommandAndOperand[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;
		
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
							TDO(TempTDO[1])
							MASK(TempMask[1]);
		setpin ISPEN HIGH;
	}			
}
function I2CCFG_PROGRAM_SECURITY 
{
	//ISC_PROGRAM_SECURITY operand is as below
	//Bit[18:16] Flash Sector Address
	//Bit[15:14] 11 to Enable Password Protection
	//Bit[13:10] 1001 to Enable Erase Security
	//Bit[9] 1 to Enable Write Security
	//Bit[8] 1 to Enable Read Security

	datastream LockBitsArray[1][24];
	datastream CommandAndOperand[1][32];
	datastream TempTDO[1][32];
	datastream TempMask[1][32];	
	
	LockBitsArray[1] = 0x000000;
	// Lock SEC_READ_L
	IF (CFG0_ISSECURED == 1)
	{
		LockBitsArray[1] = 0x000100;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000800;
    }
    // Lock SEC_PROG_L
	ELSEIF (CFG0_ISSECURED == 2)
	{
		LockBitsArray[1] = 0x000200;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000400;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CFG0_ISSECURED == 3)
	{
		LockBitsArray[1] = 0x000300;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000C00;
	}
	// Lock SEC_ERASE_L
	ELSEIF (CFG0_ISSECURED == 4)
	{
		LockBitsArray[1] = 0x002400;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000040;
	}	
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (CFG0_ISSECURED == 5)
	{
		LockBitsArray[1] = 0x002500;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000840;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (CFG0_ISSECURED == 6)
	{
		LockBitsArray[1] = 0x002600;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000440;
	}
	// Lock SEC_PROG_L SEC_ERASE_L SEC_READ_L
	ELSEIF (CFG0_ISSECURED == 7)
	{
		LockBitsArray[1] = 0x002700;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000C40;
	}
	IF (LockBitsArray[1] != 0x000000)
	{	
	    TempTDO[1] = $TempTDO[1];
		TempMask[1] = $TempMask[1];
		
		//Add Sector 0 Address
		LockBitsArray[1] = LockBitsArray[1] | 0x000000;
		
		//Add command 
		CommandAndOperand[1] = (0x00 @ LockBitsArray[1]) | 0xCE000000;
		CommandAndOperand[1] = $CommandAndOperand[1]; 	
	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (CommandAndOperand[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;
		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(TempTDO[1])
						MASK(TempMask[1]);
		I2C_STOP;
	
		//Add Sector 1 Address
		LockBitsArray[1] = LockBitsArray[1] | 0x010000;
		
		//Add command 
		CommandAndOperand[1] = (0x00 @ LockBitsArray[1]) | 0xCE000000;
		CommandAndOperand[1] = $CommandAndOperand[1]; 	
	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (CommandAndOperand[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;
		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(TempTDO[1])
						MASK(TempMask[1]);
		I2C_STOP;
	
		//Reset previous set sector 1 address
		LockBitsArray[1] = LockBitsArray[1] & 0xFEFFFF;
		//Add sector 2 address
		LockBitsArray[1] = LockBitsArray[1] | 0x020000;
		
		//Add command 
		CommandAndOperand[1] = (0x00 @ LockBitsArray[1]) | 0xCE000000;
		CommandAndOperand[1] = $CommandAndOperand[1]; 	
	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (CommandAndOperand[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;
		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(TempTDO[1])
						MASK(TempMask[1]);
		I2C_STOP;
	}		
}
function JTAGI2CCFG_PROGRAM_SECURITY {
	//ISC_PROGRAM_SECURITY operand is as below
	//Bit[18:16] Flash Sector Address
	//Bit[15:14] 11 to Enable Password Protection
	//Bit[13:10] 1001 to Enable Erase Security
	//Bit[9] 1 to Enable Write Security
	//Bit[8] 1 to Enable Read Security

	datastream LockBitsArray[1][24];
	datastream TempTDO[1][32];
	datastream TempMask[1][32];	
	datastream DataByte[1][8];
	datastream DataByteTDO[1][8];
	datastream DataByteMask[1][8];
	
	LockBitsArray[1] = 0x000000;
	// Lock SEC_READ_L
	IF (CFG0_ISSECURED == 1)
	{
		LockBitsArray[1] = 0x000100;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000800;
    }
    // Lock SEC_PROG_L
	ELSEIF (CFG0_ISSECURED == 2)
	{
		LockBitsArray[1] = 0x000200;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000400;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CFG0_ISSECURED == 3)
	{
		LockBitsArray[1] = 0x000300;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000C00;
	}
	// Lock SEC_ERASE_L
	ELSEIF (CFG0_ISSECURED == 4)
	{
		LockBitsArray[1] = 0x002400;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000040;
	}	
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (CFG0_ISSECURED == 5)
	{
		LockBitsArray[1] = 0x002500;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000840;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (CFG0_ISSECURED == 6)
	{
		LockBitsArray[1] = 0x002600;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000440;
	}
	// Lock SEC_PROG_L SEC_ERASE_L SEC_READ_L
	ELSEIF (CFG0_ISSECURED == 7)
	{
		LockBitsArray[1] = 0x002700;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000C40;
	}
	IF (LockBitsArray[1] != 0x000000)
	{		
		//Add Sector 0 Address
		LockBitsArray[1] = LockBitsArray[1] | 0x000000;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		DataByte[1] = LockBitsArray[1] ;
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10 @ DataByte[1]);
		DataByte[1] = LockBitsArray[1] << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10 @ DataByte[1]);
		DataByte[1] = LockBitsArray[1] << 16;
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10 @ DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		DataByteTDO[1] = TempTDO[1];
		DataByteMask[1] = TempMask[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		DataByteTDO[1] = (TempTDO[1] << 8);
		DataByteMask[1] = (TempMask[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		DataByteTDO[1] = (TempTDO[1] << 16);
		DataByteMask[1] = (TempMask[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		DataByteTDO[1] = (TempTDO[1] << 24);
		DataByteMask[1] = (TempMask[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	
		//Add Sector 1 Address
		LockBitsArray[1] = LockBitsArray[1] | 0x010000;
		
	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		DataByte[1] = LockBitsArray[1] ;
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10 @ DataByte[1]);
		DataByte[1] = LockBitsArray[1] << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10 @ DataByte[1]);
		DataByte[1] = LockBitsArray[1] << 16;
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10 @ DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		DataByteTDO[1] = TempTDO[1];
		DataByteMask[1] = TempMask[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		DataByteTDO[1] = (TempTDO[1] << 8);
		DataByteMask[1] = (TempMask[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		DataByteTDO[1] = (TempTDO[1] << 16);
		DataByteMask[1] = (TempMask[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		DataByteTDO[1] = (TempTDO[1] << 24);
		DataByteMask[1] = (TempMask[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	
		//Reset previous set sector 1 address
		LockBitsArray[1] = LockBitsArray[1] & 0xFEFFFF;
		//Add sector 2 address
		LockBitsArray[1] = LockBitsArray[1] | 0x020000;
		
	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		DataByte[1] = LockBitsArray[1] ;
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10 @ DataByte[1]);
		DataByte[1] = LockBitsArray[1] << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10 @ DataByte[1]);
		DataByte[1] = LockBitsArray[1] << 16;
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10 @ DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		DataByteTDO[1] = TempTDO[1];
		DataByteMask[1] = TempMask[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		DataByteTDO[1] = (TempTDO[1] << 8);
		DataByteMask[1] = (TempMask[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		DataByteTDO[1] = (TempTDO[1] << 16);
		DataByteMask[1] = (TempMask[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		DataByteTDO[1] = (TempTDO[1] << 24);
		DataByteMask[1] = (TempMask[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}		
}
/////////////////////////////////////////////////////////////////////////////////////////
function SPIUFM_PROGRAM_SECURITY {
	//ISC_PROGRAM_SECURITY operand is as below
	//Bit[18:16] Flash Sector Address
	//Bit[15:14] 11 to Enable Password Protection
	//Bit[13:10] 1001 to Enable Erase Security
	//Bit[9] 1 to Enable Write Security
	//Bit[8] 1 to Enable Read Security
	

	datastream LockBitsArray[1][24];
	datastream CommandAndOperand[1][32];
	datastream TempTDO[1][32];
	datastream TempMask[1][32];	
	
	LockBitsArray[1] = 0x000000;
	// Lock SEC_READ_L
	IF (UFM0_ISSECURED == 1)
	{
		LockBitsArray[1] = 0x000100;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000800;
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM0_ISSECURED == 2)
	{
		LockBitsArray[1] = 0x000200;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000400;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM0_ISSECURED == 3)
	{
		LockBitsArray[1] = 0x000300;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000C00;
	}
	// Lock SEC_ERASE_L
	ELSEIF (UFM0_ISSECURED == 4)
	{
		LockBitsArray[1] = 0x002400;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000040;
	}	
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (UFM0_ISSECURED == 5)
	{
		LockBitsArray[1] = 0x002500;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000840;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (UFM0_ISSECURED == 6)
	{
		LockBitsArray[1] = 0x002600;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000440;
	}
	// Lock SEC_PROG_L SEC_ERASE_L SEC_READ_L
	ELSEIF (UFM0_ISSECURED == 7)
	{
		LockBitsArray[1] = 0x002700;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000C40;
	}	
	IF (LockBitsArray[1] != 0x000000)
	{
	    TempTDO[1] = $TempTDO[1];
		TempMask[1] = $TempMask[1];
		
		//Add Sector 3 Address
		LockBitsArray[1] = LockBitsArray[1] | 0x030000;
		
		//Add command 
		CommandAndOperand[1] = (0x00 @ LockBitsArray[1]) | 0xCE000000;
		CommandAndOperand[1] = $CommandAndOperand[1]; 	
	
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (CommandAndOperand[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;
		
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
							TDO(TempTDO[1])
							MASK(TempMask[1]);
		setpin ISPEN HIGH;
	}		
}
function I2CUFM_PROGRAM_SECURITY {
	//ISC_PROGRAM_SECURITY operand is as below
	//Bit[18:16] Flash Sector Address
	//Bit[15:14] 11 to Enable Password Protection
	//Bit[13:10] 1001 to Enable Erase Security
	//Bit[9] 1 to Enable Write Security
	//Bit[8] 1 to Enable Read Security

	datastream LockBitsArray[1][24];
	datastream CommandAndOperand[1][32];
	datastream TempTDO[1][32];
	datastream TempMask[1][32];	
	
	LockBitsArray[1] = 0x000000;
	// Lock SEC_READ_L
	IF (UFM0_ISSECURED == 1)
	{
		LockBitsArray[1] = 0x000100;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000800;
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM0_ISSECURED == 2)
	{
		LockBitsArray[1] = 0x000200;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000400;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM0_ISSECURED == 3)
	{
		LockBitsArray[1] = 0x000300;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000C00;
	}
	// Lock SEC_ERASE_L
	ELSEIF (UFM0_ISSECURED == 4)
	{
		LockBitsArray[1] = 0x002400;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000040;
	}	
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (UFM0_ISSECURED == 5)
	{
		LockBitsArray[1] = 0x002500;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000840;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (UFM0_ISSECURED == 6)
	{
		LockBitsArray[1] = 0x002600;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000440;
	}
	// Lock SEC_PROG_L SEC_ERASE_L SEC_READ_L
	ELSEIF (UFM0_ISSECURED == 7)
	{
		LockBitsArray[1] = 0x002700;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000C40;
	}	
	IF (LockBitsArray[1] != 0x000000)
	{
	    TempTDO[1] = $TempTDO[1];
		TempMask[1] = $TempMask[1];
		
		//Add Sector 3 Address
		LockBitsArray[1] = LockBitsArray[1] | 0x030000;
		
		//Add command 
		CommandAndOperand[1] = (0x00 @ LockBitsArray[1]) | 0xCE000000;
		CommandAndOperand[1] = $CommandAndOperand[1]; 	
	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (CommandAndOperand[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;
		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(TempTDO[1])
						MASK(TempMask[1]);
		I2C_STOP;
	}		
}
function JTAGI2CUFM_PROGRAM_SECURITY {
	//ISC_PROGRAM_SECURITY operand is as below
	//Bit[18:16] Flash Sector Address
	//Bit[15:14] 11 to Enable Password Protection
	//Bit[13:10] 1001 to Enable Erase Security
	//Bit[9] 1 to Enable Write Security
	//Bit[8] 1 to Enable Read Security

	datastream LockBitsArray[1][24];
	datastream TempTDO[1][32];
	datastream TempMask[1][32];	
	datastream DataByte[1][8];
	datastream DataByteTDO[1][8];
	datastream DataByteMask[1][8];
	
	LockBitsArray[1] = 0x000000;
	// Lock SEC_READ_L
	IF (UFM0_ISSECURED == 1)
	{
		LockBitsArray[1] = 0x000100;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000800;
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM0_ISSECURED == 2)
	{
		LockBitsArray[1] = 0x000200;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000400;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM0_ISSECURED == 3)
	{
		LockBitsArray[1] = 0x000300;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000C00;
	}
	// Lock SEC_ERASE_L
	ELSEIF (UFM0_ISSECURED == 4)
	{
		LockBitsArray[1] = 0x002400;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000040;
	}	
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (UFM0_ISSECURED == 5)
	{
		LockBitsArray[1] = 0x002500;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000840;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (UFM0_ISSECURED == 6)
	{
		LockBitsArray[1] = 0x002600;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000440;
	}
	// Lock SEC_PROG_L SEC_ERASE_L SEC_READ_L
	ELSEIF (UFM0_ISSECURED == 7)
	{
		LockBitsArray[1] = 0x002700;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000C40;
	}	
	IF (LockBitsArray[1] != 0x000000)
	{
		//Add Sector 0 Address
		LockBitsArray[1] = LockBitsArray[1] | 0x030000;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		DataByte[1] = LockBitsArray[1] ;
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10 @ DataByte[1]);
		DataByte[1] = LockBitsArray[1] << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10 @ DataByte[1]);
		DataByte[1] = LockBitsArray[1] << 16;
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10 @ DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		DataByteTDO[1] = TempTDO[1];
		DataByteMask[1] = TempMask[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		DataByteTDO[1] = (TempTDO[1] << 8);
		DataByteMask[1] = (TempMask[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		DataByteTDO[1] = (TempTDO[1] << 16);
		DataByteMask[1] = (TempMask[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		DataByteTDO[1] = (TempTDO[1] << 24);
		DataByteMask[1] = (TempMask[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}		
}
/////////////////////////////////////////////////////////////////////////////////////////
function SPIFEA_PROGRAM_SECURITY {
	//ISC_PROGRAM_SECURITY operand is as below
	//Bit[18:16] Flash Sector Address
	//Bit[15:14] 11 to Enable Password Protection
	//Bit[13:10] 1001 to Enable Erase Security
	//Bit[9] 1 to Enable Write Security
	//Bit[8] 1 to Enable Read Security
	

	datastream LockBitsArray[1][24];
	datastream CommandAndOperand[1][32];
	datastream TempTDO[1][32];
	datastream TempMask[1][32];	
	
	LockBitsArray[1] = 0x000000;
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = 0x000100;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000800;
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = 0x000200;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000400;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = 0x000300;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000C00;
	}
	// Lock SEC_ERASE_L
	ELSEIF (ISSECURED == 4)
	{
		LockBitsArray[1] = 0x002400;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000040;
	}	
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (ISSECURED == 5)
	{
		LockBitsArray[1] = 0x002500;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000840;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (ISSECURED == 6)
	{
		LockBitsArray[1] = 0x002600;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000440;
	}
	// Lock SEC_PROG_L SEC_ERASE_L SEC_READ_L
	ELSEIF (ISSECURED == 7)
	{
		LockBitsArray[1] = 0x002700;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000C40;
	}	
	IF (LockBitsArray[1] != 0x000000)
	{
	    TempTDO[1] = $TempTDO[1];
		TempMask[1] = $TempMask[1];
		
		//Add Sector 0 Address
		LockBitsArray[1] = LockBitsArray[1] | 0x040000;
		
		//Add command 
		CommandAndOperand[1] = (0x00 @ LockBitsArray[1]) | 0xCE000000;
		CommandAndOperand[1] = $CommandAndOperand[1]; 	
	
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (CommandAndOperand[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;
		
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
							TDO(TempTDO[1])
							MASK(TempMask[1]);
		setpin ISPEN HIGH;
	}		
}
function I2CFEA_PROGRAM_SECURITY {
	//ISC_PROGRAM_SECURITY operand is as below
	//Bit[18:16] Flash Sector Address
	//Bit[15:14] 11 to Enable Password Protection
	//Bit[13:10] 1001 to Enable Erase Security
	//Bit[9] 1 to Enable Write Security
	//Bit[8] 1 to Enable Read Security

	datastream LockBitsArray[1][24];
	datastream CommandAndOperand[1][32];
	datastream TempTDO[1][32];
	datastream TempMask[1][32];	
	
	LockBitsArray[1] = 0x000000;
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = 0x000100;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000800;
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = 0x000200;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000400;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = 0x000300;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000C00;
	}
	// Lock SEC_ERASE_L
	ELSEIF (ISSECURED == 4)
	{
		LockBitsArray[1] = 0x002400;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000040;
	}	
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (ISSECURED == 5)
	{
		LockBitsArray[1] = 0x002500;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000840;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (ISSECURED == 6)
	{
		LockBitsArray[1] = 0x002600;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000440;
	}
	// Lock SEC_PROG_L SEC_ERASE_L SEC_READ_L
	ELSEIF (ISSECURED == 7)
	{
		LockBitsArray[1] = 0x002700;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000C40;
	}
	IF (LockBitsArray[1] != 0x000000)
	{	
	    TempTDO[1] = $TempTDO[1];
		TempMask[1] = $TempMask[1];
		
		//Add Sector 0 Address
		LockBitsArray[1] = LockBitsArray[1] | 0x040000;
		
		//Add command 
		CommandAndOperand[1] = (0x00 @ LockBitsArray[1]) | 0xCE000000;
		CommandAndOperand[1] = $CommandAndOperand[1]; 	
	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (CommandAndOperand[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;
		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(TempTDO[1])
						MASK(TempMask[1]);
		I2C_STOP;
	}		
}
function I2CFEA_PROGRAM_SECURITY_NEW_ADDR {
	//ISC_PROGRAM_SECURITY operand is as below
	//Bit[18:16] Flash Sector Address
	//Bit[15:14] 11 to Enable Password Protection
	//Bit[13:10] 1001 to Enable Erase Security
	//Bit[9] 1 to Enable Write Security
	//Bit[8] 1 to Enable Read Security

	datastream LockBitsArray[1][24];
	datastream CommandAndOperand[1][32];
	datastream TempTDO[1][32];
	datastream TempMask[1][32];		
	
	datastream JTAGI2CN_WRITE[1][8];
	datastream JTAGI2CN_READ[1][8];
	JTAGI2CN_WRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	JTAGI2CN_READ[1] = (NEW_I2C_ADDR_READ);
	
	LockBitsArray[1] = 0x000000;
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = 0x000100;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000800;
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = 0x000200;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000400;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = 0x000300;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000C00;
	}
	// Lock SEC_ERASE_L
	ELSEIF (ISSECURED == 4)
	{
		LockBitsArray[1] = 0x002400;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000040;
	}	
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (ISSECURED == 5)
	{
		LockBitsArray[1] = 0x002500;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000840;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (ISSECURED == 6)
	{
		LockBitsArray[1] = 0x002600;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000440;
	}
	// Lock SEC_PROG_L SEC_ERASE_L SEC_READ_L
	ELSEIF (ISSECURED == 7)
	{
		LockBitsArray[1] = 0x002700;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000C40;
	}
	IF (LockBitsArray[1] != 0x000000)
	{	
	    TempTDO[1] = $TempTDO[1];
		TempMask[1] = $TempMask[1];
		
		//Add Sector 0 Address
		LockBitsArray[1] = LockBitsArray[1] | 0x040000;
		
		//Add command 
		CommandAndOperand[1] = (0x00 @ LockBitsArray[1]) | 0xCE000000;
		CommandAndOperand[1] = $CommandAndOperand[1]; 	
	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (JTAGI2CN_WRITE[1]);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
		SDR 32	TDI (CommandAndOperand[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;
		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (JTAGI2CN_WRITE[1]);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (JTAGI2CN_READ[1]);
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(TempTDO[1])
						MASK(TempMask[1]);
		I2C_STOP;
	}		
}
function JTAGI2CFEA_PROGRAM_SECURITY {
	//ISC_PROGRAM_SECURITY operand is as below
	//Bit[18:16] Flash Sector Address
	//Bit[15:14] 11 to Enable Password Protection
	//Bit[13:10] 1001 to Enable Erase Security
	//Bit[9] 1 to Enable Write Security
	//Bit[8] 1 to Enable Read Security

	datastream LockBitsArray[1][24];
	datastream TempTDO[1][32];
	datastream TempMask[1][32];	
	datastream DataByte[1][8];
	datastream DataByteTDO[1][8];
	datastream DataByteMask[1][8];
	
	LockBitsArray[1] = 0x000000;
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = 0x000100;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000800;
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = 0x000200;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000400;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = 0x000300;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000C00;
	}
	// Lock SEC_ERASE_L
	ELSEIF (ISSECURED == 4)
	{
		LockBitsArray[1] = 0x002400;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000040;
	}	
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (ISSECURED == 5)
	{
		LockBitsArray[1] = 0x002500;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000840;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (ISSECURED == 6)
	{
		LockBitsArray[1] = 0x002600;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000440;
	}
	// Lock SEC_PROG_L SEC_ERASE_L SEC_READ_L
	ELSEIF (ISSECURED == 7)
	{
		LockBitsArray[1] = 0x002700;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000C40;
	}	
	IF (LockBitsArray[1] != 0x000000)
	{
		//Add Sector 0 Address
		LockBitsArray[1] = LockBitsArray[1] | 0x040000;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		DataByte[1] = LockBitsArray[1] ;
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10 @ DataByte[1]);
		DataByte[1] = LockBitsArray[1] << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10 @ DataByte[1]);
		DataByte[1] = LockBitsArray[1] << 16;
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10 @ DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		DataByteTDO[1] = TempTDO[1];
		DataByteMask[1] = TempMask[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		DataByteTDO[1] = (TempTDO[1] << 8);
		DataByteMask[1] = (TempMask[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		DataByteTDO[1] = (TempTDO[1] << 16);
		DataByteMask[1] = (TempMask[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		DataByteTDO[1] = (TempTDO[1] << 24);
		DataByteMask[1] = (TempMask[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}		
}
function JTAGI2CFEA_PROGRAM_SECURITY_NEW_ADDR {
	//ISC_PROGRAM_SECURITY operand is as below
	//Bit[18:16] Flash Sector Address
	//Bit[15:14] 11 to Enable Password Protection
	//Bit[13:10] 1001 to Enable Erase Security
	//Bit[9] 1 to Enable Write Security
	//Bit[8] 1 to Enable Read Security

	datastream LockBitsArray[1][24];
	datastream TempTDO[1][32];
	datastream TempMask[1][32];	
	datastream DataByte[1][8];
	datastream DataByteTDO[1][8];
	datastream DataByteMask[1][8];
	
	datastream JTAGI2CN_WRITE[1][8];
	datastream JTAGI2CN_READ[1][8];
	JTAGI2CN_WRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	JTAGI2CN_WRITE[1] = $JTAGI2CN_WRITE[1];
	JTAGI2CN_READ[1] = (NEW_I2C_ADDR_READ ) ;
	JTAGI2CN_READ[1] = $JTAGI2CN_READ[1];
	
	LockBitsArray[1] = 0x000000;
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = 0x000100;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000800;
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = 0x000200;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000400;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = 0x000300;
		TempTDO[1] = 0x00000000;
		TempMask[1] = 0x00000C00;
	}
	// Lock SEC_ERASE_L
	ELSEIF (ISSECURED == 4)
	{
		LockBitsArray[1] = 0x002400;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000040;
	}	
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (ISSECURED == 5)
	{
		LockBitsArray[1] = 0x002500;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000840;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (ISSECURED == 6)
	{
		LockBitsArray[1] = 0x002600;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000440;
	}
	// Lock SEC_PROG_L SEC_ERASE_L SEC_READ_L
	ELSEIF (ISSECURED == 7)
	{
		LockBitsArray[1] = 0x002700;
		TempTDO[1] = 0x00000040;
		TempMask[1] = 0x00000C40;
	}	
	IF (LockBitsArray[1] != 0x000000)
	{
		//Add Sector 0 Address
		LockBitsArray[1] = LockBitsArray[1] | 0x040000;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ (JTAGI2CN_WRITE[1]));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		DataByte[1] = LockBitsArray[1] ;
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10 @ DataByte[1]);
		DataByte[1] = LockBitsArray[1] << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10 @ DataByte[1]);
		DataByte[1] = LockBitsArray[1] << 16;
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10 @ DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;				
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ (JTAGI2CN_WRITE[1]));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ (JTAGI2CN_READ[1]));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		DataByteTDO[1] = TempTDO[1];
		DataByteMask[1] = TempMask[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		DataByteTDO[1] = (TempTDO[1] << 8);
		DataByteMask[1] = (TempMask[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		DataByteTDO[1] = (TempTDO[1] << 16);
		DataByteMask[1] = (TempMask[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		DataByteTDO[1] = (TempTDO[1] << 24);
		DataByteMask[1] = (TempMask[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByteTDO[1])
						MASK (DataByteMask[1]);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}		
}
////////////////////////////////////////////////////////////////////////////
function SPICSEC_PROGRAM_LOCK
{
    datastream LockBitsArray[1][32];
    datastream TempTDO[1][32];
    datastream TempMask[1][32];
    datastream LockArray[1][16];
    datastream FinalLockBitsArray[1][24];
	IF (CSEC_Array_TDI.row = 1)
	{
		//print (0,CSEC_Array_TDI);
		LockBitsArray[1] = 0x00000000;
		TempTDO[1]  = 0x00000000;
		TempMask[1] = 0x00000000;
        LockArray[1] = CSEC_Array_TDI[1] & 0x0800;
        IF (LockArray[1] == 0x0800)
        {
            print (0,"Lock SRAM Write");
            ! Lock SRAM Write;
            LockBitsArray[1] = LockBitsArray[1] | 0x00000200;             
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000400;
        } 
        LockArray[1] = CSEC_Array_TDI[1] & 0x0400;
        IF (LockArray[1] == 0x0400)
        {              
            print (0,"Lock SRAM Read");
            ! Lock SRAM Read;
            LockBitsArray[1] = LockBitsArray[1] | 0x00000100;
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000800;                                                                                                                                           
        } 
        LockArray[1] = CSEC_Array_TDI[1] & 0x0200;
        IF (LockArray[1] == 0x0200)
        {
            print (0,"Lock SRAM Erase");
            ! Lock SRAM Erase;
            LockBitsArray[1] = LockBitsArray[1] | 0x00002400;
            TempTDO[1] = TempTDO[1] | 0x00000040;
            TempMask[1] = TempMask[1] | 0x00000040;
        }
        IF (LockBitsArray[1] != 0x00000000)
        {         
	        TempTDO[1] = $TempTDO[1];
	        TempMask[1] = $TempMask[1];         
	        //Add ISC_PROGRAM_SECURITY command
	        LockBitsArray[1] = 0xCE000000 | LockBitsArray[1];
	        LockBitsArray[1] = $LockBitsArray[1];        
	        @SPISRAM_ENABLE();        
	        setpin ISPEN LOW;
	        ! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	        SDR 32  TDI (LockBitsArray[1]);
	        setpin ISPEN HIGH;
	        RUN_TEST DELAY PWP;
	        TRY 1{
	            setpin ISPEN LOW;
	            ! Shift in LSC_READ_STATUS0(0x3C) instruction;
	            SDR 32 TDI (0x0000003C);
	            SDR_TRY_VERIFY  32   TDI(#0^32)
	                                 TDO(TempTDO[1])
	                                 MASK(TempMask[1]);
	            setpin ISPEN HIGH;            
	        }
	        ELSE
	        {
	            setpin ISPEN HIGH;
	            @SPIDISABLE();
	            print (1,"Failed to Lock SRAM. Cannot Continue.");
	        } 
	    }        
		LockBitsArray[1] = 0x00000000;
		TempTDO[1]  = 0x00000000;
		TempMask[1] = 0x00000000;
		LockArray[1] = CSEC_Array_TDI[1] & 0x0100;
		IF (LockArray[1] == 0x0100)
		{
			print (0,"Lock FEA Write.");
			! Lock FEA Write;
			LockBitsArray[1] = LockBitsArray[1] | 0x00040200;
			TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000400;			
		}
		LockArray[1] = CSEC_Array_TDI[1] & 0x0080;
		IF (LockArray[1] == 0x0080)
		{
			print (0,"Lock FEA Read.");
			! Lock FEA Read;
			LockBitsArray[1] = LockBitsArray[1] | 0x00040100;
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000800; 
		}
		LockArray[1] = CSEC_Array_TDI[1] & 0x0040;
		IF (LockArray[1] == 0x0040)
		{
			print (0,"Lock FEA Erase.");
			! Lock FEA Erase;
			LockBitsArray[1] = LockBitsArray[1] | 0x00042400;
            TempTDO[1] = TempTDO[1] | 0x00000040;
            TempMask[1] = TempMask[1] | 0x00000040;			
		}
		IF (LockBitsArray[1] != 0x00000000)
        {         
	        TempTDO[1] = $TempTDO[1];
	        TempMask[1] = $TempMask[1];         
	        //Add ISC_PROGRAM_SECURITY command
	        LockBitsArray[1] = 0xCE000000 | LockBitsArray[1];
	        LockBitsArray[1] = $LockBitsArray[1];        
	        @SPIFLASH_ENABLE();
			@SPISELECT_FEA();	
			@SPICHECK_PROGRAM_SECURITY();
	        setpin ISPEN LOW;
	        ! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	        SDR 32  TDI (LockBitsArray[1]);
	        setpin ISPEN HIGH;
	        RUN_TEST DELAY PWP;
	        TRY 1{
	            setpin ISPEN LOW;
	            ! Shift in LSC_READ_STATUS0(0x3C) instruction;
	            SDR 32 TDI (0x0000003C);
	            SDR_TRY_VERIFY  32   TDI(#0^32)
	                                 TDO(TempTDO[1])
	                                 MASK(TempMask[1]);
	            setpin ISPEN HIGH;            
	        }
	        ELSE
	        {
	            setpin ISPEN HIGH;
	            @SPIDISABLE();
	            print (1,"Failed to Lock Feature Row. Cannot Continue.");
	        } 
	    }  
	    LockBitsArray[1] = 0x00000000;
		TempTDO[1]  = 0x00000000;
		TempMask[1] = 0x00000000;
		LockArray[1] = CSEC_Array_TDI[1] & 0x0020;
		IF (LockArray[1] == 0x0020)
		{
			print (0,"Lock CFG Write.");
			! Lock CFG Write;
			LockBitsArray[1] = LockBitsArray[1] | 0x00000200;
			TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000400;	
        }
        LockArray[1] = CSEC_Array_TDI[1] & 0x0010;
		IF (LockArray[1] == 0x0010)
		{
			print (0,"Lock CFG Read.");
			! Lock CFG Read;
			LockBitsArray[1] = LockBitsArray[1] | 0x00000100;
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000800; 
        }
        LockArray[1] = CSEC_Array_TDI[1] & 0x0008;
		IF (LockArray[1] == 0x0008)
		{
			print (0,"Lock CFG Erase.");  
			! Lock CFG Erase;
			LockBitsArray[1] = LockBitsArray[1] | 0x00002400;
            TempTDO[1] = TempTDO[1] | 0x00000040;
            TempMask[1] = TempMask[1] | 0x00000040;
        }
		IF (LockBitsArray[1] != 0x00000000)
        {         
	        TempTDO[1] = $TempTDO[1];
	        TempMask[1] = $TempMask[1];         
	        //Add ISC_PROGRAM_SECURITY command
	        LockBitsArray[1] = 0xCE000000 | LockBitsArray[1];
	        LockBitsArray[1] = $LockBitsArray[1];        
	        @SPIFLASH_ENABLE();
			@SPISELECT_SECTOR0();		
			@SPICHECK_PROGRAM_SECURITY();				       
	        setpin ISPEN LOW;
	        ! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	        SDR 32  TDI (LockBitsArray[1]);
	        setpin ISPEN HIGH;
	        RUN_TEST DELAY PWP;
	        TRY 1{
	            setpin ISPEN LOW;
	            ! Shift in LSC_READ_STATUS0(0x3C) instruction;
	            SDR 32 TDI (0x0000003C);
	            SDR_TRY_VERIFY  32   TDI(#0^32)
	                                 TDO(TempTDO[1])
	                                 MASK(TempMask[1]);
	            setpin ISPEN HIGH;            
	        }
	        ELSE
	        {
	            setpin ISPEN HIGH;
	            @SPIDISABLE();
	            print (1,"Failed to Lock CFG. Cannot Continue.");
	        } 
	    } 
	    LockBitsArray[1] = 0x00000000;
		TempTDO[1]  = 0x00000000;
		TempMask[1] = 0x00000000;
		LockArray[1] = CSEC_Array_TDI[1] & 0x0020;
		IF (LockArray[1] == 0x0020)
		{
			LockBitsArray[1] = LockBitsArray[1] | 0x00010200;
			TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000400;	
        }
        LockArray[1] = CSEC_Array_TDI[1] & 0x0010;
		IF (LockArray[1] == 0x0010)
		{
			LockBitsArray[1] = LockBitsArray[1] | 0x00010100;
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000800; 
        }
        LockArray[1] = CSEC_Array_TDI[1] & 0x0008;
		IF (LockArray[1] == 0x0008)
		{			
			LockBitsArray[1] = LockBitsArray[1] | 0x00012400;
            TempTDO[1] = TempTDO[1] | 0x00000040;
            TempMask[1] = TempMask[1] | 0x00000040;
        }
        IF (LockBitsArray[1] != 0x00000000)
        {         
	        TempTDO[1] = $TempTDO[1];
	        TempMask[1] = $TempMask[1];         
	        //Add ISC_PROGRAM_SECURITY command
	        LockBitsArray[1] = 0xCE000000 | LockBitsArray[1];
	        LockBitsArray[1] = $LockBitsArray[1];        
	        @SPISELECT_SECTOR1();	
			@SPICHECK_PROGRAM_SECURITY();		
	        setpin ISPEN LOW;
	        ! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	        SDR 32  TDI (LockBitsArray[1]);
	        setpin ISPEN HIGH;
	        RUN_TEST DELAY PWP;
	        TRY 1{
	            setpin ISPEN LOW;
	            ! Shift in LSC_READ_STATUS0(0x3C) instruction;
	            SDR 32 TDI (0x0000003C);
	            SDR_TRY_VERIFY  32   TDI(#0^32)
	                                 TDO(TempTDO[1])
	                                 MASK(TempMask[1]);
	            setpin ISPEN HIGH;            
	        }
	        ELSE
	        {
	            setpin ISPEN HIGH;
	            @SPIDISABLE();
	            print (1,"Failed to Lock CFG. Cannot Continue.");
	        } 
	    } 
		LockBitsArray[1] = 0x00000000;
		TempTDO[1]  = 0x00000000;
		TempMask[1] = 0x00000000;
		LockArray[1] = CSEC_Array_TDI[1] & 0x0020;
		IF (LockArray[1] == 0x0020)
		{
			LockBitsArray[1] = LockBitsArray[1] | 0x00020200;
			TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000400;	
        }
        LockArray[1] = CSEC_Array_TDI[1] & 0x0010;
		IF (LockArray[1] == 0x0010)
		{
			LockBitsArray[1] = LockBitsArray[1] | 0x00020100;
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000800; 
        }
        LockArray[1] = CSEC_Array_TDI[1] & 0x0008;
		IF (LockArray[1] == 0x0008)
		{			
			LockBitsArray[1] = LockBitsArray[1] | 0x00022400;
            TempTDO[1] = TempTDO[1] | 0x00000040;
            TempMask[1] = TempMask[1] | 0x00000040;
        }
        IF (LockBitsArray[1] != 0x00000000)
        {         
	        TempTDO[1] = $TempTDO[1];
	        TempMask[1] = $TempMask[1];         
	        //Add ISC_PROGRAM_SECURITY command
	        LockBitsArray[1] = 0xCE000000 | LockBitsArray[1];
	        LockBitsArray[1] = $LockBitsArray[1];        
	        @SPISELECT_SECTOR2();			
			@SPICHECK_PROGRAM_SECURITY();				       
	        setpin ISPEN LOW;
	        ! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	        SDR 32  TDI (LockBitsArray[1]);
	        setpin ISPEN HIGH;
	        RUN_TEST DELAY PWP;
	        TRY 1{
	            setpin ISPEN LOW;
	            ! Shift in LSC_READ_STATUS0(0x3C) instruction;
	            SDR 32 TDI (0x0000003C);
	            SDR_TRY_VERIFY  32   TDI(#0^32)
	                                 TDO(TempTDO[1])
	                                 MASK(TempMask[1]);
	            setpin ISPEN HIGH;            
	        }
	        ELSE
	        {
	            setpin ISPEN HIGH;
	            @SPIDISABLE();
	            print (1,"Failed to Lock CFG. Cannot Continue.");
	        } 
	    }  	
		LockBitsArray[1] = 0x00000000;
		TempTDO[1]  = 0x00000000;
		TempMask[1] = 0x00000000;
		LockArray[1] = CSEC_Array_TDI[1] & 0x0004;
		IF (LockArray[1] == 0x0004)
		{
			print (0,"Lock UFM Write.");
			! Lock UFM Write;
			LockBitsArray[1] = LockBitsArray[1] | 0x00030200;
			TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000400;	
		} 
		LockArray[1] = CSEC_Array_TDI[1] & 0x0002;
		IF (LockArray[1] == 0x0002)
		{
			print (0,"Lock UFM Read.");
			! Lock UFM Read;
			LockBitsArray[1] = LockBitsArray[1] | 0x00030100;
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000800; 
		} 
		LockArray[1] = CSEC_Array_TDI[1] & 0x0001;
		IF (LockArray[1] == 0x0001)
		{
			print (0,"Lock UFM Erase.");
			! Lock UFM Erase;
			LockBitsArray[1] = LockBitsArray[1] | 0x00032400;
            TempTDO[1] = TempTDO[1] | 0x00000040;
            TempMask[1] = TempMask[1] | 0x00000040;
		}
		IF (LockBitsArray[1] != 0x00000000)
        {         
	        TempTDO[1] = $TempTDO[1];
	        TempMask[1] = $TempMask[1];         
	        //Add ISC_PROGRAM_SECURITY command
	        LockBitsArray[1] = 0xCE000000 | LockBitsArray[1];
	        LockBitsArray[1] = $LockBitsArray[1];        
	        @SPIFLASH_ENABLE();
			@SPISELECT_UFM();	
			@SPICHECK_PROGRAM_SECURITY();								       
	        setpin ISPEN LOW;
	        ! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	        SDR 32  TDI (LockBitsArray[1]);
	        setpin ISPEN HIGH;
	        RUN_TEST DELAY PWP;
	        TRY 1{
	            setpin ISPEN LOW;
	            ! Shift in LSC_READ_STATUS0(0x3C) instruction;
	            SDR 32 TDI (0x0000003C);
	            SDR_TRY_VERIFY  32   TDI(#0^32)
	                                 TDO(TempTDO[1])
	                                 MASK(TempMask[1]);
	            setpin ISPEN HIGH;            
	        }
	        ELSE
	        {
	            setpin ISPEN HIGH;
	            @SPIDISABLE();
	            print (1,"Failed to Lock UFM. Cannot Continue.");
	        } 
	    }  	 
	}
}
function I2CCSEC_PROGRAM_LOCK
{
	datastream LockBitsArray[1][32];
    datastream TempTDO[1][32];
    datastream TempMask[1][32];
    datastream LockArray[1][16];
    datastream FinalLockBitsArray[1][24];
	IF (CSEC_Array_TDI.row = 1)
	{
		//print (0,CSEC_Array_TDI);
		LockBitsArray[1] = 0x00000000;
		TempTDO[1]  = 0x00000000;
		TempMask[1] = 0x00000000;
        LockArray[1] = CSEC_Array_TDI[1] & 0x0800;
        IF (LockArray[1] == 0x0800)
        {
            print (0,"Lock SRAM Write.");
            ! Lock SRAM Write;
            LockBitsArray[1] = LockBitsArray[1] | 0x00000200;             
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000400;
        } 
        LockArray[1] = CSEC_Array_TDI[1] & 0x0400;
        IF (LockArray[1] == 0x0400)
        {              
            print (0,"Lock SRAM Read.");
            ! Lock SRAM Read;
            LockBitsArray[1] = LockBitsArray[1] | 0x00000100;
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000800;                                                                                                                                           
        } 
        LockArray[1] = CSEC_Array_TDI[1] & 0x0200;
        IF (LockArray[1] == 0x0200)
        {
            print (0,"Lock SRAM Erase.");
            ! Lock SRAM Erase;
            LockBitsArray[1] = LockBitsArray[1] | 0x00002400;
            TempTDO[1] = TempTDO[1] | 0x00000040;
            TempMask[1] = TempMask[1] | 0x00000040;
        }
        IF (LockBitsArray[1] != 0x00000000)
        {         
	        TempTDO[1] = $TempTDO[1];
	        TempMask[1] = $TempMask[1];         
	        //Add ISC_PROGRAM_SECURITY command
	        LockBitsArray[1] = 0xCE000000 | LockBitsArray[1];
	        LockBitsArray[1] = $LockBitsArray[1];        
	        @I2CSRAM_ENABLE();        
	        I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	        ! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	        SDR 32  TDI (LockBitsArray[1]);
	        I2C_STOP;
	        RUN_TEST DELAY PWP;
	        TRY 1{
	            I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	            ! Shift in LSC_READ_STATUS0(0x3C) instruction;
	            SDR 32 TDI (0x0000003C);
	            I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
	            SDR_TRY_VERIFY  32   TDI(#0^32)
	                                 TDO(TempTDO[1])
	                                 MASK(TempMask[1]);
	            I2C_STOP;            
	        }
	        ELSE
	        {
	            I2C_STOP;
	            @I2CDISABLE();
	            print (1,"Failed to Lock SRAM. Cannot Continue.");
	        } 
	    }        
		LockBitsArray[1] = 0x00000000;
		TempTDO[1]  = 0x00000000;
		TempMask[1] = 0x00000000;
		LockArray[1] = CSEC_Array_TDI[1] & 0x0100;
		IF (LockArray[1] == 0x0100)
		{
			print (0,"Lock FEA Write.");
			! Lock FEA Write;
			LockBitsArray[1] = LockBitsArray[1] | 0x00040200;
			TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000400;			
		}
		LockArray[1] = CSEC_Array_TDI[1] & 0x0080;
		IF (LockArray[1] == 0x0080)
		{
			print (0,"Lock FEA Read.");
			! Lock FEA Read;
			LockBitsArray[1] = LockBitsArray[1] | 0x00040100;
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000800; 
		}
		LockArray[1] = CSEC_Array_TDI[1] & 0x0040;
		IF (LockArray[1] == 0x0040)
		{
			print (0,"Lock FEA Erase.");
			! Lock FEA Erase;
			LockBitsArray[1] = LockBitsArray[1] | 0x00042400;
            TempTDO[1] = TempTDO[1] | 0x00000040;
            TempMask[1] = TempMask[1] | 0x00000040;			
		}
		IF (LockBitsArray[1] != 0x00000000)
        {         
	        TempTDO[1] = $TempTDO[1];
	        TempMask[1] = $TempMask[1];         
	        //Add ISC_PROGRAM_SECURITY command
	        LockBitsArray[1] = 0xCE000000 | LockBitsArray[1];
	        LockBitsArray[1] = $LockBitsArray[1];        
	        @I2CFLASH_ENABLE();
			@I2CSELECT_FEA();		
			@I2CCHECK_PROGRAM_SECURITY();	       
	        I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	        ! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	        SDR 32  TDI (LockBitsArray[1]);
	        I2C_STOP;
	        RUN_TEST DELAY PWP;
	        TRY 1{
	            I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	            ! Shift in LSC_READ_STATUS0(0x3C) instruction;
	            SDR 32 TDI (0x0000003C);
	            I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
	            SDR_TRY_VERIFY  32   TDI(#0^32)
	                                 TDO(TempTDO[1])
	                                 MASK(TempMask[1]);
	            I2C_STOP;            
	        }
	        ELSE
	        {
	            I2C_STOP;
	            @I2CDISABLE();
	            print (1,"Failed to Lock Feature Row. Cannot Continue.");
	        } 
	    }  
	    LockBitsArray[1] = 0x00000000;
		TempTDO[1]  = 0x00000000;
		TempMask[1] = 0x00000000;
		LockArray[1] = CSEC_Array_TDI[1] & 0x0020;
		IF (LockArray[1] == 0x0020)
		{
			print (0,"Lock CFG Write.");
			! Lock CFG Write;
			LockBitsArray[1] = LockBitsArray[1] | 0x00000200;
			TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000400;	
        }
        LockArray[1] = CSEC_Array_TDI[1] & 0x0010;
		IF (LockArray[1] == 0x0010)
		{
			print (0,"Lock CFG Read.");
			! Lock CFG Read;
			LockBitsArray[1] = LockBitsArray[1] | 0x00000100;
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000800; 
        }
        LockArray[1] = CSEC_Array_TDI[1] & 0x0008;
		IF (LockArray[1] == 0x0008)
		{
			print (0,"Lock CFG Erase.");  
			! Lock CFG Erase;
			LockBitsArray[1] = LockBitsArray[1] | 0x00002400;
            TempTDO[1] = TempTDO[1] | 0x00000040;
            TempMask[1] = TempMask[1] | 0x00000040;
        }
		IF (LockBitsArray[1] != 0x00000000)
        {         
	        TempTDO[1] = $TempTDO[1];
	        TempMask[1] = $TempMask[1];         
	        //Add ISC_PROGRAM_SECURITY command
	        LockBitsArray[1] = 0xCE000000 | LockBitsArray[1];
	        LockBitsArray[1] = $LockBitsArray[1];        
	        @I2CFLASH_ENABLE();
			@I2CSELECT_SECTOR0();		
			@I2CCHECK_PROGRAM_SECURITY();	  				       
	        I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	        ! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	        SDR 32  TDI (LockBitsArray[1]);
	        I2C_STOP;
	        RUN_TEST DELAY PWP;
	        TRY 1{
	            I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	            ! Shift in LSC_READ_STATUS0(0x3C) instruction;
	            SDR 32 TDI (0x0000003C);
	            I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
	            SDR_TRY_VERIFY  32   TDI(#0^32)
	                                 TDO(TempTDO[1])
	                                 MASK(TempMask[1]);
	            I2C_STOP;            
	        }
	        ELSE
	        {
	            I2C_STOP;
	            @I2CDISABLE();
	            print (1,"Failed to Lock CFG. Cannot Continue.");
	        } 
	    } 
	    LockBitsArray[1] = 0x00000000;
		TempTDO[1]  = 0x00000000;
		TempMask[1] = 0x00000000;
		LockArray[1] = CSEC_Array_TDI[1] & 0x0020;
		IF (LockArray[1] == 0x0020)
		{
			LockBitsArray[1] = LockBitsArray[1] | 0x00010200;
			TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000400;	
        }
        LockArray[1] = CSEC_Array_TDI[1] & 0x0010;
		IF (LockArray[1] == 0x0010)
		{
			LockBitsArray[1] = LockBitsArray[1] | 0x00010100;
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000800; 
        }
        LockArray[1] = CSEC_Array_TDI[1] & 0x0008;
		IF (LockArray[1] == 0x0008)
		{			
			LockBitsArray[1] = LockBitsArray[1] | 0x00012400;
            TempTDO[1] = TempTDO[1] | 0x00000040;
            TempMask[1] = TempMask[1] | 0x00000040;
        }
        IF (LockBitsArray[1] != 0x00000000)
        {         
	        TempTDO[1] = $TempTDO[1];
	        TempMask[1] = $TempMask[1];         
	        //Add ISC_PROGRAM_SECURITY command
	        LockBitsArray[1] = 0xCE000000 | LockBitsArray[1];
	        LockBitsArray[1] = $LockBitsArray[1];        
	        @I2CSELECT_SECTOR1();		
			@I2CCHECK_PROGRAM_SECURITY();	 				       
	        I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	        ! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	        SDR 32  TDI (LockBitsArray[1]);
	        I2C_STOP;
	        RUN_TEST DELAY PWP;
	        TRY 1{
	            I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	            ! Shift in LSC_READ_STATUS0(0x3C) instruction;
	            SDR 32 TDI (0x0000003C);
	            I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
	            SDR_TRY_VERIFY  32   TDI(#0^32)
	                                 TDO(TempTDO[1])
	                                 MASK(TempMask[1]);
	            I2C_STOP;           
	        }
	        ELSE
	        {
	            I2C_STOP;
	            @I2CDISABLE();
	            print (1,"Failed to Lock CFG. Cannot Continue.");
	        } 
	    } 
		LockBitsArray[1] = 0x00000000;
		TempTDO[1]  = 0x00000000;
		TempMask[1] = 0x00000000;
		LockArray[1] = CSEC_Array_TDI[1] & 0x0020;
		IF (LockArray[1] == 0x0020)
		{
			LockBitsArray[1] = LockBitsArray[1] | 0x00020200;
			TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000400;	
        }
        LockArray[1] = CSEC_Array_TDI[1] & 0x0010;
		IF (LockArray[1] == 0x0010)
		{
			LockBitsArray[1] = LockBitsArray[1] | 0x00020100;
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000800; 
        }
        LockArray[1] = CSEC_Array_TDI[1] & 0x0008;
		IF (LockArray[1] == 0x0008)
		{			
			LockBitsArray[1] = LockBitsArray[1] | 0x00022400;
            TempTDO[1] = TempTDO[1] | 0x00000040;
            TempMask[1] = TempMask[1] | 0x00000040;
        }
        IF (LockBitsArray[1] != 0x00000000)
        {         
	        TempTDO[1] = $TempTDO[1];
	        TempMask[1] = $TempMask[1];         
	        //Add ISC_PROGRAM_SECURITY command
	        LockBitsArray[1] = 0xCE000000 | LockBitsArray[1];
	        LockBitsArray[1] = $LockBitsArray[1];        
	        @I2CSELECT_SECTOR2();			
			@I2CCHECK_PROGRAM_SECURITY();	 			       
	        I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	        ! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	        SDR 32  TDI (LockBitsArray[1]);
	        I2C_STOP;
	        RUN_TEST DELAY PWP;
	        TRY 1{
	            I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	            ! Shift in LSC_READ_STATUS0(0x3C) instruction;
	            SDR 32 TDI (0x0000003C);
	            I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
	            SDR_TRY_VERIFY  32   TDI(#0^32)
	                                 TDO(TempTDO[1])
	                                 MASK(TempMask[1]);
	            I2C_STOP;            
	        }
	        ELSE
	        {
	            I2C_STOP;
	            @I2CDISABLE();
	            print (1,"Failed to Lock CFG. Cannot Continue.");
	        } 
	    }  	
		LockBitsArray[1] = 0x00000000;
		TempTDO[1]  = 0x00000000;
		TempMask[1] = 0x00000000;
		LockArray[1] = CSEC_Array_TDI[1] & 0x0004;
		IF (LockArray[1] == 0x0004)
		{
			print (0,"Lock UFM Write.");
			! Lock UFM Write;
			LockBitsArray[1] = LockBitsArray[1] | 0x00030200;
			TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000400;	
		} 
		LockArray[1] = CSEC_Array_TDI[1] & 0x0002;
		IF (LockArray[1] == 0x0002)
		{
			print (0,"Lock UFM Read.");
			! Lock UFM Read;
			LockBitsArray[1] = LockBitsArray[1] | 0x00030100;
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000800; 
		} 
		LockArray[1] = CSEC_Array_TDI[1] & 0x0001;
		IF (LockArray[1] == 0x0001)
		{
			print (0,"Lock UFM Erase.");
			! Lock UFM Erase;
			LockBitsArray[1] = LockBitsArray[1] | 0x00032400;
            TempTDO[1] = TempTDO[1] | 0x00000040;
            TempMask[1] = TempMask[1] | 0x00000040;
		}
		IF (LockBitsArray[1] != 0x00000000)
        {         
	        TempTDO[1] = $TempTDO[1];
	        TempMask[1] = $TempMask[1];         
	        //Add ISC_PROGRAM_SECURITY command
	        LockBitsArray[1] = 0xCE000000 | LockBitsArray[1];
	        LockBitsArray[1] = $LockBitsArray[1];        
	        @I2CFLASH_ENABLE();
			@I2CSELECT_UFM();		
			@I2CCHECK_PROGRAM_SECURITY();	  							       
	        I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	        ! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	        SDR 32  TDI (LockBitsArray[1]);
	        I2C_STOP;
	        RUN_TEST DELAY PWP;
	        TRY 1{
	            I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	            ! Shift in LSC_READ_STATUS0(0x3C) instruction;
	            SDR 32 TDI (0x0000003C);
	            I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
	            SDR_TRY_VERIFY  32   TDI(#0^32)
	                                 TDO(TempTDO[1])
	                                 MASK(TempMask[1]);
	            I2C_STOP;            
	        }
	        ELSE
	        {
	            I2C_STOP;
	            @I2CDISABLE();
	            print (1,"Failed to Lock UFM. Cannot Continue.");
	        } 
	    }  	 
	}	
}
function JTAGI2CCSEC_PROGRAM_LOCK
{
	datastream LockBitsArray[1][32];
    datastream TempTDO[1][32];
    datastream TempMask[1][32];
    datastream LockArray[1][16];
    datastream FinalLockBitsArray[1][24];
    datastream DataByte[1][8];
    datastream MaskByte[1][8];
	IF (CSEC_Array_TDI.row = 1)
	{
		//print (0,CSEC_Array_TDI);
		LockBitsArray[1] = 0x00000000;
		TempTDO[1]  = 0x00000000;
		TempMask[1] = 0x00000000;
        LockArray[1] = CSEC_Array_TDI[1] & 0x0800;
        IF (LockArray[1] == 0x0800)
        {
            print (0,"Lock SRAM Write");
            LockBitsArray[1] = LockBitsArray[1] | 0x00000200;             
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000400;
        } 
        LockArray[1] = CSEC_Array_TDI[1] & 0x0400;
        IF (LockArray[1] == 0x0400)
        {              
            print (0,"Lock SRAM Read");
            LockBitsArray[1] = LockBitsArray[1] | 0x00000100;
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000800;                                                                                                                                           
        } 
        LockArray[1] = CSEC_Array_TDI[1] & 0x0200;
        IF (LockArray[1] == 0x0200)
        {
            print (0,"Lock SRAM Erase");
            LockBitsArray[1] = LockBitsArray[1] | 0x00002400;
            TempTDO[1] = TempTDO[1] | 0x00000040;
            TempMask[1] = TempMask[1] | 0x00000040;
        }
        IF (LockBitsArray[1] != 0x00000000)
        { 
        	TempTDO[1] = $TempTDO[1];
	        TempMask[1] = $TempMask[1];         
	        //Add ISC_PROGRAM_SECURITY command
	        LockBitsArray[1] = 0xCE000000 | LockBitsArray[1];    
	        @JTAGI2CSRAM_ENABLE();        
	        ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);		
	        ! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	        DataByte[1] = LockBitsArray[1];
	        SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (LockBitsArray[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (LockBitsArray[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (LockBitsArray[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST	IDLE  TCK 2 DELAY PWP; 
	        TRY 1{
	            ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
	            ! Shift in LSC_READ_STATUS0(0x3C) instruction;
	            SDR	16	TDI (0x103C);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);
				TempTDO[1] = $TempTDO[1];
				TempMask[1] = $TempMask[1];
				DataByte[1] = TempTDO[1];
				MaskByte[1] = TempMask[1];
				SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;		
	            DataByte[1] = (TempTDO[1] << 8);
	            MaskByte[1] = (TempMask[1] << 8);
	            SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TempTDO[1] << 16);
	            MaskByte[1] = (TempMask[1] << 16);
	            SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;   
				DataByte[1] = (TempTDO[1] << 24);
	            MaskByte[1] = (TempMask[1] << 24);
	            SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;                  
	            ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;            
	        }
	        ELSE
	        {
	            ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;
	            @JTAGI2CDISABLE();
	            print (1,"Failed to Lock SRAM. Cannot Continue.");
	        } 
	    }        
		LockBitsArray[1] = 0x00000000;
		TempTDO[1]  = 0x00000000;
		TempMask[1] = 0x00000000;
		LockArray[1] = CSEC_Array_TDI[1] & 0x0100;
		IF (LockArray[1] == 0x0100)
		{
			print (0,"Lock FEA Write.");
			LockBitsArray[1] = LockBitsArray[1] | 0x00040200;
			TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000400;			
		}
		LockArray[1] = CSEC_Array_TDI[1] & 0x0080;
		IF (LockArray[1] == 0x0080)
		{
			print (0,"Lock FEA Read.");
			LockBitsArray[1] = LockBitsArray[1] | 0x00040100;
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000800; 
		}
		LockArray[1] = CSEC_Array_TDI[1] & 0x0040;
		IF (LockArray[1] == 0x0040)
		{
			print (0,"Lock FEA Erase.");
			LockBitsArray[1] = LockBitsArray[1] | 0x00042400;
            TempTDO[1] = TempTDO[1] | 0x00000040;
            TempMask[1] = TempMask[1] | 0x00000040;			
		}
		IF (LockBitsArray[1] != 0x00000000)
        {         
	        TempTDO[1] = $TempTDO[1];
	        TempMask[1] = $TempMask[1];         
	        //Add ISC_PROGRAM_SECURITY command
	        LockBitsArray[1] = 0xCE000000 | LockBitsArray[1];    
	        @JTAGI2CFLASH_ENABLE();
			@JTAGI2CSELECT_FEA();		
			@JTAGI2CCHECK_PROGRAM_SECURITY();	  	       
	        ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);		
	        ! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	        DataByte[1] = LockBitsArray[1];
	        SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (LockBitsArray[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (LockBitsArray[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (LockBitsArray[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST	IDLE  TCK 2 DELAY PWP; 
	        TRY 1{
	            ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
	            ! Shift in LSC_READ_STATUS0(0x3C) instruction;
	            SDR	16	TDI (0x103C);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);
				TempTDO[1] = $TempTDO[1];
				TempMask[1] = $TempMask[1];
				DataByte[1] = TempTDO[1];
				MaskByte[1] = TempMask[1];
				SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;		
	            DataByte[1] = (TempTDO[1] << 8);
	            MaskByte[1] = (TempMask[1] << 8);
	            SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TempTDO[1] << 16);
	            MaskByte[1] = (TempMask[1] << 16);
	            SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;   
				DataByte[1] = (TempTDO[1] << 24);
	            MaskByte[1] = (TempMask[1] << 24);
	            SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;                  
	            ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;            
	        }
	        ELSE
	        {
	            ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;
	            @JTAGI2CDISABLE();
	            print (1,"Failed to Lock Feature Row. Cannot Continue.");
	        } 
	    }  
	    LockBitsArray[1] = 0x00000000;
		TempTDO[1]  = 0x00000000;
		TempMask[1] = 0x00000000;
		LockArray[1] = CSEC_Array_TDI[1] & 0x0020;
		IF (LockArray[1] == 0x0020)
		{
			print (0,"Lock CFG Write.");
			LockBitsArray[1] = LockBitsArray[1] | 0x00000200;
			TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000400;	
        }
        LockArray[1] = CSEC_Array_TDI[1] & 0x0010;
		IF (LockArray[1] == 0x0010)
		{
			print (0,"Lock CFG Read.");
			LockBitsArray[1] = LockBitsArray[1] | 0x00000100;
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000800; 
        }
        LockArray[1] = CSEC_Array_TDI[1] & 0x0008;
		IF (LockArray[1] == 0x0008)
		{
			print (0,"Lock CFG Erase.");  
			LockBitsArray[1] = LockBitsArray[1] | 0x00002400;
            TempTDO[1] = TempTDO[1] | 0x00000040;
            TempMask[1] = TempMask[1] | 0x00000040;
        }
		IF (LockBitsArray[1] != 0x00000000)
        {         
	        TempTDO[1] = $TempTDO[1];
	        TempMask[1] = $TempMask[1];         
	        //Add ISC_PROGRAM_SECURITY command
	        LockBitsArray[1] = 0xCE000000 | LockBitsArray[1];
	        @JTAGI2CFLASH_ENABLE();
			@JTAGI2CSELECT_SECTOR0();		
			@JTAGI2CCHECK_PROGRAM_SECURITY();					       
	        ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);		
	        ! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	        DataByte[1] = LockBitsArray[1];
	        SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (LockBitsArray[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (LockBitsArray[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (LockBitsArray[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST	IDLE  TCK 2 DELAY 1000; 
	        TRY 1{
	            ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
	            ! Shift in LSC_READ_STATUS0(0x3C) instruction;
	            SDR	16	TDI (0x103C);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);
				TempTDO[1] = $TempTDO[1];
				TempMask[1] = $TempMask[1];
				DataByte[1] = TempTDO[1];
				MaskByte[1] = TempMask[1];
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1])
								MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;		
	            DataByte[1] = (TempTDO[1] << 8);
	            MaskByte[1] = (TempMask[1] << 8);
	            SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TempTDO[1] << 16);
				MaskByte[1] = (TempMask[1] << 16);
	            SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;   
				DataByte[1] = (TempTDO[1] << 24);
				MaskByte[1] = (TempMask[1] << 24);
	            SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;                  
	            ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;          
	        }
	        ELSE
	        {
	        	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;
	            @JTAGI2CDISABLE();
	            print (1,"Failed to Lock CFG. Cannot Continue.");
	        } 
	    } 
	    LockBitsArray[1] = 0x00000000;
		TempTDO[1]  = 0x00000000;
		TempMask[1] = 0x00000000;
		LockArray[1] = CSEC_Array_TDI[1] & 0x0020;
		IF (LockArray[1] == 0x0020)
		{
			LockBitsArray[1] = LockBitsArray[1] | 0x00010200;
			TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000400;	
        }
        LockArray[1] = CSEC_Array_TDI[1] & 0x0010;
		IF (LockArray[1] == 0x0010)
		{
			LockBitsArray[1] = LockBitsArray[1] | 0x00010100;
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000800; 
        }
        LockArray[1] = CSEC_Array_TDI[1] & 0x0008;
		IF (LockArray[1] == 0x0008)
		{			
			LockBitsArray[1] = LockBitsArray[1] | 0x00012400;
            TempTDO[1] = TempTDO[1] | 0x00000040;
            TempMask[1] = TempMask[1] | 0x00000040;
        }
        IF (LockBitsArray[1] != 0x00000000)
        {         
	        TempTDO[1] = $TempTDO[1];
	        TempMask[1] = $TempMask[1];         
	        //Add ISC_PROGRAM_SECURITY command
	        LockBitsArray[1] = 0xCE000000 | LockBitsArray[1];
	        @JTAGI2CSELECT_SECTOR1();		
			@JTAGI2CCHECK_PROGRAM_SECURITY();					       
	        ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);		
	        ! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	        DataByte[1] = LockBitsArray[1];
	        SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (LockBitsArray[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (LockBitsArray[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (LockBitsArray[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST	IDLE  TCK 2 DELAY PWP; 
	        TRY 1{
	            ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
	            ! Shift in LSC_READ_STATUS0(0x3C) instruction;
	            SDR	16	TDI (0x103C);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);
				TempTDO[1] = $TempTDO[1];
				TempMask[1] = $TempMask[1];
				DataByte[1] = TempTDO[1];
				MaskByte[1] = TempMask[1];
				SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;		
	            DataByte[1] = (TempTDO[1] << 8);
	            MaskByte[1] = (TempMask[1] << 8);
	            SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TempTDO[1] << 16);
	            MaskByte[1] = (TempMask[1] << 16);
	            SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;   
				DataByte[1] = (TempTDO[1] << 24);
	            MaskByte[1] = (TempMask[1] << 24);
	            SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;                  
	            ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;            
	        }
	        ELSE
	        {
	        	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;
	            @JTAGI2CDISABLE();
	            print (1,"Failed to Lock CFG. Cannot Continue.");
	        } 
	    } 
		LockBitsArray[1] = 0x00000000;
		TempTDO[1]  = 0x00000000;
		TempMask[1] = 0x00000000;
		LockArray[1] = CSEC_Array_TDI[1] & 0x0020;
		IF (LockArray[1] == 0x0020)
		{
			LockBitsArray[1] = LockBitsArray[1] | 0x00020200;
			TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000400;	
        }
        LockArray[1] = CSEC_Array_TDI[1] & 0x0010;
		IF (LockArray[1] == 0x0010)
		{
			LockBitsArray[1] = LockBitsArray[1] | 0x00020100;
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000800; 
        }
        LockArray[1] = CSEC_Array_TDI[1] & 0x0008;
		IF (LockArray[1] == 0x0008)
		{			
			LockBitsArray[1] = LockBitsArray[1] | 0x00022400;
            TempTDO[1] = TempTDO[1] | 0x00000040;
            TempMask[1] = TempMask[1] | 0x00000040;
        }
        IF (LockBitsArray[1] != 0x00000000)
        {         
	        TempTDO[1] = $TempTDO[1];
	        TempMask[1] = $TempMask[1];         
	        //Add ISC_PROGRAM_SECURITY command
	        LockBitsArray[1] = 0xCE000000 | LockBitsArray[1];
	        @JTAGI2CSELECT_SECTOR2();		
			@JTAGI2CCHECK_PROGRAM_SECURITY();					       
	        ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);		
	        ! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	        DataByte[1] = LockBitsArray[1];
	        SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (LockBitsArray[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (LockBitsArray[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (LockBitsArray[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST	IDLE  TCK 2 DELAY PWP; 
	        TRY 1{
	            ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
	            ! Shift in LSC_READ_STATUS0(0x3C) instruction;
	            SDR	16	TDI (0x103C);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);
				TempTDO[1] = $TempTDO[1];
				TempMask[1] = $TempMask[1];
				DataByte[1] = TempTDO[1];
				MaskByte[1] = TempMask[1];
				SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;		
	            DataByte[1] = (TempTDO[1] << 8);
	            MaskByte[1] = (TempMask[1] << 8);
	            SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TempTDO[1] << 16);
	            MaskByte[1] = (TempMask[1] << 16);
	            SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;   
				DataByte[1] = (TempTDO[1] << 24);
	            MaskByte[1] = (TempMask[1] << 24);
	            SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;                  
	            ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;            
	        }
	        ELSE
	        {
	        	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;
	            @JTAGI2CDISABLE();
	            print (1,"Failed to Lock CFG. Cannot Continue.");
	        } 
	    }  	
		LockBitsArray[1] = 0x00000000;
		TempTDO[1]  = 0x00000000;
		TempMask[1] = 0x00000000;
		LockArray[1] = CSEC_Array_TDI[1] & 0x0004;
		IF (LockArray[1] == 0x0004)
		{
			print (0,"Lock UFM Write.");
			LockBitsArray[1] = LockBitsArray[1] | 0x00030200;
			TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000400;	
		} 
		LockArray[1] = CSEC_Array_TDI[1] & 0x0002;
		IF (LockArray[1] == 0x0002)
		{
			print (0,"Lock UFM Read.");
			LockBitsArray[1] = LockBitsArray[1] | 0x00030100;
            TempTDO[1] = TempTDO[1] | 0x00000000;
            TempMask[1] = TempMask[1] | 0x00000800; 
		} 
		LockArray[1] = CSEC_Array_TDI[1] & 0x0001;
		IF (LockArray[1] == 0x0001)
		{
			print (0,"Lock UFM Erase.");
			LockBitsArray[1] = LockBitsArray[1] | 0x00032400;
            TempTDO[1] = TempTDO[1] | 0x00000040;
            TempMask[1] = TempMask[1] | 0x00000040;
		}
		IF (LockBitsArray[1] != 0x00000000)
        {         
	        TempTDO[1] = $TempTDO[1];
	        TempMask[1] = $TempMask[1];         
	        //Add ISC_PROGRAM_SECURITY command
	        LockBitsArray[1] = 0xCE000000 | LockBitsArray[1]; 
	        @JTAGI2CFLASH_ENABLE();
			@JTAGI2CSELECT_UFM();		
			@JTAGI2CCHECK_PROGRAM_SECURITY();								       
	        ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);		
	        ! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	        DataByte[1] = LockBitsArray[1];
	        SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (LockBitsArray[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (LockBitsArray[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (LockBitsArray[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST	IDLE  TCK 2 DELAY PWP; 
	        TRY 1{
	            ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
	            ! Shift in LSC_READ_STATUS0(0x3C) instruction;
	            SDR	16	TDI (0x103C);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);
				TempTDO[1] = $TempTDO[1];
				TempMask[1] = $TempMask[1];
				DataByte[1] = TempTDO[1];
				MaskByte[1] = TempMask[1];
				SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;		
	            DataByte[1] = (TempTDO[1] << 8);
	            MaskByte[1] = (TempMask[1] << 8);
	            SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TempTDO[1] << 16);
	            MaskByte[1] = (TempMask[1] << 16);
	            SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;   
				DataByte[1] = (TempTDO[1] << 24);
	            MaskByte[1] = (TempMask[1] << 24);
	            SDR_TRY_VERIFY	8	TDI  (0x00)
									TDO  (DataByte[1])
									MASK (MaskByte[1]);
				RUN_TEST IDLE TCK 1000 ;                  
	            ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;            
	        }
	        ELSE
	        {
	        	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;
	            @JTAGI2CDISABLE();
	            print (1,"Failed to Lock UFM. Cannot Continue.");
	        } 
	    }  	 
	}
}
function SPICFG_READ_CENTRAL_LOCK
{
	datastream CSECSavedFuseMap[1][16];
	file NewFile = "FILE_SAVE";		
	@SPISELECT_FEA();	
	// Feature Row Locks	
	TRY 1{	
    	setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00200000)
				  		MASK(0x00200000);
		setpin ISPEN HIGH;	
	}
	ELSE
	{
		setpin ISPEN HIGH;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0100;
	
	} 		
	TRY 1{	
    	setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00100000)
				  		MASK(0x00100000);
		setpin ISPEN HIGH;	
	}
	ELSE
	{
		setpin ISPEN HIGH;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0080;
	} 		
	TRY 1{		
    	setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00000000)
				  		MASK(0x02000000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		setpin ISPEN HIGH;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0040;
	} 		
	@SPISELECT_SECTOR0();	
	// Flash CFG Locks	
	TRY 1{
    	setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00200000)
				  		MASK(0x00200000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		setpin ISPEN HIGH;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0020;
	} 		
	TRY 1{		
    	setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00100000)
				  		MASK(0x00100000);
		setpin ISPEN HIGH;	
	}
	ELSE
	{
		setpin ISPEN HIGH;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0010;
	} 		
	TRY 1{		
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00000000)
				  		MASK(0x02000000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		setpin ISPEN HIGH;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0008;
	} 
	@SPISELECT_UFM();
	// Flash UFM Locks					
	TRY 1{	
    	setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00200000)
				  		MASK(0x00200000);
		setpin ISPEN HIGH;	
	} 
	ELSE
	{
		setpin ISPEN HIGH;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0004;
	} 		
	TRY 1{
    	setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00100000)
				  		MASK(0x00100000);
		setpin ISPEN HIGH;	
	} 
	ELSE
	{
		setpin ISPEN HIGH;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0002;
	}		
	TRY 1{
    	setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00000000)
				  		MASK(0x02000000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		setpin ISPEN HIGH;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0001;
	}
	@SPISRAM_ENABLE();
	TRY 1{
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00200000)
				  		MASK(0x00200000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		setpin ISPEN HIGH;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0800;
	
	}
	TRY 1{							             			
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00100000)
				  		MASK(0x00100000);
		setpin ISPEN HIGH;		   		    
	}
	ELSE
	{
		setpin ISPEN HIGH;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0400;
	
	}
	TRY 1{	
    	setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00000000)
				  		MASK(0x02000000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		setpin ISPEN HIGH;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0200;
	}  
	print (0,CSECSavedFuseMap);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, CSECSavedFuseMap);
	fclose 	NewFile;		
}
function I2CCFG_READ_CENTRAL_LOCK
{
	datastream CSECSavedFuseMap[1][16];
	file NewFile = "FILE_SAVE";		
	@I2CSELECT_FEA();		
	TRY 1{	
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00200000)
				  		MASK(0x00200000);
		I2C_STOP;	
	}
	ELSE
	{
		I2C_STOP;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0100;
	
	} 		
	TRY 1{	
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00100000)
				  		MASK(0x00100000);
		I2C_STOP;	
	}
	ELSE
	{
		I2C_STOP;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0080;
	} 		
	TRY 1{		
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00000000)
				  		MASK(0x02000000);
		I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0040;
	} 		
	@I2CSELECT_SECTOR0();		
	TRY 1{
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00200000)
				  		MASK(0x00200000);
		I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0020;
	} 		
	TRY 1{		
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00100000)
				  		MASK(0x00100000);
		I2C_STOP;	
	}
	ELSE
	{
		I2C_STOP;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0010;
	} 		
	TRY 1{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00000000)
				  		MASK(0x02000000);
		I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0008;
	} 
	@I2CSELECT_UFM();				
	TRY 1{	
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00200000)
				  		MASK(0x00200000);
		I2C_STOP;	
	} 
	ELSE
	{
		I2C_STOP;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0004;
	} 		
	TRY 1{
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00100000)
				  		MASK(0x00100000);
		I2C_STOP;	
	} 
	ELSE
	{
		I2C_STOP;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0002;
	}		
	TRY 1{
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00000000)
				  		MASK(0x02000000);
		I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0001;
	} 
	@I2CSRAM_ENABLE();
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00200000)
				  		MASK(0x00200000);
		I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0800;
	
	}
	TRY 1{							             			
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00100000)
				  		MASK(0x00100000);
		I2C_STOP;		   		    
	}
	ELSE
	{
		I2C_STOP;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0400;
	
	}
	TRY 1{	
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00000000)
				  		MASK(0x02000000);
		I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0200;
	} 
	print (0,CSECSavedFuseMap);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, CSECSavedFuseMap);
	fclose 	NewFile;			
}
function JTAGI2CCFG_READ_CENTRAL_LOCK
{
	datastream DataByte[1][8];
	datastream SavedStatus[1][32];
	datastream TempArray[1][32];
	datastream CSECSavedFuseMap[1][16];
	file NewFile = "FILE_SAVE";
	@JTAGI2CSELECT_FEA();	

	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedStatus[1] = ((SavedStatus[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedStatus[1] = ((SavedStatus[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedStatus[1] = ((SavedStatus[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedStatus[1] = ((SavedStatus[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 

	TempArray[1] = SavedStatus[1] & 0x00000400;
	IF (TempArray[1] == 0x00000000)
	{
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0100;
	}
	
	TempArray[1] = SavedStatus[1] & 0x00000800;
	IF (TempArray[1] == 0x00000000)
	{
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0080;
	}

	TempArray[1] = SavedStatus[1] & 0x00000040;
	IF (TempArray[1] == 0x00000040)
	{
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0040;
	}	

	@JTAGI2CSELECT_SECTOR0();
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedStatus[1] = ((SavedStatus[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedStatus[1] = ((SavedStatus[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedStatus[1] = ((SavedStatus[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedStatus[1] = ((SavedStatus[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 

	TempArray[1] = SavedStatus[1] & 0x00000400;
	IF (TempArray[1] == 0x00000000)
	{
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0020;
	}
	
	TempArray[1] = SavedStatus[1] & 0x00000800;
	IF (TempArray[1] == 0x00000000)
	{
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0010;
	}

	TempArray[1] = SavedStatus[1] & 0x00000040;
	IF (TempArray[1] == 0x00000040)
	{
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0008;
	}	

	@JTAGI2CSELECT_UFM();	

	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedStatus[1] = ((SavedStatus[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedStatus[1] = ((SavedStatus[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedStatus[1] = ((SavedStatus[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedStatus[1] = ((SavedStatus[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 

	TempArray[1] = SavedStatus[1] & 0x00000400;
	IF (TempArray[1] == 0x00000000)
	{
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0004;
	}
	
	TempArray[1] = SavedStatus[1] & 0x00000800;
	IF (TempArray[1] == 0x00000000)
	{
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0002;
	}

	TempArray[1] = SavedStatus[1] & 0x00000040;
	IF (TempArray[1] == 0x00000040)
	{
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0001;
	}
	@JTAGI2CSRAM_ENABLE();
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedStatus[1] = ((SavedStatus[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedStatus[1] = ((SavedStatus[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedStatus[1] = ((SavedStatus[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedStatus[1] = ((SavedStatus[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ; 
	
	TempArray[1] = SavedStatus[1] & 0x00000400;
	IF (TempArray[1] == 0x00000000)
	{
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0800;
	}
	
	TempArray[1] = SavedStatus[1] & 0x00000800;
	IF (TempArray[1] == 0x00000000)
	{
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0400;
	}

	TempArray[1] = SavedStatus[1] & 0x00000040;
	IF (TempArray[1] == 0x00000040)
	{
		CSECSavedFuseMap[1] = CSECSavedFuseMap[1] | 0x0200;
	}
	print (0,CSECSavedFuseMap);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, CSECSavedFuseMap);
	fclose 	NewFile;		
}
]]>
</Script>
</SVF_Plus>
