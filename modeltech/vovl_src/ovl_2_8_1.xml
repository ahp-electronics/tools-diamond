


<library version="2.6">
	<checkers>
		<checker vhdl_support="full" verilog_support="full">
			<name>ovl_always</name>
			<note>Checks that the value of an expression is TRUE.</note>
			<file_path>ovl_always.v</file_path>
			<diagram>diagram_ovl_always.gif</diagram>
			<syntax>ovl_always [#(severity_level, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>											
			</params>
			<ports>
				<port direction="input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>		
				<port direction="input">
				   <name>test_expr</name>
				</port>					
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>					
			</ports>
		</checker>	
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_always_on_edge</name>
			<note>Checks that the value of an expression is TRUE when a sampling event undergoes a specified transition.</note>
			<file_path>ovl_always_on_edge.v</file_path>
			<diagram>diagram_ovl_always_on_edge.gif</diagram>
			<syntax>ovl_always_on_edge [#(severity_level, edge_type, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, sampling_event, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="edgeParam" type="list">
					<name>edge_type</name>			
					<values>
						<value abs="0" default="yes">`OVL_NOEDGE</value>					
						<value abs="1">`OVL_POSEDGE</value>				
						<value abs="2">`OVL_NEGEDGE</value>	
						<value abs="3">`OVL_ANYEDGE</value>	
					</values>
					<note>Transition type for sampling event: OVL_NOEDGE, OVL_POSEDGE, OVL_NEGEDGE or OVL_ANYEDGE. Default: OVL_NOEDGE.</note>
				</param>				
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>		
				<port direction="input">
				   <name>sampling_event</name>
				</port>
				<port direction="input">
				   <name>test_expr</name>
				</port>
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>					
			</ports>			
		</checker>	
		<checker vhdl_support="none">
			<name>ovl_arbiter</name>
			<note>Checks that a resource arbiter provides grants to corresponding requests according to a specified arbitration scheme and within a specified time window.</note>
			<file_path>ovl_arbiter.v</file_path>
			<diagram>diagram_ovl_arbiter.gif</diagram>
			<syntax>ovl_arbiter [#(severity_level, width, priority_width, min_cks, max_cks, one_cycle_gnt_check, priority_check, arbitration_rule, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, reqs, priorities, gnts, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">2</value>
					</values>
					<note>Width of reqs and gnts ports (number of channels). Default: 2.</note>
				</param>	
				<param id="priorityParam" type="number">
					<name>priority_width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Number of bits to encode a priority value in priorities. Default: 1.</note>
				</param>	
				<param id="minCksParam" type="number">
					<name>min_cks</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Minimum number of clock cycles after a request that its grant can be issued. If min_cks is 0, a grant can be issued in the same cycle the request is made. Default: 1.</note>
				</param>
				<param id="maxCksParam" type="number">
					<name>max_cks</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Maximum number of clock cycles after a request that its grant can be issued. A value of 0 indicates no upper bound for grants. Default: 0.</note>
				</param>
				<param id="cycleCkParam">
					<name>one_cycle_gnt_check</name>			
					<values>
						<value>0</value>						
						<value default="yes">1</value>
					</values>
					<note>Whether or not to perform grant_one checks.&#10;one_cycle_gnt_check = 0 Turns off the grant_one check.&#10;one_cycle_gnt_check = 1 (Default) Turns on the grant_one check.</note>
				</param>
				<param id="arbitRuleParam">
					<name>arbitration_rule</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
						<value>2</value>
						<value>3</value>						
					</values>
					<note>Arbitration scheme used by the arbiter. This parameter turns on the corresponding check for the arbitration scheme.&#10;&#10;arbitration_rule = 0 (Default) no scheme&#10;arbitration_rule = 1 fair (round robin)&#10;arbitration_rule = 2 FIFO&#10;arbitration_rule = 3 least-recently used.</note>
				</param>	
				<param id="priorityCkParam">
					<name>priority_check</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>					
					</values>
					<note>Whether or not to perform priority checks.&#10;&#10;priority_check = 0 (Default) Turns off the priority check.&#10;priority_check = 1 Turns on the priority check. The min_cks parameter must be 0 or 1.</note>
				</param>					
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>				
				<port direction="input">
				   <name>reqs</name>
				   <packed>width-1 : 0</packed>
				</port>
				<port direction="input">
				   <name>priorities</name>
				   <packed>(width*priority_width)-1 : 0</packed>
				</port>
				<port direction="input">
				   <name>gnts</name>
				   <packed>width-1 : 0</packed>
				</port>
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>	
		<checker vhdl_support="none">
			<name>ovl_bits</name>
			<note>Checks that the number of asserted (or deasserted) bits of the value of an expression is within a specified range.</note>
			<file_path>ovl_bits.v</file_path>
			<diagram>diagram_ovl_bits.gif</diagram>
			<syntax>ovl_bits [#(severity_level, min, max, width, asserted, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr argument.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="assertedParam" type="number">
					<name>asserted</name>			
					<values>
						<value>0</value>					
						<value default="yes">1</value>
					</values>
					<note>Whether to count asserted or deasserted bits.&#10;&#10;asserted = 0 Counts FALSE (deasserted) bits.&#10;asserted = 1 (Default) Counts TRUE (asserted) bits.</note>
				</param>	
				<param id="minCksParam" type="number">
					<name>min</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Whether or not to perform min checks. Default: 1.&#10;&#10;min = 0 Turns off the min check.&#10;min &gt;= 1 Minimum number of bits in test_expr that should be asserted (or deasserted).</note>
				</param>
				<param id="maxCksParam" type="number">
					<name>max</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Maximum number of bits in test_expr that should be asserted (or deasserted). Max must be &gt;= min. Default: 1.</note>
				</param>
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>				
				<port direction="input">
				   <name>test_expr</name>
				   <packed>width-1 : 0</packed>
				</port>
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>			
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_change</name>
			<note>Checks that the value of an expression changes within a specified number of cycles after a start event initiates checking.</note>
			<file_path>ovl_change.v</file_path>
			<diagram>diagram_ovl_change.gif</diagram>
			<syntax>ovl_change [#(severity_level, width, num_cks, action_on_new_start, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, start_event, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr argument.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="chksParam" type="number">
					<name>num_cks</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Number of cycles to check for a change in the value of test_expr.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="actionParam">
					<name>action_on_new_start</name>			
					<values>
						<value abs="0" default="yes">`OVL_IGNORE_NEW_START</value>
						<value abs="1">`OVL_RESET_ON_NEW_START</value>
						<value abs="2">`OVL_ERROR_ON_NEW_START</value>
					</values>
					<note>Method for handling a new start event that occurs before test_expr changes value or num_cks clock cycles transpire without a change.&#10;&#10;Values are: OVL_IGNORE_NEW_START, OVL_RESET_ON_NEW_START and OVL_ERROR_ON_NEW_START.&#10;Default: OVL_IGNORE_NEW_START.</note>
				</param>
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>				
				<port direction="input">
				   <name>start_event</name>
				</port>
				<port direction="input">
				   <name>test_expr</name>
				   <packed>width-1 : 0</packed>
				</port>
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>	
		<checker vhdl_support="none">
			<name>ovl_code_distance</name>
			<note>Checks that when an expression changes value, the number of bits in the new value that are different from the bits in the value of a second expression is within a specified range.</note>
			<file_path>ovl_code_distance.v</file_path>
			<diagram>diagram_ovl_code_distance.gif</diagram>
			<syntax>ovl_code_distance [#(severity_level, min, max, width, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr1, test_expr2, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of test_expr and test_expr2.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="minParam" type="number">
					<name>min</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Minimum code distance.&#10;&#10;Default: 1.</note>
				</param>
				<param id="maxParam" type="number">
					<name>max</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Maximum code distance.&#10;&#10;Default: 1.</note>
				</param>
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>				
				<port direction="input">
				   <name>test_expr1</name>
				   <packed>width-1 : 0</packed>
				</port>
				<port direction="input">				
				   <name>test_expr2</name>
				   <packed>width-1 : 0</packed>
				</port>
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>
		<checker vhdl_support="none">
			<name>ovl_coverage</name>
			<note>Ensures that an HDL statement is covered during simulation.</note>
			<file_path>ovl_coverage.v</file_path>
			<diagram>diagram_ovl_coverage.gif</diagram>
			<syntax>ovl_coverage [#(severity_level, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>				
				<port direction="input">
				   <name>test_expr</name>
				</port>
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>	
		<checker vhdl_support="none">
			<name>ovl_crc</name>
			<note>Ensures that the CRC checksum values for a specified expression are calculated properly.</note>
			<file_path>ovl_crc.v</file_path>
			<diagram>diagram_ovl_crc.gif</diagram>
			<syntax>ovl_crc [#(severity_level, width, data_width, crc_width, crc_enable, crc_latch_enable, polynomial, standard_polynomial, initial_value, lsb_first, big_endian, reverse_endian, invert, combinational, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, initialize, valid, compare, crc, crc_latch, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of test_expr.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="dataParam" type="number">
					<name>data_width</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Width of a data item in the message stream.&#10;&#10;data_width = 0 Data item width is width bits (i.e., test_expr holds a complete data item).&#10;data_width = n x width (n &gt; 0) Data item width is n times the width of test_expr. Each data item is the concatenation of the values of test_expr collected over n valid cycles.&#10;For example, if test_expr has the values 2'b11, 2'b10, 2'b01 and 2'b10 over 4 consecutive valid cycles, then the corresponding data item is 8'b11100110.</note>
				</param>	
				<param id="crcParam" type="number">
					<name>crc_width</name>			
					<values>
						<value default="yes">5</value>
					</values>
					<note>Degree of the CRC generator polynomial, width of the CRC checksum and width of the crc port (if crc_enable is 1).&#10;&#10;Default: 5.</note>
				</param>
				<param id="crcEnableParam">
					<name>crc_enable</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>Which data port contains the input CRC value.&#10;&#10;crc_enable = 0 (Default) Test_expr contains the input CRC value. Crc_width cannot be &lt; width, or a CRC check violation occurs each compare cycle. The crc port is ignored.&#10;crc_enable = 1 The crc port contains the complete input CRC value.</note>
				</param>
				<param id="crcLatchParam">
					<name>crc_latch_enable</name>			
					<values>
						<value default="yes">0</value>						
						<value>1</value>							
					</values>
					<note>Whether or not to latch the internal CRC register value.&#10;crc_latch_enable = 0 (Default) The current value of the CRC register is compared with the input CRC value when compare asserts. The crc_latch port is ignored.&#10;crc_latch_enable = 1 The current value of the CRC register is latched if crc_latch is TRUE. The latched CRC value is compared with the input CRC value when compare asserts.</note>
				</param>
				<param id="polyParam">
					<name>polynomial</name>			
					<values>
						<value default="yes">5'b00101</value>
					</values>
					<note>Normal representation of the CRC generator polynomial.&#10;Equal to the concatenation of the polynomial coefficients in descending order, skipping the high-order coefficient.&#10;&#10;For example, the polynomial value representing: x^16+x^12+x^5+1 is 4h'1021 (16'b0001 0000 0010 0001).&#10;Default: 5'b00101 (x^5+x^2+1)</note>
				</param>	
				<param id="polyStandardParam">
					<name>standard_polynomial</name>			
					<values>
						<value default="yes">1</value>
						<value>2</value>					
						<value>3</value>					
						<value>4</value>					
						<value>5</value>											
					</values>
					<note>Polynomial to use if polynomial is 0:&#10;1 - CRC-5-USB (2'h05)&#10;2 - CRC-7 (2'h09)&#10;3 - CRC-16-CCITT (4'h1021)&#10;4 - CRC-32-IEEE802.3 (8'h04C11DB7)&#10;5 - CRC-64-ISO (16'h000000000000001B)</note>
				</param>	
				<param id="initParam">
					<name>initial_value</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>	
						<value>2</value>	
						<value>3</value>							
					</values>
					<note>Initial value of the internal CRC register.&#10;&#10;initial_value = 0 (Default) All 0's, for example: 8'h00000000.&#10;initial_value = 1 All 1's, for example: 8'b11111111.&#10;initial_value = 2 Alternating 10's, for example: 8'b10101010.&#10;initial_value = 3 Alternating 01's, for example: 8'b01010101.</note>
				</param>	
				<param id="lsbParam">
					<name>lsb_first</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>						
					</values>
					<note>Bit order in the CRC register.&#10;&#10;lsb_first = 0 (Default) MSB first bit order.&#10;lsb_first = 1 LSB first bit order (i.e., reflected).</note>
				</param>	
				<param id="bigEndParam">
					<name>big_endian</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>Byte order of a message data item.&#10;&#10;big_endian = 0 (Default) Little-endian byte order.&#10;big_endian = 1 Big-endian byte order.</note>
				</param>	
				<param id="reverseEndParam">
					<name>reverse_endian</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>Byte order in the CRC value.&#10;&#10;reverse_endian = 0 (Default) Byte order is the same as the byte order of a message data item (i.e., same as the big_endian parameter).&#10;reverse_endian = 1 Byte order is the opposite of the byte order of a message data item (i.e., inverse of big_endian parameter).</note>
				</param>	
				<param id="invertParam">
					<name>invert</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>Sense of the input CRC value.&#10;&#10;invert = 0 (Default) Input CRC value is the CRC checksum.&#10;invert = 1 Input CRC value is the inverted CRC checksum.</note>
				</param>	
				<param id="combParam">
					<name>combinational</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>Type of logic used to calculate CRC values.&#10;&#10;combinational = 0 (Default) CRC is calculated sequentially. The input CRC value is the CRC checksum for the previous cycle.&#10;combinational = 1 CRC is calculated combinationally. The input CRC value is the CRC checksum for the current cycle.</note>
				</param>					
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>				
				<port direction="input">
				   <name>test_expr</name>
				   <packed>width-1 : 0</packed>
				</port>
				<port direction="input">
					<name>initialize</name>
				</port>				
				<port direction="input">
					<name>valid</name>
				</port>				
				<port direction="input">
					<name>compare</name>
				</port>	
				<port direction="input">
				   <name>crc</name>
				   <packed>crc_width-1 : 0</packed>
				</port>	
				<port direction="input">
					<name>crc_latch</name>
				</port>					
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>	
		<checker vhdl_support="full" verilog_support="full">
			<name>ovl_cycle_sequence</name>
			<note>Checks that if a specified necessary condition occurs, it is followed by a specified sequence of events.</note>
			<file_path>ovl_cycle_sequence.v</file_path>
			<diagram>diagram_ovl_cycle_sequence.gif</diagram>
			<syntax>ovl_cycle_sequence [#(severity_level, num_cks, necessary_condition, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, event_sequence, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>					
				<param id="numCksParam" type="number">
					<name>num_cks</name>			
					<values>
						<value default="yes">2</value>
					</values>
					<note>Width of the event_sequence argument. This parameter must not be less than 2.&#10;&#10;Default: 2.</note>
				</param>
				<param id="condParam">
					<name>necessary_condition</name>			
					<values>
						<value abs="0" default="yes">`OVL_TRIGGER_ON_MOST_PIPE</value>
						<value abs="1">`OVL_TRIGGER_ON_FIRST_PIPE</value>
						<value abs="2">`OVL_TRIGGER_ON_FIRST_NOPIPE</value>
					</values>
					<note>Method for determining the necessary condition that initiates the sequence check and whether or not to pipeline checking.&#10;&#10;Values are: OVL_TRIGGER_ON_MOST_PIPE (default), OVL_TRIGGER_ON_FIRST_PIPE and OVL_TRIGGER_ON_FIRST_NOPIPE.</note>
				</param>				
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>		
				<port direction="input">
				   <name>event_sequence</name>
				   <packed>num_cks-1:0</packed>
				</port>	
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>					
			</ports>
		</checker>	
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_decrement</name>
			<note>Checks that the value of an expression changes only by the specified decrement value.</note>
			<file_path>ovl_decrement.v</file_path>
			<diagram>diagram_ovl_decrement.gif</diagram>
			<syntax>ovl_decrement [#(severity_level, width, value, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr argument.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="valueParam" type="number">
					<name>value</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Decrement value for test_expr.&#10;&#10;Default: 1.</note>
				</param>	
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>				
				<port direction="input">
				   <name>test_expr</name>
				   <packed>width-1 : 0</packed>
				</port>
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>		
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_delta</name>
			<note>Checks that the value of an expression changes only by a value in the specified range.</note>
			<file_path>ovl_delta.v</file_path>
			<diagram>diagram_ovl_delta.gif</diagram>
			<syntax>ovl_delta [#(severity_level, width, min, max, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr argument.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="minParam" type="number">
					<name>min</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Minimum delta value allowed for test_expr.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="maxParam" type="number">
					<name>max</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Maximum delta value allowed for test_expr.&#10;&#10;Default: 1.</note>
				</param>
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>				
				<port direction="input">
				   <name>test_expr</name>
				   <packed>width-1 : 0</packed>
				</port>
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>		
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_even_parity</name>
			<note>Checks that the value of an expression has even parity.</note>
			<file_path>ovl_even_parity.v</file_path>
			<diagram>diagram_ovl_even_parity.gif</diagram>
			<syntax>ovl_even_parity [#(severity_level, width, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr argument.&#10;&#10;Default: 1.</note>
				</param>	
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>				
				<port direction="input">
				   <name>test_expr</name>
				   <packed>width-1 : 0</packed>
				</port>
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>	
		<checker vhdl_support="none">
			<name>ovl_fifo</name>
			<note>Checks the data integrity of a FIFO and checks that the FIFO does not overflow or underflow.</note>
			<file_path>ovl_fifo.v</file_path>
			<diagram>diagram_ovl_fifo.gif</diagram>
			<syntax>ovl_fifo [#(severity_level, depth, width, high_water_mark, enq_latency, deq_latency, value_check, pass_thru, registered, preload_count, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, enq, enq_data, deq, deq_data, full, empty, preload, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of a data item.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="depthParam" type="number">
					<name>depth</name>			
					<values>
						<value default="yes">2</value>
					</values>
					<note>FIFO depth. The depth must be &gt; 0.&#10;&#10;Default: 2.</note>
				</param>	
				<param id="passParam">
					<name>pass_thru</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>How the FIFO handles a dequeue and enqueue in the same cycle if the FIFO is empty.&#10;&#10;pass_thru = 0 (Default) No pass-through mode. Simultaneous dequeue/enqueue of an empty FIFO is an dequeue violation.&#10;pass_thru = 1 Pass-through mode. Enqueue happens before the dequeue. Simultaneous enqueue/dequeue of an empty FIFO is not a dequeue violation.</note>
				</param>
				<param id="regParam">
					<name>registered</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>How the FIFO handles an enqueue and dequeue in the same cycle if the FIFO is full.&#10;&#10;registered = 0 (Default) No registered mode. Simultaneous enqueue/dequeue of a full FIFO is an enqueue violation.&#10;registered = 1 Registered mode. Dequeue happens before the enqueue. Simultaneous enqueue/dequeue of a full FIFO is not an enqueue violation.</note>
				</param>
				<param id="enqParam" type="number">
					<name>enq_latency</name>			
					<values>						
						<value default="yes">0</value>
					</values>
					<note>Latency for enqueue data.&#10;&#10;enq_latency = 0 (Default) Checks and coverage assume enq_data is valid and the enqueue operation is performed in the same cycle enq asserts.&#10;enq_latency &gt; 0 Checks and coverage assume enq_data is valid and the enqueue operation is performed enq_latency cycles after enq asserts.</note>
				</param>
				<param id="deqParam" type="number">
					<name>deq_latency</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Latency for dequeued data.&#10;&#10;deq_latency = 0 (Default) Checks and coverage assume deq_data is valid and the dequeue operation is performed in the same cycle deq asserts.&#10;deq_latency &gt; 0 Checks and coverage assume deq_data is valid and the dequeue operation is performed deq_latency cycles after deq asserts.</note>
				</param>	
				<param id="preParam" type="number">
					<name>preload_count</name>			
					<values>
						<value default="yes">0</value>				
					</values>
					<note>Number of items to preload the FIFO on reset. The preload port is a concatenated list of items to be preloaded into the FIFO.&#10;&#10;Default: 0 (FIFO empty on reset).</note>
				</param>	
				<param id="waterParam" type="number">
					<name>high_water_mark</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>FIFO high-water mark. Must be &lt; depth. A value of 0 disables the high-water mark cover point.&#10;&#10;Default: 0.</note>
				</param>	
				<param id="valueParam">
					<name>value_check</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>Whether or not to perform value checks.&#10;&#10;value_check = 0 (Default) Turns off the value check.&#10;value_check = 1 Turns on the value check.</note>
				</param>					
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>		
				<port direction="input">
					<name>enq</name>
				</port>					
				<port direction="input">
				   <name>enq_data</name>
				   <packed>width-1 : 0</packed>
				</port>
				<port direction="input">
				   <name>deq</name>
				</port>
				<port direction="input">
				   <name>deq_data</name>
				   <packed>width-1 : 0</packed>
				</port>		
				<port direction="input">
					<name>full</name>
				</port>		
				<port direction="input">
					<name>empty</name>
				</port>						
				<port direction="input">
				   <name>preload</name>
				   <packed>preload_count*width-1 : 0</packed>
				</port>
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>			
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_fifo_index</name>
			<note>Checks that a FIFO-type structure never overflows or underflows. This checker can be configured to support multiple pushes (FIFO writes) and pops (FIFO reads) during the same clock cycle.</note>
			<file_path>ovl_fifo_index.v</file_path>
			<diagram>diagram_ovl_fifo_index.gif</diagram>
			<syntax>ovl_fifo_index [#(severity_level, depth, push_width, pop_width, simultaneous_push_pop, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, push, pop, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>					
				<param id="depthParam" type="number">
					<name>depth</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Maximum number of elements in the FIFO or queue structure. This parameter must be > 0.&#10;&#10;Default: 1.</note>
				</param>
				<param id="pushParam" type="number">
					<name>push_width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the push argument.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="popParam" type="number">
					<name>pop_width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the pop argument.&#10;&#10;Default: 1.</note>
				</param>
				<param id="simParam" type="number">
					<name>simultaneous_push_pop</name>			
					<values>
					    <value>0</value>
						<value default="yes">1</value>
					</values>
					<note>Whether or not to allow simultaneous push/pop operations in the same clock cycle.&#10;When set to 0, if push and pop operations occur in the same cycle, the assertion fails.&#10;&#10;Default: 1 (simultaneous push/pop operations are allowed).</note>
				</param>				
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>		
				<port direction="input">
				   <name>push</name>
				   <packed>push_width-1:0</packed>
				</port>	
				<port direction="input">
				   <name>pop</name>
				   <packed>pop_width-1:0</packed>
				</port>	
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>	
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_frame</name>
			<note>Checks that when a specified start event is TRUE, then an expression must not evaluate TRUE before a minimum number of clock cycles and must transition to TRUE no later than a maximum number of clock cycles.</note>
			<file_path>ovl_frame.v</file_path>
			<diagram>diagram_ovl_frame.gif</diagram>
			<syntax>ovl_fifo_index [#(severity_level, depth, push_width, pop_width, simultaneous_push_pop, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, push, pop, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>					
				<param id="minParam" type="number">
					<name>min_cks</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Number of cycles after the start event that test_expr must not evaluate to TRUE.&#10;The special case where min_cks is 0 turns off minimum checking (i.e., test_expr can be TRUE in the cycle following the start event).&#10;&#10;Default: 0.</note>
				</param>
				<param id="maxParam" type="number">
					<name>max_cks</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Number of cycles after the start event that during which test_expr must transition to TRUE.&#10;The special case where max_cks is 0 turns off maximum checking (i.e., test_expr does not need to transition to TRUE).&#10;&#10;Default: 0.</note>
				</param>	
				<param id="actionParam">
					<name>action_on_new_start</name>			
					<values>
						<value abs="0" default="yes">`OVL_IGNORE_NEW_START</value>
						<value abs="1">`OVL_RESET_ON_NEW_START</value>
						<value abs="2">`OVL_ERROR_ON_NEW_START</value>
					</values>
					<note>Method for handling a new start event that occurs while a check is pending.&#10;Values are: OVL_IGNORE_NEW_START, OVL_RESET_ON_NEW_START and OVL_ERROR_ON_NEW_START.&#10;&#10;Default: OVL_IGNORE_NEW_START.</note>
				</param>
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>		
				<port direction="input">
				   <name>start_event</name>
				</port>	
				<port direction="input">
				   <name>test_expr</name>
				</port>	
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>	
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_handshake</name>
			<note>Checks that specified request and acknowledge signals follow a specified handshake protocol.</note>
			<file_path>ovl_handshake.v</file_path>
			<diagram>diagram_ovl_handshake.gif</diagram>
			<syntax>ovl_handshake [#(severity_level, min_ack_cycle, max_ack_cycle, req_drop, deassert_count, max_ack_length, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, req, ack, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="minParam" type="number">
					<name>min_ack_cycle</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Minimum number of clock cycles before acknowledge. A value of 0 turns off the ack min cycle check.&#10;&#10;Default: 0.</note>
				</param>	
				<param id="maxParam" type="number">
					<name>max_ack_cycle</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Maximum number of clock cycles before acknowledge. A value of 0 turns off the ack max cycle check.&#10;&#10;Default: 0.</note>
				</param>	
				<param id="reqParam" type="number">
					<name>req_drop</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>If greater than 0, value of req must remain TRUE until acknowledge. A value of 0 turns off the req drop check.&#10;&#10;Default: 0.</note>
				</param>
				<param id="assertParam" type="number">
					<name>deassert_count</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Maximum number of clock cycles after acknowledge that req can remain TRUE (i.e., req must not be stuck active). A value of 0 turns off the req deassert check.&#10;&#10;Default: 0.</note>
				</param>
				<param id="lenParam">
					<name>max_ack_length</name>			
					<values>				
						<value default="yes">0</value>
					</values>
					<note>Maximum number of clock cycles that ack can be TRUE. A value of 0 turns off the max ack length check.&#10;&#10;Default: 0.</note>
				</param>
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>				
				<port direction="input">
				   <name>req</name>
				</port>
				<port direction="input">
				   <name>ack</name>
				</port>
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>	
		<checker vhdl_support="none">
			<name>ovl_hold_value</name>
			<note>Checks that once an expression matches the value of a second expression, the first expression does not change value until a specified event window arrives and then changes value some time in that window.</note>
			<file_path>ovl_hold_value.v</file_path>
			<diagram>diagram_ovl_hold_value.gif</diagram>
			<syntax>ovl_hold_value [#(severity_level, min, max, width, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, value, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">2</value>
					</values>
					<note>Width of test_expr and value.&#10;&#10;Default: 2.</note>
				</param>	
				<param id="minParam" type="number">
					<name>min</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Number of cycles after the value match that the event window opens.&#10;&#10;Default: 0 (test_expr can change value in any cycle).</note>
				</param>	
				<param id="maxParam" type="number">
					<name>max</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Number of cycles after the value match that the event window closes.&#10;&#10;But if max = 0, no event window opens and there are the following special cases:&#10;min = 0 and max = 0 When test_expr and value match, test_expr must change value in the next cycle.&#10;min &gt; 0 and max = 0 When test_expr and value match, test_expr must not change value in the next min-1 cycles.&#10;Default: 0.</note>
				</param>
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>				
				<port direction="input">
				   <name>test_expr</name>
				   <packed>width-1 : 0</packed>
				</port>
				<port direction="input">
				   <name>value</name>
				   <packed>width-1 : 0</packed>
				</port>
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>			
		<checker vhdl_support="full" verilog_support="full">
			<name>ovl_implication</name>
			<note>Checks that a specified consequent expression is TRUE if the specified antecedent expression is TRUE.</note>
			<file_path>ovl_implication.v</file_path>
			<diagram>diagram_ovl_implication.gif</diagram>
			<syntax>ovl_implication [#(severity_level, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, antecedent_expr, consequent_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>				
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>		
				<port direction="input">
				   <name>antecedent_expr</name>
				</port>	
				<port direction="input">
				   <name>consequent_expr</name>
				</port>	
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>					
			</ports>
		</checker>					
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_increment</name>
			<note>Checks that the value of an expression changes only by the specified increment value.</note>
			<file_path>ovl_increment.v</file_path>
			<diagram>diagram_ovl_increment.gif</diagram>
			<syntax>ovl_increment [#(severity_level, width, value, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>				
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr argument.&#10;&#10;Default: 1.</note>
				</param>			
				<param id="valueParam" type="number">
					<name>value</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Increment value for test_expr.&#10;&#10;Default: 1.</note>
				</param>							
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
				   <name>test_expr</name>
				   <packed>width-1:0</packed>
				</port>					
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>					
			</ports>			
		</checker>
		<checker vhdl_support="none">
			<name>ovl_memory_async</name>
			<note>Checks the integrity of accesses to an asynchronous memory.</note>
			<file_path>ovl_memory_async.v</file_path>
			<diagram>diagram_ovl_memory_async.gif</diagram>
			<syntax>ovl_memory_async [#(severity_level, data_width, addr_width, mem_size, addr_check, init_check, one_read_check, one_write_check, value_check, property_type, msg, coverage_level, wen_edge, ren_edge, reset_polarity, gating_type)] instance_name (reset, enable, start_addr, end_addr, ren, raddr, rdata, wen, waddr, wdata, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockReadParam"/>
				<param_ref id="clockWriteParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="dataWidthParam" type="number">
					<name>data_width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Number of bits in a data item.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="addWidthParam" type="number">
					<name>addr_width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Number of bits in an address.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="memParam" type="number">
					<name>mem_size</name>			
					<values>
						<value default="yes">2</value>
					</values>
					<note>Number of data items in the memory.&#10;&#10;Default: 2.</note>
				</param>
				<param id="addrCheckParam">
					<name>addr_check</name>			
					<values>
						<value>0</value>
						<value default="yes">1</value>						
					</values>
					<note>Whether or not to perform address checks.&#10;&#10;addr_check = 0 Turns off the address check.&#10;addr_check = 1 (Default) Turns on the address check.</note>
				</param>
				<param id="initCheckParam">
					<name>init_check</name>			
					<values>
						<value>0</value>						
						<value default="yes">1</value>
					</values>
					<note>Whether or not to perform initialization checks.&#10;&#10;init_check = 0 Turns off the initialization check.&#10;init_check = 1 (Default) Turns on the initialization check.</note>
				</param>
				<param id="readParam">
					<name>one_read_check</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>Whether or not to perform one_read checks.&#10;&#10;one_read_check = 0 (Default) Turns off the one_read check&#10;one_read_check = 1 Turns on the one_read check.</note>
				</param>	
				<param id="writeParam">
					<name>one_write_check</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>					
					</values>
					<note>Whether or not to perform one_write checks.&#10;&#10;one_write_check = 0 (Default) Turns off the one_write check.&#10;one_write_check = 1 Turns on the one_write check.</note>
				</param>					
				<param id="valueParam">
					<name>value_check</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>					
					</values>
					<note>Whether or not to perform value checks.&#10;&#10;value_check = 0 (Default) Turns off the value check.&#10;value_check = 1 Turns on the value check.</note>
				</param>					
			</params>
			<ports>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>				
				<port direction="input">
				   <name>start_addr</name>
				</port>
				<port direction="input">
				   <name>end_addr</name>
				</port>
				<port direction="input">
				   <name>ren</name>
				</port>
				<port direction="input">
				   <name>raddr</name>
				</port>
				<port direction="input">
				   <name>rdata</name>
				</port>
				<port direction="input">
				   <name>wen</name>
				</port>
				<port direction="input">
				   <name>waddr</name>
				</port>
				<port direction="input">
				   <name>wdata</name>
				</port>				
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>			
		<checker vhdl_support="none">
			<name>ovl_memory_sync</name>
			<note>Checks the integrity of accesses to a synchronous memory.</note>
			<file_path>ovl_memory_sync.v</file_path>
			<diagram>diagram_ovl_memory_sync.gif</diagram>
			<syntax>ovl_memory_sync [#(severity_level, data_width, addr_width, mem_size, addr_check, init_check, conflict_check, pass_thru, one_read_check, one_write_check, value_check, property_type, msg, coverage_level, wen_edge, ren_edge, reset_polarity, gating_type)] instance_name (reset, enable, start_addr, end_addr, r_clock, ren, raddr, rdata, w_clock, wen, waddr, wdata, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockReadParam"/>
				<param_ref id="clockWriteParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="dataWidthParam" type="number">
					<name>data_width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Number of bits in a data item.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="addWidthParam" type="number">
					<name>addr_width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Number of bits in an address.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="memParam" type="number">
					<name>mem_size</name>			
					<values>
						<value default="yes">2</value>
					</values>
					<note>Number of data items in the memory.&#10;&#10;Default: 2.</note>
				</param>
				<param id="passParam">
					<name>pass_thru</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>How the memory handles a simultaneous read and write access to the same address.&#10;This parameter applies to the initialization and value checks.&#10;&#10;pass_thru = 0 (Default) No pass-through mode (i.e., read before write).&#10;Simultaneous read/write access to the same location should return the current data item as the read data.&#10;pass_thru = 1 Pass-through mode (i.e., write before read).&#10;Simultaneous read/write access to the same location should return the new data item as the read data.&#10;Only specify pass-through mode if r_clock === w_clock and conflict_check = 0.</note>
				</param>				
				<param id="addrCheckParam">
					<name>addr_check</name>			
					<values>
						<value>0</value>
						<value default="yes">1</value>						
					</values>
					<note>Whether or not to perform address checks.&#10;&#10;addr_check = 0 Turns off the address check.&#10;addr_check = 1 (Default) Turns on the address check.</note>
				</param>
				<param id="initCheckParam">
					<name>init_check</name>			
					<values>
						<value>0</value>						
						<value default="yes">1</value>
					</values>
					<note>Whether or not to perform initialization checks.&#10;&#10;init_check = 0 Turns off the initialization check.&#10;init_check = 1 (Default) Turns on the initialization check.</note>
				</param>
				<param id="conflictParam">
					<name>conflict_check</name>			
					<values>
						<value default="yes">0</value>						
						<value>1</value>
					</values>
					<note>Whether or not to perform conflict checks.&#10;&#10;conflict_check = 0 (Default) Turns off the conflict check.&#10;conflict_check = 1 Turns on the conflict check. Only select the conflict check if r_clock === w_clock.</note>
				</param>				
				<param id="readParam">
					<name>one_read_check</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>Whether or not to perform one_read checks.&#10;&#10;one_read_check = 0 (Default) Turns off the one_read check&#10;one_read_check = 1 Turns on the one_read check.</note>
				</param>	
				<param id="writeParam">
					<name>one_write_check</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>					
					</values>
					<note>Whether or not to perform one_write checks.&#10;&#10;one_write_check = 0 (Default) Turns off the one_write check.&#10;one_write_check = 1 Turns on the one_write check.</note>
				</param>					
				<param id="valueParam">
					<name>value_check</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>					
					</values>
					<note>Whether or not to perform value checks.&#10;&#10;value_check = 0 (Default) Turns off the value check.&#10;value_check = 1 Turns on the value check.</note>
				</param>					
			</params>
			<ports>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>				
				<port direction="input">
				   <name>start_addr</name>
				</port>
				<port direction="input">
				   <name>end_addr</name>
				</port>
				<port direction="input">
				   <name>r_clock</name>
				</port>				
				<port direction="input">
				   <name>ren</name>
				</port>
				<port direction="input">
				   <name>raddr</name>
				</port>
				<port direction="input">
				   <name>rdata</name>
				</port>
				<port direction="input">
				   <name>w_clock</name>
				</port>				
				<port direction="input">
				   <name>wen</name>
				</port>
				<port direction="input">
				   <name>waddr</name>
				</port>
				<port direction="input">
				   <name>wdata</name>
				</port>				
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>					
		<checker vhdl_support="none">
			<name>ovl_multiport_fifo</name>
			<note>Checks the data integrity of a FIFO with multiple enqueue and dequeue ports, and checks that the FIFO does not overflow or underflow.</note>
			<file_path>ovl_multiport_fifo.v</file_path>
			<diagram>diagram_ovl_multiport_fifo.gif</diagram>
			<syntax>ovl_multiport_fifo [#(severity_level, width, depth, enq_count, deq_count, preload_count, pass_thru, registered, high_water_mark, enq_latency, deq_latency, value_check, full_check, empty_check, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, enq, deq, enq_data, deq_data, full, empty, preload, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of a data item in the FIFO.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="depthParam" type="number">
					<name>depth</name>			
					<values>
						<value default="yes">2</value>
					</values>
					<note>FIFO depth. The depth must be &gt; 0.&#10;&#10;Default: 2.</note>
				</param>	
				<param id="enqParam" type="number">
					<name>enq_count</name>			
					<values>
						<value default="yes">2</value>
					</values>
					<note>Number of FIFO enqueue ports. Must be &lt;= depth. Default: 2.</note>
				</param>
				<param id="deqParam" type="number">
					<name>deq_count</name>			
					<values>
						<value default="yes">2</value>
					</values>
					<note>Number of FIFO dequeue ports. Must be &lt;= depth. Default: 2.</note>
				</param>				
				<param id="passParam">
					<name>pass_thru</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>How the FIFO handles dequeues and enqueues in the same cycle if the FIFO count is such that a dequeue violation might occur.&#10;&#10;pass_thru = 0 (Default) No pass-through mode means dequeue before enqueue.&#10;A dequeue violation occurs if the number of scheduled dequeues &gt; the current FIFO count.&#10;pass_thru = 1 Pass-through mode means enqueue before dequeue.&#10;A dequeue violation occurs if the number of scheduled dequeues - the number of scheduled enqueues &gt; the current FIFO count.</note>
				</param>				
				<param id="regParam">
					<name>registered</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>						
					</values>
					<note>How the FIFO handles dequeues and enqueues in the same cycle if the FIFO count is such that an enqueue violation might occur.&#10;&#10;registered = 0 (Default) No registered mode means enqueue before dequeue.&#10;An enqueue violation occurs if the current FIFO count + the number of scheduled enqueues &gt; depth.&#10;registered = 1 Registered mode means dequeue before enqueue.&#10;An enqueue violation occurs if the current FIFO count + the number of scheduled enqueues - the number scheduled dequeues &gt; depth.</note>
				</param>
				<param id="enqLateParam" type="number">
					<name>enq_latency</name>			
					<values>					
						<value default="yes">0</value>
					</values>
					<note>Latency for enqueue data.&#10;&#10;enq_latency = 0 (Default) Checks and coverage assume enq_data is valid and the enqueue operation is performed in the same cycle enq asserts.&#10;enq_latency &gt; 0 Checks and coverage assume enq_data is valid and the enqueue operation is performed enq_latency cycles after enq asserts.</note>
				</param>
				<param id="deqLateParam" type="number">
					<name>deq_latency</name>			
					<values>
						<value default="yes">0</value>						
					</values>
					<note>Latency for dequeued data. It is used for the value check.&#10;&#10;deq_latency = 0 (Default) Checks and coverage assume deq_data is valid and the dequeue operation is performed in the same cycle deq asserts.&#10;deq_latency &gt; 0 Checks and coverage assume deq_data is valid and the dequeue operation is performed deq_latency cycles after deq asserts.</note>
				</param>				
				<param id="preloadParam" type="number">
					<name>preload_count</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Number of items to preload the FIFO on reset. The preload port is a concatenated list of items to be preloaded into the FIFO.&#10;&#10;Default: 0 (FIFO empty on reset).</note>
				</param>	
				<param id="waterParam" type="number">
					<name>high_water_mark</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>FIFO high-water mark. Must be &lt; depth. A value of 0 disables the high_water_mark cover point.&#10;&#10;Default: 0.</note>
				</param>	
				<param id="fullParam">
					<name>full_check</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>Whether or not to perform full checks.&#10;&#10;full_check = 0 (Default) Turns off the full check.&#10;full_check = 1 Turns on the full check.</note>
				</param>
				<param id="emptyParam">
					<name>empty_check</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>Whether or not to perform empty checks.&#10;&#10;empty_check = 0 (Default) Turns off the empty check.&#10;empty_check = 1 Turns on the empty check.</note>
				</param>				
				<param id="valueParam">
					<name>value_check</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>					
					</values>
					<note>Whether or not to perform value checks.&#10;&#10;value_check = 0 (Default) Turns off the value check.&#10;value_check = 1 Turns on the value check.</note>
				</param>					
			</params>
			<ports>
				<port direction="input">
					<name>clock</name>
				</port>			
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>				
				<port direction="input">
				   <name>enq</name>
				    <packed>enq_count-1 : 0</packed>
				</port>
				<port direction="input">
				   <name>deq</name>
				    <packed>deq_count-1 : 0</packed>
				</port>
				<port direction="input">
				   <name>full</name>
				</port>				
				<port direction="input">
				   <name>empty</name>
				</port>
				<port direction="input">
				   <name>enq_data</name>
				    <packed>enq_count*width-1 : 0</packed>
				</port>
				<port direction="input">
				   <name>deq_data</name>
				   <packed>deq_count*width-1 : 0</packed>
				</port>
				<port direction="input">
				   <name>preload</name>
				   <packed>preload_count*width-1 : 0</packed>
				</port>				
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>							
		<checker vhdl_support="none">
			<name>ovl_mutex</name>
			<note>Checks that the bits of an expression are mutually exclusive.</note>
			<file_path>ovl_mutex.v</file_path>
			<diagram>diagram_ovl_mutex.gif</diagram>
			<syntax>ovl_mutex [#(severity_level, width, invert_mode, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, fire);</syntax>			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">2</value>
					</values>
					<note>Width of test_expr.&#10;&#10;Default: 2.</note>
				</param>	
				<param id="modeParam">
					<name>invert_mode</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>Sense of the active bits for the mutex check.&#10;&#10;invert_mode = 0 (Default) Expression value must not have more than one TRUE bit.&#10;invert_mode = 1 Expression value must not have more than one FALSE bit.</note>
				</param>	
			</params>
			<ports>
				<port direction="input">
					<name>clock</name>
				</port>			
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>				
				<port direction="input">
				   <name>test_expr</name>
				    <packed>width-1 : 0</packed>
				</port>
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>									
		<checker vhdl_support="full" verilog_support="full">
			<name>ovl_never</name>
			<note>Checks that the value of an expression is not TRUE.</note>
			<file_path>ovl_never.v</file_path>
			<diagram>diagram_ovl_never.gif</diagram>
			<syntax>ovl_never [#(severity_level, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type )] instance_name (clock, reset, enable, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>		
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>				
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
				   <name>test_expr</name>
				</port>					
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>	
		<checker vhdl_support="full" verilog_support="full">
			<name>ovl_never_unknown</name>
			<note>Checks that the value of an expression contains only 0 and 1 bits when a qualifying expression is TRUE.</note>
			<file_path>ovl_never_unknown.v</file_path>
			<diagram>diagram_ovl_never_unknown.gif</diagram>
			<syntax>ovl_never_unknown [#(severity_level, width, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type )] instance_name (clock, reset, enable, qualifier, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>		
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>					
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr argument.&#10;&#10;Default: 1.</note>
				</param>				
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
					<name>qualifier</name>
				</port>				
				<port direction="input">
				   <name>test_expr</name>
				   <packed>width-1:0</packed>				   
				</port>					
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>	
		<checker vhdl_support="full" verilog_support="full">
			<name>ovl_never_unknown_async</name>
			<note>Checks that the value of an expression combinationally contains only 0 and 1 bits.</note>
			<file_path>ovl_never_unknown_async.v</file_path>
			<diagram>diagram_ovl_never_unknown_async.gif</diagram>
			<syntax>ovl_never_unknown_async [#(severity_level, width, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (reset, enable, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>		
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>					
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr argument.&#10;&#10;Default: 1.</note>
				</param>				
			</params>
			<ports>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>				
				<port direction="input">
				   <name>test_expr</name>
				   <packed>width-1:0</packed>				   
				</port>					
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>			
		<checker vhdl_support="full" verilog_support="full">
			<name>ovl_next</name>
			<note>Checks that the value of an expression is TRUE a specified number of cycles after a start event.</note>
			<file_path>ovl_next.v</file_path>
			<diagram>diagram_ovl_next.gif</diagram>
			<syntax>ovl_next [#(severity_level, num_cks, check_overlapping, check_missing_start, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, start_event, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>					
				<param id="cksParam" type="number">
					<name>num_cks</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Number of cycles after start_event is TRUE to wait to check that the value of test_expr is TRUE.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="overParam" type="number">
					<name>check_overlapping</name>			
					<values>
					    <value>0</value>
						<value default="yes">1</value>
					</values>
					<note>Whether or not to perform overlap checking.&#10;&#10;Default: 1 (overlap checking off).&#10;- If set to 0, overlap checking is performed.&#10;From the active edge of clock after start_event is sampled TRUE to the active edge of clock of the cycle before test_expr is sampled for the current next check, the checker performs an overlap check.&#10;During this interval, if start_event is TRUE at an active edge of clock, then the overlap check fails (illegal overlapping condition).&#10;- If set to 1, overlap checking is not performed.</note>
				</param>				
				<param id="missParam" type="number">
					<name>check_missing_start</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>Whether or not to perform missing-start checking.&#10;&#10;Default: 0 (missing-start checking off).&#10;- If set to 0, missing start checks are not performed.&#10;- If set to 1, missing start checks are performed.&#10;&#10;The checker samples test_expr every active edge of clock.&#10;If the value of test_expr is TRUE, then num_cks active edges of clock prior to the current time, start_event must have been TRUE (initiating a next check).&#10;If not, the missing-start check fails (start_event without test_expr).</note>
				</param>								
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
					<name>start_event</name>
				</port>				
				<port direction="input">
				   <name>test_expr</name>			   
				</port>					
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>	
		<checker vhdl_support="none">
			<name>ovl_next_state</name>
			<note>Checks that an expression transitions only to specified values.</note>
			<file_path>ovl_next_state.v</file_path>
			<diagram>diagram_ovl_next_state.gif</diagram>
			<syntax>ovl_next_state [#(severity_level, next_count, width, min_hold, max_hold, disallow, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, curr_state, next_state, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>					
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of test_expr.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="nextParam" type="number">
					<name>next_count</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Number of next state values. The next_state port is a concatenated list of next state values.&#10;&#10;Default: 1.</note>
				</param>				
				<param id="minParam" type="number">
					<name>min_hold</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Minimum number of cycles test_expr must not change value when it matches the value of curr_state. Must be &gt; 0.&#10;&#10;Default: 1.</note>
				</param>
				<param id="maxParam" type="number">
					<name>max_hold</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Maximum number of cycles test_expr can remain unchanged when it matches the value of curr_state. A value of 0 turns off checking for a maximum hold time. Must be 0 or &gt; min_hold.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="disParam">
					<name>disallow</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>Sense of the comparison of test_expr with next_state.&#10;&#10;disallow = 0 (Default) Next value of test_expr should match one of the values in next_state.&#10;disallow = 1 Next value of test_expr should not match one of the values in next_state.</note>
				</param>	
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>												
				<port direction="input">
					<name>test_expr</name>	
					<packed>width-1 : 0</packed>				   
				</port>		
				<port direction="input">
					<name>curr_state</name>
					<packed>width-1 : 0</packed>
				</port>	
				<port direction="input">
				   <name>next_state</name>		
					<packed>next_count*width-1 : 0</packed>				   
				</port>					
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>			
		<checker vhdl_support="none">
			<name>ovl_no_contention</name>
			<note>Checks that a bus is driven according to specified contention rules.</note>
			<file_path>ovl_no_contention.v</file_path>
			<diagram>diagram_ovl_no_contention.gif</diagram>
			<syntax>ovl_no_contention [#(severity_level, min_quiet, max_quiet, num_drivers, width, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, driver_enables, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>					
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">2</value>
					</values>
					<note>Width of test_expr.&#10;&#10;Default: 2.</note>
				</param>	
				<param id="driversParam" type="number">
					<name>num_drivers</name>			
					<values>
						<value default="yes">2</value>
					</values>
					<note>Width of driver_enables.&#10;&#10;Default: 2.</note>
				</param>				
				<param id="minParam" type="number">
					<name>min_quiet</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Minimum number of cycles the bus must be quiet (i.e., when all driver_enables bits are 0) between transactions.&#10;&#10;Default: 0 (quiet periods between transactions are not necessary).</note>
				</param>
				<param id="maxParam" type="number">
					<name>max_quiet</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Maximum number of cycles the bus can be quiet (i.e., when all driver_enables bits are 0). The min_quiet parameter must be = max_quiet.&#10;&#10;Default: 0 (quiet periods between transactions should not occur).</note>
				</param>	
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>			
				<port direction="input">
					<name>enable</name>
				</port>					
				<port direction="input">
					<name>test_expr</name>	
					<packed>width-1 : 0</packed>				   
				</port>		
				<port direction="input">
					<name>driver_enables</name>
					<packed>num_drivers-1 : 0</packed>
				</port>	
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>					
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_no_overflow</name>
			<note>Checks that the value of an expression does not overflow.</note>
			<file_path>ovl_no_overflow.v</file_path>
			<diagram>diagram_ovl_no_overflow.gif</diagram>
			<syntax>ovl_no_overflow [#(severity_level, width, min, max, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>					
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr argument. Width must be less than or equal to 32.&#10;&#10;Default: 1.</note>
				</param>					
				<param id="minParam" type="number">
					<name>min</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Minimum value in the test range of test_expr.&#10;&#10;Default: 0.</note>
				</param>
				<param id="maxParam">
					<name>max</name>			
					<values>
						<value abs="1" default="yes">2**width - 1</value>
					</values>
					<note>Maximum value in the test range of test_expr.&#10;&#10;Default: 2**width - 1.</note>
				</param>	
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>		
				<port direction="input">
					<name>enable</name>
				</port>					
				<port direction="input">
					<name>test_expr</name>	
					<packed>width-1 : 0</packed>				   
				</port>		
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>							
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_no_transition</name>
			<note>Checks that the value of an expression does not transition from a start state to the specified next state.</note>
			<file_path>ovl_no_transition.v</file_path>
			<diagram>diagram_ovl_no_transition.gif</diagram>
			<syntax>ovl_no_transition [#(severity_level, width, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type )] instance_name (clock, reset, enable, test_expr, start_state, next_state, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>					
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr argument.&#10;&#10;Default: 1.</note>
				</param>						
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>		
				<port direction="input">
					<name>enable</name>
				</port>					
				<port direction="input">
					<name>test_expr</name>	
					<packed>width-1 : 0</packed>				   
				</port>	
				<port direction="input">
					<name>start_state</name>	
					<packed>width-1 : 0</packed>				   
				</port>	
				<port direction="input">
					<name>next_state</name>	
					<packed>width-1 : 0</packed>				   
				</port>	
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>									
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_no_underflow</name>
			<note>Checks that the value of an expression does not underflow.</note>
			<file_path>ovl_no_underflow.v</file_path>
			<diagram>diagram_ovl_no_underflow.gif</diagram>
			<syntax>ovl_no_underflow [#(severity_level, width, min, max, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>					
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr argument. Width must be less than or equal to 32.&#10;&#10;Default: 1.</note>
				</param>		
				<param id="minParam" type="number">
					<name>min</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Minimum value in the test range of test_expr.&#10;&#10;Default: 0.</note>
				</param>	
				<param id="maxParam">
					<name>max</name>			
					<values>
						<value abs="1" default="yes">2**width - 1</value>
					</values>
					<note>Maximum value in the test range of test_expr.&#10;&#10;Default: 2**width - 1.</note>
				</param>	
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>		
				<port direction="input">
					<name>enable</name>
				</port>					
				<port direction="input">
					<name>test_expr</name>	
					<packed>width-1 : 0</packed>				   
				</port>	
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>											
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_odd_parity</name>
			<note>Checks that the value of an expression has odd parity.</note>
			<file_path>ovl_odd_parity.v</file_path>
			<diagram>diagram_ovl_odd_parity.gif</diagram>
			<syntax>ovl_odd_parity [#(severity_level, width, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>					
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr argument.&#10;&#10;Default: 1.</note>
				</param>			
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>		
				<port direction="input">
					<name>enable</name>
				</port>					
				<port direction="input">
					<name>test_expr</name>	
					<packed>width-1 : 0</packed>				   
				</port>	
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>													
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_one_cold</name>
			<note>Checks that the value of an expression is one-cold (or equals an inactive state value, if specified).</note>
			<file_path>ovl_one_cold.v</file_path>
			<diagram>diagram_ovl_one_cold.gif</diagram>
			<syntax>ovl_one_cold [#(severity_level, width, inactive, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>					
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">32</value>
					</values>
					<note>Width of the test_expr argument.&#10;&#10;Default: 32.</note>
				</param>	
				<param id="inactiveParam">
					<name>inactive</name>			
					<values>
						<value abs="0">`OVL_ALL_ZEROS</value>
						<value abs="1">`OVL_ALL_ONES</value>
						<value abs="2" default="yes">`OVL_ONE_COLD</value>
					</values>
					<note>Inactive state of test_expr: OVL_ALL_ZEROS, OVL_ALL_ONES or OVL_ONE_COLD.&#10;&#10;Default: OVL_ONE_COLD.</note>
				</param>					
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>		
				<port direction="input">
					<name>enable</name>
				</port>					
				<port direction="input">
					<name>test_expr</name>	
					<packed>width-1 : 0</packed>				   
				</port>	
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>																	
		<checker vhdl_support="full" verilog_support="full">
			<name>ovl_one_hot</name>
			<note>Checks that the value of an expression is one-hot.</note>
			<file_path>ovl_one_hot.v</file_path>
			<diagram>diagram_ovl_one_hot.gif</diagram>
			<syntax>ovl_one_hot [#(severity_level, width, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>		
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>					
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">32</value>
					</values>
					<note>Width of the test_expr argument.&#10;&#10;Default: 32.</note>
				</param>									
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
				   <name>test_expr</name>		
				   <packed>width-1:0</packed>					   
				</port>					
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>							
			</ports>
		</checker>	
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_proposition</name>
			<note>Checks that the value of an expression is always combinationally TRUE.</note>
			<file_path>ovl_proposition.v</file_path>
			<diagram>diagram_ovl_proposition.gif</diagram>
			<syntax>ovl_proposition [#(severity_level, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (reset, enable, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>		
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
			</params>
			<ports>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
				   <name>test_expr</name>						   
				</port>					
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>						
			</ports>
		</checker>		
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_quiescent_state</name>
			<note>Checks that the value of a specified state expression equals a corresponding check value if a specified sample event has transitioned to TRUE.</note>
			<file_path>ovl_quiescent_state.v</file_path>
			<diagram>diagram_ovl_quiescent_state.gif</diagram>
			<syntax>ovl_quiescent_state [#(severity_level, width, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, state_expr, check_value, sample_event, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>		
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the state_expr and check_value arguments.&#10;&#10;Default: 1.</note>
				</param>				
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>			
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
					<name>state_expr</name>	
					<packed>width-1 : 0</packed>						   
				</port>					
				<port direction="input">
					<name>check_value</name>	
					<packed>width-1 : 0</packed>						   
				</port>					
				<port direction="input">
					<name>sample_event</name>	
				</port>									
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>						
			</ports>
		</checker>			
		<checker vhdl_support="full" verilog_support="full">
			<name>ovl_range</name>
			<note>Checks that the value of an expression is in a specified range.</note>
			<file_path>ovl_range.v</file_path>
			<diagram>diagram_ovl_range.gif</diagram>
			<syntax>ovl_range [#(severity_level, width, min, max, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>		
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr argument.&#10;&#10;Default: 1.</note>
				</param>				
				<param id="minParam" type="number">
					<name>min</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Minimum value allowed for test_expr.&#10;&#10;Default: 0.</note>
				</param>				
				<param id="maxParam">
					<name>max</name>			
					<values>
						<value abs="1" default="yes">2**width - 1</value>
					</values>
					<note>Maximum value allowed for test_expr.&#10;&#10;Default: 2**width - 1.</note>
				</param>								
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>			
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
					<name>test_expr</name>	
					<packed>width-1 : 0</packed>						   
				</port>					
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>						
			</ports>
		</checker>					
		<checker vhdl_support="none">
			<name>ovl_reg_loaded</name>
			<note>Checks that a register is loaded with source data within a specified time window.</note>
			<file_path>ovl_reg_loaded.v</file_path>
			<diagram>diagram_ovl_reg_loaded.gif</diagram>
			<syntax>ovl_reg_loaded [#(severity_level, width, start_count, end_count, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, start_event, end_event, src_expr, dest_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>		
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">4</value>
					</values>
					<note>Width of the src_expr and dest_expr registers.&#10;&#10;Default: 4.</note>
				</param>				
				<param id="startParam" type="number">
					<name>start_count</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Number of cycles after start_event asserts that the time window opens.&#10;&#10;Default: 1.</note>
				</param>				
				<param id="endParam" type="number">
					<name>end_count</name>			
					<values>
						<value default="yes">10</value>
					</values>
					<note>Number of cycles after start_event asserts that the time window closes (if it is still open). If end_count is 0, only the end_event signal is used to define the time windows.&#10;&#10;Default: 10.</note>
				</param>								
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>			
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
					<name>start_event</name>							   
				</port>		
				<port direction="input">
					<name>end_event</name>	
				</port>	
				<port direction="input">
					<name>src_expr</name>	
					<packed>width-1 : 0</packed>						   
				</port>	
				<port direction="input">
					<name>dest_expr</name>	
					<packed>width-1 : 0</packed>						   
				</port>				
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>						
			</ports>
		</checker>					
		<checker vhdl_support="none">
			<name>ovl_req_ack_unique</name>
			<note>Checks that every request receives a corresponding acknowledge in a specified time window.</note>
			<file_path>ovl_req_ack_unique.v</file_path>
			<diagram>diagram_ovl_req_ack_unique.gif</diagram>
			<syntax>ovl_req_ack_unique [#(severity_level, min_cks, max_cks, method, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, req, ack, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>		
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="minParam" type="number">
					<name>min_cks</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Minimum number of clock cycles after req asserts that its corresponding acknowledge can occur.&#10;&#10;Default: 1</note>
				</param>				
				<param id="maxParam" type="number">
					<name>max_cks</name>			
					<values>
						<value default="yes">15</value>
					</values>
					<note>Maximum number of clock cycles after req asserts that its corresponding acknowledge can occur.&#10;&#10;Default: 15.</note>
				</param>				
				<param id="methodParam">
					<name>method</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>Method used to track and correlate request/acknowledge pairs.&#10;&#10;method = 0 (Default) Method suitable for a short time window (max_cks =&lt; 15).&#10;Uses internal IDs for requests. For each request, generates max_cks properties.&#10;method = 1 Method suitable for a long time window (max_cks &gt; 15).&#10;Uses time stamps (computed mod 2 max_cks) to identify requests.&#10;To process an acknowledge, the time stamp for the request at the front of the queue is used to verify that the acknowledge meets timing requirements.</note>
				</param>								
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>			
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
					<name>req</name>							   
				</port>		
				<port direction="input">
					<name>ack</name>	
				</port>	
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>						
			</ports>
		</checker>					
		<checker vhdl_support="none">
			<name>ovl_req_requires</name>
			<note>Checks that every request event initiates a valid request-response event sequence that finishes within a specified time window.</note>
			<file_path>ovl_req_requires.v</file_path>
			<diagram>diagram_ovl_req_requires.gif</diagram>
			<syntax>ovl_req_requires [#(severity_level, min_cks, max_cks, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, req_trigger, req_follower, resp_leader, resp_trigger, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>		
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="minParam" type="number">
					<name>min_cks</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Minimum number of clock cycles after req_trigger is TRUE that the event sequence can finish.&#10;Value of min_cks must be &gt; 0.&#10;&#10;Default: 1.</note>
				</param>				
				<param id="maxParam" type="number">
					<name>max_cks</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Maximum number of clock cycles after req_trigger is TRUE that the event sequence should finish.&#10;The special value 0 selects no upper bound.&#10;If max_cks not equal 0, then max_cks must be min_cks.&#10;&#10;Default: 0.</note>
				</param>				
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>			
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
					<name>req_trigger</name>							   
				</port>		
				<port direction="input">
					<name>req_follower</name>	
				</port>	
				<port direction="input">
					<name>resp_leader</name>	
				</port>	
				<port direction="input">
					<name>resp_trigger</name>	
				</port>					
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>						
			</ports>
		</checker>							
		<checker vhdl_support="none">
			<name>ovl_stack</name>
			<note>Checks the data integrity of a stack and checks that the stack does not overflow or underflow.</note>
			<file_path>ovl_stack.v</file_path>
			<diagram>diagram_ovl_stack.gif</diagram>
			<syntax>ovl_stack [#(severity_level, depth, width, high_water_mark, push_latency, pop_latency, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, push, push_data, pop, pop_data, full, empty, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>		
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of a data item.&#10;&#10;Default: 1.</note>
				</param>				
				<param id="depthParam" type="number">
					<name>depth</name>			
					<values>
						<value default="yes">2</value>
					</values>
					<note>Stack depth. The depth must be &gt; 0.&#10;&#10;Default: 2.</note>
				</param>				
				<param id="pushParam" type="number">
					<name>push_latency</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Latency for push operation.&#10;&#10;push_latency = 0 (Default) Value of push_data is valid and the push operation is performed in the same cycle push asserts.&#10;push_latency &gt; 0 Value of push_data is valid and the push operation is performed push_latency cycles after push asserts.</note>
				</param>				
				<param id="popParam" type="number">
					<name>pop_latency</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Latency for pop operation.&#10;&#10;pop_latency = 0 (Default) Value of pop_data is valid and the pop operation is performed in the same cycle pop asserts.&#10;pop_latency &gt; 0 Value of pop_data is valid and the pop operation is performed pop_latency cycles after pop asserts.</note>
				</param>				
				<param id="waterParam" type="number">
					<name>high_water_mark</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Stack high-water mark. Must be &lt; depth. A value of 0 disables the cover_high_water_mark cover point.&#10;&#10;Default: 0.</note>
				</param>								
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>			
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
					<name>push</name>							   
				</port>		
				<port direction="input">
					<name>push_data</name>	
					<packed>width-1 : 0</packed>
				</port>	
				<port direction="input">
					<name>pop</name>	
				</port>	
				<port direction="input">
					<name>pop_data</name>	
					<packed>width-1 : 0</packed>
				</port>		
				<port direction="input">
					<name>full</name>	
				</port>	
				<port direction="input">
					<name>empty</name>	
				</port>					
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>						
			</ports>
		</checker>									
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_time</name>
			<note>Checks that the value of an expression remains TRUE for a specified number of cycles after a start event.</note>
			<file_path>ovl_time.v</file_path>
			<diagram>diagram_ovl_time.gif</diagram>
			<syntax>ovl_time [#(severity_level, num_cks, action_on_new_start, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, start_event, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>					
				<param id="cksParam" type="number">
					<name>num_cks</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Number of cycles after start_event is TRUE that test_expr must be held TRUE.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="actionParam">
					<name>action_on_new_start</name>			
					<values>
						<value abs="0" default="yes">`OVL_IGNORE_NEW_START</value>
						<value abs="1">`OVL_RESET_ON_NEW_START</value>
						<value abs="2">`OVL_ERROR_ON_NEW_START</value>
					</values>
					<note>Method for handling a new start event that occurs while a check is pending.&#10;&#10;Values are: OVL_IGNORE_NEW_START, OVL_RESET_ON_NEW_START and OVL_ERROR_ON_NEW_START.&#10;Default: OVL_IGNORE_NEW_START.</note>
				</param>											
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
					<name>start_event</name>
				</port>				
				<port direction="input">
				   <name>test_expr</name>			   
				</port>					
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>		
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_transition</name>
			<note>Checks that the value of an expression transitions properly from a start state to the specified next state.</note>
			<file_path>ovl_transition.v</file_path>
			<diagram>diagram_ovl_transition.gif</diagram>
			<syntax>ovl_transition [#(severity_level, width, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, start_state, next_state, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>					
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr argument.&#10;&#10;Default: 1.</note>
				</param>	
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
				   <name>test_expr</name>			   
				   <packed>width-1 : 0</packed>
				</port>					
				<port direction="input">
					<name>start_state</name>
					<packed>width-1 : 0</packed>
				</port>				
				<port direction="input">
					<name>next_state</name>		
					<packed>width-1 : 0</packed>				   
				</port>					
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>				
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_unchange</name>
			<note>Checks that the value of an expression does not change for a specified number of cycles after a start event initiates checking.</note>
			<file_path>ovl_unchange.v</file_path>
			<diagram>diagram_ovl_unchange.gif</diagram>
			<syntax>ovl_unchange [#(severity_level, width, num_cks, action_on_new_start, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, start_event, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr argument.&#10;&#10;Default: 1.</note>
				</param>
				<param id="cksParam" type="number">
					<name>num_cks</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Number of cycles test_expr should remain unchanged after a start event.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="actionParam">
					<name>action_on_new_start</name>			
					<values>
						<value abs="0" default="yes">`OVL_IGNORE_NEW_START</value>
						<value abs="1">`OVL_RESET_ON_NEW_START</value>
						<value abs="2">`OVL_ERROR_ON_NEW_START</value>
					</values>
					<note>Method for handling a new start event that occurs before num_cks clock cycles transpire without a change in the value of test_expr.&#10;&#10;Values are: OVL_IGNORE_NEW_START, OVL_RESET_ON_NEW_START and OVL_ERROR_ON_NEW_START.&#10;Default: OVL_IGNORE_NEW_START.</note>
				</param>											
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
					<name>start_event</name>
				</port>				
				<port direction="input">
				   <name>test_expr</name>			   
				   <packed>width-1:0</packed>					   
				</port>					
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>			
		<checker vhdl_support="none">
			<name>ovl_valid_id</name>
			<note>Checks that each issued ID is returned within a specified time window; that returned IDs match issued IDs; and that the issued and outstanding IDs do not exceed specified limits.</note>
			<file_path>ovl_valid_id.v</file_path>
			<diagram>diagram_ovl_valid_id.gif</diagram>
			<syntax>ovl_valid_id [#(severity_level, min_cks, max_cks, width, max_id_instances, max_ids, max_instances_per_id, instance_count_width, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, issued, issued_id, returned, returned_id, flush, flush_id, issued_count, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">2</value>
					</values>
					<note>Width of the issued_id, returned_id and flush_id.&#10;&#10;Default: 2.</note>
				</param>
				<param id="minParam" type="number">
					<name>min_cks</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Minimum number of clock cycles an ID instance must be outstanding. Must be &gt; 0.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="maxParam">
					<name>max_cks</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Maximum number of clock cycles an ID instance can be outstanding. Must be &gt;= min_cks.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="idInstancesParam">
					<name>max_id_instances</name>			
					<values>
						<value default="yes">2</value>
					</values>
					<note>Maximum number of ID instances that can be outstanding at any time.&#10;&#10;Default: 2.</note>
				</param>	
				<param id="idParam">
					<name>max_ids</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Maximum number of different IDs that can be outstanding at any time.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="instancesIdParam">
					<name>max_instances_per_id</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Maximum number of instances of a single ID that can be outstanding at any time.&#10;&#10;Default: 1.</note>
				</param>	
				<param id="instanceWidthParam">
					<name>instance_count_width</name>			
					<values>
						<value default="yes">2</value>
					</values>
					<note>Width of issued_count.&#10;&#10;Default: 2.</note>
				</param>					
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
					<name>issued</name>
				</port>				
				<port direction="input">
				   <name>issued_id</name>			   
				   <packed>width-1:0</packed>					   
				</port>					
				<port direction="input">
				   <name>returned</name>			   
				</port>					
				<port direction="input">
				   <name>returned_id</name>			   
				   <packed>width-1:0</packed>					   
				</port>					
				<port direction="input">
				   <name>flush</name>			   
				</port>					
				<port direction="input">
				   <name>flush_id</name>			   
				   <packed>width-1:0</packed>					   
				</port>					
				<port direction="input">
				   <name>issued_count</name>			   
				   <packed>instance_count_width-1:0</packed>					   
				</port>									
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>					
		<checker vhdl_support="none">
			<name>ovl_value</name>
			<note>Checks that the value of an expression either matches a value in a specified list or does not match any value in the list (as determined by a mode signal).</note>
			<file_path>ovl_value.v</file_path>
			<diagram>diagram_ovl_value.gif</diagram>
			<syntax>ovl_value [#(severity_level, num_values, width, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, vals, disallow, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="numParam" type="number">
					<name>num_values</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Number of values in vals. Must be &gt;= 1.&#10;&#10;Default: 1.</note>
				</param>				
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of test_expr.&#10;&#10;Default: 1.</note>
				</param>				
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
				   <name>test_expr</name>			   
				   <packed>width-1:0</packed>					   
				</port>					
				<port direction="input">
				   <name>vals</name>			   
				   <packed>num_values*width-1:0</packed>					   
				</port>		
				<port direction="input">
				   <name>disallow</name>			   
				</port>	
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>							
		<checker vhdl_support="none">
			<name>ovl_value_coverage</name>
			<note>Ensures that values of a specified expression are covered during simulation.</note>
			<file_path>ovl_value_coverage.v</file_path>
			<diagram>diagram_ovl_value_coverage.gif</diagram>
			<syntax>ovl_value_coverage [#(severity_level, width, is_not_width, is_not_count, value_coverage, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, is_not, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>				
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of test_expr.&#10;&#10;Default: 1.</note>
				</param>				
				<param id="notWidthParam" type="number">
					<name>is_not_width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Maximum width of an is_not value.&#10;&#10;Default: 1.</note>
				</param>			
				<param id="notCountParam" type="number">
					<name>is_not_count</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Number of is_not values.&#10;&#10;Default: 0.</note>
				</param>	
				<param id="covParam" type="number">
					<name>value_coverage</name>			
					<values>
						<value default="yes">0</value>						
						<value>1</value>
					</values>
					<note>Whether or not to perform value_coverage checks.&#10;&#10;value_coverage = 0 (Default) Turns off the value_coverage check.&#10;value_coverage = 1 Turns on the value_coverage check.</note>
				</param>					
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
				   <name>test_expr</name>			   
				   <packed>width-1:0</packed>					   
				</port>					
				<port direction="input">
				   <name>is_not</name>			   
				   <packed>is_not_width - 1:0</packed>					   
				</port>		
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>				
			</ports>
		</checker>									
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_width</name>
			<note>Checks that when value of an expression is TRUE, it remains TRUE for a minimum number of clock cycles and transitions from TRUE no later than a maximum number of clock cycles.</note>
			<file_path>ovl_width.v</file_path>
			<diagram>diagram_ovl_width.gif</diagram>
			<syntax>ovl_width [#(severity_level, min_cks, max_cks, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>		
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>					
				<param id="minParam" type="number">
					<name>min_cks</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Minimum number of clock edges test_expr must remain TRUE once it is sampled TRUE.&#10;The special case where min_cks is 0 turns off minimum checking (i.e., test_expr can transition from TRUE in the next clock cycle).&#10;&#10;Default: 1 (i.e., same as 0).</note>
				</param>
				<param id="maxParam" type="number">
					<name>max_cks</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Maximum number of clock edges test_expr can remain TRUE once it is sampled TRUE.&#10;The special case where max_cks is 0 turns off maximum checking (i.e., test_expr can remain TRUE for any number of cycles).&#10;&#10;Default: 1 (i.e., test_expr must transition from TRUE in the next clock cycle).</note>
				</param>												
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
				   <name>test_expr</name>			   				   
				</port>				
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>							
			</ports>
		</checker>			
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_win_change</name>
			<note>Checks that the value of an expression changes in a specified window between a start event and an end event.</note>
			<file_path>ovl_win_change.v</file_path>
			<diagram>diagram_ovl_win_change.gif</diagram>
			<syntax>ovl_win_change [#(severity_level, width, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, start_event, test_expr, end_event, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>		
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>				
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr argument.&#10;&#10;Default: 1.</note>
				</param>											
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
					<name>start_event</name>
				</port>				
				<port direction="input">
				   <name>test_expr</name>			   
				   <packed>width-1:0</packed>					   
				</port>		
				<port direction="input">
					<name>end_event</name>
				</port>				
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>						
			</ports>
		</checker>		
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_win_unchange</name>
			<note>Checks that the value of an expression does not change in a specified window between a start event and an end event.</note>
			<file_path>ovl_win_unchange.v</file_path>
			<diagram>diagram_ovl_win_unchange.gif</diagram>
			<syntax>ovl_win_unchange [#(severity_level, width, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, start_event, test_expr, end_event, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr argument.&#10;&#10;Default: 1.</note>
				</param>					
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
					<name>start_event</name>
				</port>				
				<port direction="input">
				   <name>test_expr</name>		
				   <packed>width-1:0</packed>		   			   
				</port>		
				<port direction="input">
					<name>end_event</name>
				</port>				
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>						
			</ports>
		</checker>			
		<checker vhdl_support="wrap" verilog_support="full">
			<name>ovl_window</name>
			<note>Checks that the value of an expression is TRUE in a specified window between a start event and an end event.</note>
			<file_path>ovl_window.v</file_path>
			<diagram>diagram_ovl_window.gif</diagram>
			<syntax>ovl_window [#(severity_level, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, start_event, test_expr, end_event, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>			
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
					<name>start_event</name>
				</port>				
				<port direction="input">
				   <name>test_expr</name>			   			   
				</port>		
				<port direction="input">
					<name>end_event</name>
				</port>				
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>					
			</ports>
		</checker>	
		<checker vhdl_support="none">
			<name>ovl_xproduct_bit_coverage</name>
			<note>Ensures functional cross product bit coverage of two vectors.</note>
			<file_path>ovl_xproduct_bit_coverage.v</file_path>
			<diagram>diagram_ovl_xproduct_bit_coverage.gif</diagram>
			<syntax>ovl_xproduct_bit_coverage [#(severity_level, width1, width2, test_expr2_enable, coverage_check, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr1, test_expr2, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="width1Param" type="number">
					<name>width1</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr1.&#10;&#10;Default: 1.</note>
				</param>					
				<param id="width2Param" type="number">
					<name>width2</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr2.&#10;&#10;Default: 1.</note>
				</param>					
				<param id="testParam">
					<name>test_expr2_enable</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>Whether or not to use test_expr2 as the second vector.&#10;&#10;test_expr2_enable = 0 (Default) Use test_expr1 as the second vector (test_expr2 is ignored).&#10;test_expr2_enable = 1 Use test_expr2 as the second vector.</note>
				</param>					
				<param id="coverParam">
					<name>coverage_check</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>Whether or not to perform coverage checks.&#10;&#10;coverage_check = 0 (Default) Turns off the coverage check.&#10;coverage_check = 1 Turns on the coverage check.</note>
				</param>									
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
				   <name>test_expr1</name>		
				   <packed>width1-1:0</packed>		   			   
				</port>		
				<port direction="input">
				   <name>test_expr2</name>		
				   <packed>width2-1:0</packed>		   			   
				</port>		
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>						
			</ports>
		</checker>	
		<checker vhdl_support="none">
			<name>ovl_xproduct_value_coverage</name>
			<note>Ensures functional cross product value coverage of two variables.</note>
			<file_path>ovl_xproduct_value_coverage.v</file_path>
			<diagram>diagram_ovl_xproduct_value_coverage.gif</diagram>
			<syntax>ovl_xproduct_value_coverage [#(severity_level, width1,width2, val1_width, val2_width, val1_count, val2_count, min1, min2, max1, max2, coverage_check, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr1, test_expr2, val1, val2);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="width1Param" type="number">
					<name>width1</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr1.&#10;&#10;Default: 1.</note>
				</param>					
				<param id="width2Param" type="number">
					<name>width2</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of the test_expr2.&#10;&#10;Default: 1.</note>
				</param>					
				<param id="valwidth1Param" type="number">
					<name>val1_width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of each item in val1.&#10;&#10;Default: 1.</note>
				</param>					
				<param id="valwidth2Param" type="number">
					<name>val2_width</name>			
					<values>
						<value default="yes">1</value>
					</values>
					<note>Width of each item in val2.&#10;&#10;Default: 1.</note>
				</param>					
				<param id="valcount1Param" type="number">
					<name>val1_count</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Number of items in val1.&#10;&#10;Default: 0.</note>
				</param>					
				<param id="valcount2Param" type="number">
					<name>val2_count</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Number of items in val1.&#10;&#10;Default: 0.</note>
				</param>					
				<param id="min1Param" type="number">
					<name>min1</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Minimum value of the range of test_expr1. Ignored unless val1_count = 0.&#10;&#10;Default : 0.</note>
				</param>					
				<param id="min2Param" type="number">
					<name>min2</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Minimum value of the range of test_expr1. Ignored unless val1_count = 0.&#10;&#10;Default : 0.</note>
				</param>					
				<param id="max1Param" type="number">
					<name>max1</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Maximum value of the range of test_expr1. Ignored unless val1_count = 0.&#10;&#10;max1 = 0 (Default) Maximum value is the largest possible value of test_expr1.&#10;max1 &gt; 0 Maximum value is max1.</note>
				</param>					
				<param id="max2Param" type="number">
					<name>max2</name>			
					<values>
						<value default="yes">0</value>
					</values>
					<note>Maximum value of the range of test_expr2. Ignored unless val2_count = 0.&#10;&#10;max2 = 0 (Default) Maximum value is the largest possible value of test_expr2.&#10;max2 &gt; 0 Maximum value is max2.</note>
				</param>									
				<param id="coverParam">
					<name>coverage_check</name>			
					<values>
						<value default="yes">0</value>
						<value>1</value>
					</values>
					<note>Whether or not to perform coverage checks.&#10;&#10;coverage_check = 0 (Default) Turns off the coverage check.&#10;coverage_check = 1 Turns on the coverage check.</note>
				</param>									
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
				   <name>test_expr1</name>		
				   <packed>width1-1:0</packed>		   			   
				</port>		
				<port direction="input">
				   <name>test_expr2</name>		
				   <packed>width2-1:0</packed>		   			   
				</port>		
				<port direction="input">
				   <name>val1</name>		
				   <packed>val1_width-1:0</packed>		   			   
				</port>		
				<port direction="input">
				   <name>val2</name>		
				   <packed>val2_width-1:0</packed>		   			   
				</port>						
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>						
			</ports>
		</checker>			
		<checker vhdl_support="full" verilog_support="full">
			<name>ovl_zero_one_hot</name>
			<note>Checks that the value of an expression is zero or one-hot.</note>
			<file_path>ovl_zero_one_hot.v</file_path>
			<diagram>diagram_ovl_zero_one_hot.gif</diagram>
			<syntax>ovl_zero_one_hot [#(severity_level, width, property_type, msg, coverage_level, clock_edge, reset_polarity, gating_type)] instance_name (clock, reset, enable, test_expr, fire);</syntax>
			<params>
				<param_ref id="severityParam"/>
				<param_ref id="propertyParam"/>
				<param_ref id="msgParam"/>
				<param_ref id="coverageParam"/>	
				<param_ref id="clockParam"/>
				<param_ref id="resetParam"/>
				<param_ref id="gatingParam"/>	
				<param id="widthParam" type="number">
					<name>width</name>			
					<values>
						<value default="yes">32</value>
					</values>
					<note>Width of the test_expr argument.&#10;&#10;Default: 32.</note>
				</param>					
			</params>
			<ports>
				<port direction = "input">
					<name>clock</name>
		        </port>
				<port direction="input">
					<name>reset</name>
				</port>
				<port direction="input">
					<name>enable</name>
				</port>	
				<port direction="input">
				   <name>test_expr</name>		
				   <packed>width-1:0</packed>		   			   
				</port>				
				<port direction="output">
				   <name>fire</name>
				   <packed>`OVL_FIRE_WIDTH-1 : 0</packed>
				</port>									
			</ports>
		</checker>					
	</checkers>
	<globals>
		<param id="languageParam">
			<name>Language</name>			
			<values>
				<value default="yes" verilog_name="OVL_SVA">SVA</value>			
				<value verilog_name="OVL_VERILOG">Verilog</value>
				<value verilog_name="OVL_PSL">PSL (Verilog)</value>
				<value>VHDL</value>
			</values>
			<note>Checker HDL language to be compiled.</note>
		</param>
		<param id="xcheckParam">
			<name vhdl_name="xcheck_ctrl">X/Z Check</name>			
			<values>
				<value vhdl_name="OVL_OFF" verilog_name="OVL_XCHECK_OFF">OFF</value>			
				<value default="yes" vhdl_name="OVL_ON" verilog_name="">ON</value>
			</values>
		</param>
		<param id="implicitxcheckParam">
			<name vhdl_name="implicit_xcheck_ctrl">Implicit X/Z Check</name>			
			<values>
				<value vhdl_name="OVL_OFF" verilog_name="OVL_IMPLICIT_XCHECK_OFF">OFF</value>			
				<value default="yes" vhdl_name="OVL_ON" verilog_name="">ON</value>
			</values>
		</param>
		<param id="initMsgParam" hidden="yes">
			<name vhdl_name="init_msg_ctrl">Init. Message</name>			
			<values>
				<value default="yes">OVL_OFF</value>			
				<value>OVL_ON</value>
			</values>
		</param>
		<param id="initCountParam" hidden="yes">
			<name vhdl_name="init_count_ctrl">Init. Count</name>			
			<values>
				<value default="yes">OVL_OFF</value>			
				<value>OVL_ON</value>
			</values>
		</param>		
		<param id="assertParam">
			<name vhdl_name="assert_ctrl">Assertion</name>			
			<values>
				<value vhdl_name="OVL_OFF" verilog_name="">OFF</value>			
				<value vhdl_name="OVL_ON" verilog_name="OVL_ASSERT_ON" default="yes">ON</value>
			</values>
			<note>Activates or deactivates assertion logic. Default: deactivated.</note>
		</param>
		<param id="coverParam">
			<name vhdl_name="cover_ctrl">Coverage</name>			
			<values>
				<value vhdl_name="OVL_OFF" verilog_name="">OFF</value>			
				<value vhdl_name="OVL_ON" verilog_name="OVL_COVER_ON" default="yes">ON</value>
			</values>
			<note>Activates or deactivates coverage logic. Default: deactivated.</note>
		</param>
		<param id="globalResetParam" hidden="yes">
			<name vhdl_name="global_reset_ctrl">Global Reset</name>			
			<values>
				<value default="yes">OVL_OFF</value>			
				<value>OVL_ON</value>
			</values>
		</param>
		<param id="finishParam" hidden="yes">
			<name vhdl_name="finish_ctrl">Finish</name>			
			<values>
				<value default="yes">OVL_OFF</value>			
				<value>OVL_ON</value>
			</values>
		</param>
		<param id="gatingParam" hidden="yes">
			<name vhdl_name="gating_ctrl">Gating</name>			
			<values>
				<value default="yes">OVL_OFF</value>			
				<value>OVL_ON</value>
			</values>
		</param>
		<param id="maxErrorParam" hidden="yes">
			<name vhdl_name="max_report_error">Max. Report Error</name>			
			<values>
				<value default="yes">15</value>			
			</values>
		</param>
		<param id="maxCoverParam" hidden="yes">
			<name vhdl_name="max_report_cover_point">Max. Report Cover Point</name>			
			<values>
				<value default="yes">15</value>			
			</values>
		</param>
		<param id="runtimeParam" hidden="yes">
			<name vhdl_name="runtime_after_fatal">Runtime After Fatal</name>			
			<values>
				<value default="yes">&quot;100 ns    &quot;</value>			
			</values>
		</param>
		<param id="severityParam" hidden="yes">
			<name vhdl_name="severity_level_default">severity_level_default</name>			
			<values>
				<value default="yes">OVL_ERROR</value>			
			</values>
		</param>
		<param id="propertyParam" hidden="yes">
			<name vhdl_name="property_type_default">property_type_default</name>			
			<values>
				<value default="yes">OVL_ASSERT</value>			
			</values>
		</param>
		<param id="msgParam" hidden="yes">
			<name vhdl_name="msg_default">msg_default</name>			
			<values>
				<value default="yes">&quot;VIOLATION                                         &quot;</value>			
			</values>
		</param>
		<param id="coverageParam" hidden="yes">
			<name vhdl_name="coverage_level_default">coverage_level_default</name>			
			<values>
				<value default="yes">OVL_COVER_BASIC</value>			
			</values>
		</param>
		<param id="clockParam" hidden="yes">
			<name vhdl_name="clock_edge_default">clock_edge_default</name>			
			<values>
				<value default="yes">OVL_POSEDGE</value>			
			</values>
		</param>
		<param id="resetParam" hidden="yes">
			<name vhdl_name="reset_polarity_default">reset_polarity_default</name>			
			<values>
				<value default="yes">OVL_ACTIVE_LOW</value>			
			</values>
		</param>
		<param id="gatingTypeParam" hidden="yes">
			<name vhdl_name="gating_type_default">Gating Type</name>			
			<values>
				<value default="yes">OVL_GATE_CLOCK</value>			
			</values>
		</param>
		<param id="othersParam" type="user">
			<name>Extra Defines</name>			
			<values>
				<value default="yes"></value>			
			</values>
			<note>Extra compiler options (example: +define+OVL_INIT_MSG).</note>
		</param>		
	</globals>
	<params>
		<param id="severityParam" vhdl_type="ovl_severity_level">
			<name>severity_level</name>			
			<values>
				<value abs="0">`OVL_FATAL</value>			
				<value abs="1" default="yes">`OVL_ERROR</value>
				<value abs="2">`OVL_WARNING</value>			
				<value abs="3">`OVL_INFO</value>			
			</values>
			<note>Severity of the failure.&#10;&#10;Default: OVL_SEVERITY_DEFAULT (OVL_ERROR).</note>
		</param>
		<param id="propertyParam" vhdl_type="ovl_property_type">
			<name>property_type</name>			
			<values>			
				<value abs="0" default="yes">`OVL_ASSERT</value>
				<value abs="1">`OVL_ASSUME</value>			
				<value abs="2">`OVL_IGNORE</value>			
				<value abs="3">`OVL_ASSERT_2STATE</value>	
				<value abs="4">`OVL_ASSUME_2STATE</value>	
			</values>
			<note>Property type.&#10;&#10;Default: OVL_PROPERTY_DEFAULT (OVL_ASSERT).</note>
		</param>		
		<param id="msgParam" type="string" vhdl_type="string">
			<name>msg</name>			
			<values>			
				<value abs="&quot;VIOLATION&quot;" default="yes">`OVL_MSG_DEFAULT</value>
			</values>
			<note>Error message printed when assertion fails.&#10;&#10;Default: OVL_MSG_DEFAULT ("VIOLATION").</note>
		</param>	
		<param id="coverageParam" type="multi" vhdl_type="ovl_coverage_level">
			<name>coverage_level</name>			
			<values>			
				<value abs="0" exclusive="1">`OVL_COVER_NONE</value>			
				<value abs="1">`OVL_COVER_SANITY</value>			
				<value abs="2" default="yes">`OVL_COVER_BASIC</value>				
				<value abs="4">`OVL_COVER_CORNER</value>	
				<value abs="8">`OVL_COVER_STATISTIC</value>	
				<value abs="15" exclusive="1">`OVL_COVER_ALL</value>	
			</values>
			<note>Coverage level.&#10;&#10;Default: OVL_COVER_DEFAULT (OVL_COVER_BASIC).</note>
		</param>	
		<param id="clockParam" vhdl_type="ovl_active_edges">
			<name>clock_edge</name>			
			<values>								
				<value abs="1" default="yes">`OVL_POSEDGE</value>				
				<value abs="2">`OVL_NEGEDGE</value>		
			</values>
			<note>Active edge of the clock input.&#10;&#10;Default: OVL_CLOCK_EDGE_DEFAULT (OVL_POSEDGE).</note>
		</param>	
		<param id="clockReadParam" vhdl_type="ovl_active_edges">
			<name>ren_edge</name>			
			<values>								
				<value abs="1" default="yes">`OVL_POSEDGE</value>				
				<value abs="2">`OVL_NEGEDGE</value>		
			</values>
			<note>Active edge of the ren input&#10;&#10;Default: OVL_CLOCK_EDGE_DEFAULT (OVL_POSEDGE)..</note>
		</param>	
		<param id="clockWriteParam" vhdl_type="ovl_active_edges">
			<name>wen_edge</name>			
			<values>								
				<value abs="1" default="yes">`OVL_POSEDGE</value>				
				<value abs="2">`OVL_NEGEDGE</value>		
			</values>
			<note>Active edge of the wen input&#10;&#10;Default: OVL_CLOCK_EDGE_DEFAULT (OVL_POSEDGE)..</note>
		</param>	
		<param id="resetParam" vhdl_type="ovl_reset_polarity">
			<name>reset_polarity</name>			
			<values>							
				<value abs="0" default="yes">`OVL_ACTIVE_LOW</value>				
				<value abs="1">`OVL_ACTIVE_HIGH</value>	
			</values>
			<note>Polarity (active level) of the reset input.&#10;&#10;Default: OVL_RESET_POLARITY_DEFAULT (OVL_ACTIVE_LOW).</note>
		</param>		
		<param id="gatingParam" vhdl_type="ovl_gating_type">
			<name>gating_type</name>			
			<values>							
				<value abs="0">`OVL_GATE_NONE</value>			
				<value abs="1" default="yes">`OVL_GATE_CLOCK</value>					
				<value abs="2">`OVL_GATE_RESET</value>	
			</values>
			<note>Gating behavior of the checker when enable is FALSE.&#10;&#10;Default: OVL_GATING_TYPE_DEFAULT (OVL_GATE_CLOCK).</note>
		</param>			
	</params>
</library>



